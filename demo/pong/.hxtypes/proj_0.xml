<haxe>
	<class path="cocktailCore.style.computer.BoxStylesComputer" params="" file="/Users/lexa/Documents/repositories/lexoyo_Cocktail/demo/games/libs/cocktailCore/style/computer/BoxStylesComputer.hx">
		<measure public="1" set="method" line="62">
			<f a="style:containingDOMElementData">
				<c path="cocktailCore.style.abstract.AbstractStyle"/>
				<t path="cocktailCore.style.ContainingDOMElementData"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Takes the styles of a domElement and measure each of its box model properties from 
	 * them (paddings, margins, width, height...)
	 * 
	 * Stores all the style computed value in its computed style structure
	 * 
	 * @param	style contains each of a DOMElement styles, a reference to the DOMElement and a structure to
	 * hold computed styles.
	 * @param	containingDOMElementData the width and height dimensions of the containing block of this 
	 * DOMElement, used when computing styles determined as percent or "auto"
	 </haxe_doc>
		</measure>
		<shrinkToFit public="1" set="method" line="103">
			<f a="style:containingDOMElementData:minimumWidth">
				<c path="cocktailCore.style.abstract.AbstractStyle"/>
				<t path="cocktailCore.style.ContainingDOMElementData"/>
				<c path="Int"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
	 * Shrink the width a DOMElement to fit its content. Doesn't apply to a
	 * non-replaced block so return the current width
	 * @param	style
	 * @param	containingDOMElementData
	 * @param	minimumWidth the minimum width of the DOMElement if shrinked, corresponding 
	 * to its content width
	 * @return
	 </haxe_doc>
		</shrinkToFit>
		<applyContentHeight public="1" set="method" line="116">
			<f a="style:cotainingDOMElementData:childrenHeight">
				<c path="cocktailCore.style.abstract.AbstractStyle"/>
				<t path="cocktailCore.style.ContainingDOMElementData"/>
				<c path="Int"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
	 * Return the height that should be used when the 'height' of a ContainerDOMElement is specified
	 * as 'auto'. The default behaviour is to use the total height of its children
	 * @param	style
	 * @param	cotainingDOMElementData
	 * @param	childrenHeight
	 * @return
	 </haxe_doc>
		</applyContentHeight>
		<measureDimensionsConstraints set="method" line="132">
			<f a="style:containingDOMElementData">
				<c path="cocktailCore.style.abstract.AbstractStyle"/>
				<t path="cocktailCore.style.ContainingDOMElementData"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Compute the 'dimensions constraints' styles :
	 * min-height, max-height, min-width and max-width
	 </haxe_doc>
		</measureDimensionsConstraints>
		<measurePositionOffsets set="method" line="152">
			<f a="style:containingDOMElementData">
				<c path="cocktailCore.style.abstract.AbstractStyle"/>
				<t path="cocktailCore.style.ContainingDOMElementData"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Compute the 'position offsets' styles :
	 * top, left, bottom, right, used if the DOMElement
	 * is 'positioned' (position style other than 'static')
	 </haxe_doc>
		</measurePositionOffsets>
		<measureVerticalPaddings set="method" line="175">
			<f a="style:containingDOMElementData">
				<c path="cocktailCore.style.abstract.AbstractStyle"/>
				<t path="cocktailCore.style.ContainingDOMElementData"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Compute the top and bottom paddings of
	 * the DOMElement's box model
	 </haxe_doc>
		</measureVerticalPaddings>
		<measureHorizontalPaddings set="method" line="188">
			<f a="style:containingDOMElementData">
				<c path="cocktailCore.style.abstract.AbstractStyle"/>
				<t path="cocktailCore.style.ContainingDOMElementData"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Compute the left and right paddings of
	 * the DOMElement's box model
	 </haxe_doc>
		</measureHorizontalPaddings>
		<measureWidthAndHorizontalMargins set="method" line="204">
			<f a="style:containingDOMElementData">
				<c path="cocktailCore.style.abstract.AbstractStyle"/>
				<t path="cocktailCore.style.ContainingDOMElementData"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Measure the width and the horizontal margins
	 * of the DOMElement
	 </haxe_doc>
		</measureWidthAndHorizontalMargins>
		<measureAutoWidth set="method" line="225">
			<f a="style:containingDOMElementData">
				<c path="cocktailCore.style.abstract.AbstractStyle"/>
				<t path="cocktailCore.style.ContainingDOMElementData"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Measure the width and the horizontal margins
	 * of the DOMElement in the case where the 'width'
	 * is set as 'auto' and thus depends on the size of the 
	 * margins.
	 * 
	 * An auto width is equal to the containing DOMElement width minus
	 * horizontal paddings and margins.
	 </haxe_doc>
		</measureAutoWidth>
		<measureWidth set="method" line="246">
			<f a="style:containingDOMElementData">
				<c path="cocktailCore.style.abstract.AbstractStyle"/>
				<t path="cocktailCore.style.ContainingDOMElementData"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Measure the width when it is not 'auto'.
	 * It might be a percentage of its containing 
	 * DOMElement width or a length value defined
	 * in pixels or any other length unit
	 </haxe_doc>
		</measureWidth>
		<measureHeightAndVerticalMargins set="method" line="265">
			<f a="style:containingDOMElementData">
				<c path="cocktailCore.style.abstract.AbstractStyle"/>
				<t path="cocktailCore.style.ContainingDOMElementData"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Measure the height and
	 * vertical margins of the 
	 * DOMElement
	 </haxe_doc>
		</measureHeightAndVerticalMargins>
		<measureAutoHeight set="method" line="292">
			<f a="style:containingDOMElementData">
				<c path="cocktailCore.style.abstract.AbstractStyle"/>
				<t path="cocktailCore.style.ContainingDOMElementData"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Measure the height and the vertical margins
	 * of the DOMElement in the case where the 'height' style
	 * is set as 'auto' and thus depends on the total height
	 * of its content
	 * 
	 * An auto height can't be determined until all of its children
	 * height are computed. The auto height of a DOMElement
	 * is the addition of all of the offset heights (margin + padding + content height)
	 * of its children.
	 </haxe_doc>
		</measureAutoHeight>
		<measureHeight set="method" line="311">
			<f a="style:containingDOMElementData">
				<c path="cocktailCore.style.abstract.AbstractStyle"/>
				<t path="cocktailCore.style.ContainingDOMElementData"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Measure the height and the vertical margins
	 * of the DOMElement in the case where the height is
	 * either a percentage of the containing DOMElement height
	 * or a length value exprimend in a supported unit, such
	 * as pixel
	 </haxe_doc>
		</measureHeight>
		<constrainDimensions set="method" line="331">
			<f a="style">
				<c path="cocktailCore.style.abstract.AbstractStyle"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Apply the dimensions constraints, such as 
	 * max-height to the computed width and height
	 * values
	 </haxe_doc>
		</constrainDimensions>
		<getComputedWidth set="method" line="389">
			<f a="style:containingDOMElementData">
				<c path="cocktailCore.style.abstract.AbstractStyle"/>
				<t path="cocktailCore.style.ContainingDOMElementData"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
	 * Compute the size of the width when not 'auto' and return it as pixels
	 </haxe_doc>
		</getComputedWidth>
		<getComputedAutoWidth set="method" line="399">
			<f a="style:containingDOMElementData">
				<c path="cocktailCore.style.abstract.AbstractStyle"/>
				<t path="cocktailCore.style.ContainingDOMElementData"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
	 * Compute the size of the width when 'auto' and return it as pixels. It is equal to
	 * the remaining width of the containing DOMElement once the margins and paddings width have been
	 * removed
	 </haxe_doc>
		</getComputedAutoWidth>
		<getComputedHeight set="method" line="411">
			<f a="style:containingDOMElementData">
				<c path="cocktailCore.style.abstract.AbstractStyle"/>
				<t path="cocktailCore.style.ContainingDOMElementData"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
	 * Get the computed height of the DOMElement when not 'auto' and returns it as pixels
	 </haxe_doc>
		</getComputedHeight>
		<getComputedAutoHeight set="method" line="421">
			<f a="style:containingDOMElementData">
				<c path="cocktailCore.style.abstract.AbstractStyle"/>
				<t path="cocktailCore.style.ContainingDOMElementData"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
	 * Get the computed height of the DOMElement when 'auto' and returns it as pixels. Default for 'auto' is 0
	 * as its children total height is not known yet, it will be set once all its children have been
	 * laid out
	 </haxe_doc>
		</getComputedAutoHeight>
		<getComputedMarginLeft set="method" line="432">
			<f a="style:containingDOMElementData">
				<c path="cocktailCore.style.abstract.AbstractStyle"/>
				<t path="cocktailCore.style.ContainingDOMElementData"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
	 * Compute the size of the left margin and return it as pixels
	 </haxe_doc>
		</getComputedMarginLeft>
		<getComputedMarginRight set="method" line="440">
			<f a="style:containingDOMElementData">
				<c path="cocktailCore.style.abstract.AbstractStyle"/>
				<t path="cocktailCore.style.ContainingDOMElementData"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
	 * Compute the size of the right margin and return it as pixels
	 </haxe_doc>
		</getComputedMarginRight>
		<getComputedMarginTop set="method" line="448">
			<f a="style:containingDOMElementData">
				<c path="cocktailCore.style.abstract.AbstractStyle"/>
				<t path="cocktailCore.style.ContainingDOMElementData"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
	 * Compute the size of the top margin and return it as pixels
	 </haxe_doc>
		</getComputedMarginTop>
		<getComputedMarginBottom set="method" line="456">
			<f a="style:containingDOMElementData">
				<c path="cocktailCore.style.abstract.AbstractStyle"/>
				<t path="cocktailCore.style.ContainingDOMElementData"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
	 * Compute the size of the bottom margin and return it as pixels
	 </haxe_doc>
		</getComputedMarginBottom>
		<getComputedMargin set="method" line="480">
			<f a="marginStyleValue:opositeMarginStyleValue:containingDOMElementDimension:computedDimension:isDimensionAuto:computedPaddingsDimension:fontSize:xHeight:?isHorizontalMargin">
				<e path="cocktail.style.MarginStyleValue"/>
				<e path="cocktail.style.MarginStyleValue"/>
				<c path="Int"/>
				<c path="Int"/>
				<e path="Bool"/>
				<c path="Int"/>
				<c path="Float"/>
				<c path="Float"/>
				<e path="Bool"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
	 * Compute the value of a margin thickness from a 
	 * margin style value
	 * @param	marginStyleValue contains the value of the computed margin as a unit, percentage or defined as auto
	 * @param	opositeMarginStyleValue the complementary margin from the computed margin. For example for the left margin, it
	 * is the right margin
	 * @param	containingDOMElementDimension the width and height of the DOMElement containing the current DOMElement, used for
	 * computing percentage values
	 * @param	computedDimension a computed dimension (width or height) of the content of the current DOMElement
	 * @param isDimensionAuto wether the reference dimensions is auto, meaning its computed width id not set yet
	 * @param	computedPaddingsDimension the computed dimensions of both horizontal or vertical paddings, depending if the computed
	 * margin is horizontal or vertical
	 * @param  fontSize the computed font size of the containing DOMElement, used to compute the marginStyleValue if it is a length value
	 * defined in 'em'
	 * @param  xHeight the computed x height of the containing DOMElement, used to compute the marginStyleValue if it is a length value
	 * defined in 'ex'
	 * @param	isHorizontalMargin true if the margin is horizontal (left or right)
	 * @return the computed thickness of the margin
	 </haxe_doc>
		</getComputedMargin>
		<getComputedAutoMargin set="method" line="518">
			<f a="marginStyleValue:opositeMarginStyleValue:containingDOMElementDimension:computedDimension:isDimensionAuto:computedPaddingsDimension:fontSize:xHeight:?isHorizontalMargin">
				<e path="cocktail.style.MarginStyleValue"/>
				<e path="cocktail.style.MarginStyleValue"/>
				<c path="Int"/>
				<c path="Int"/>
				<e path="Bool"/>
				<c path="Int"/>
				<c path="Float"/>
				<c path="Float"/>
				<e path="Bool"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
	 * Return the width of an auto margin
	 </haxe_doc>
		</getComputedAutoMargin>
		<getComputedConstrainedDimension set="method" line="564">
			<f a="constrainedDimensionStyleValue:containingDOMElementDimension:isContainingDimensionAuto:fontSize:xHeight:?isMinConstraint">
				<e path="cocktail.style.ConstrainedDimensionStyleValue"/>
				<c path="Int"/>
				<e path="Bool"/>
				<c path="Float"/>
				<c path="Float"/>
				<e path="Bool"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
	 * Compute a contrain dimensions (max-height, min-width...)
	 * from a contrain style value
	 * @param	constrainedDimensionStyleValue can be defined as a unit, a percentage
	 * or to "none" if no constraint must be applied
	 * @param	containingDOMElementDimension the dimension of the DOMElement into which 
	 * the current DOMElement must fit
	 * @param  isContainingDimensionAuto wether the containinDOMElementDimension is defined as 'auto'
	 * @param  fontSize the computed font size of the containing DOMElement, used to compute the constrainedDimensionStyleValue if it is a length value
	 * defined in 'em'
	 * @param  xHeight the computed x height of the containing DOMElement, used to compute the constrainedDimensionStyleValue if it is a length value
	 * defined in 'ex'
	 * @param	isMinConstraint true if min-width or min-height is computed
	 * @return a computed contraint dimensions in pixels
	 </haxe_doc>
		</getComputedConstrainedDimension>
		<getComputedPositionOffset set="method" line="626">
			<f a="positionOffsetStyleValue:containingDOMElementDimension:fontSize:xHeight">
				<e path="cocktail.style.PositionOffsetStyleValue"/>
				<c path="Int"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
	 * Compute a position offset style (left, right, bottom and top) in pixel
	 * from a position offset style value
	 * 
	 * @param positionOffsetStyleValue might be set to 'auto', an absolute value
	 * or a percent value
	 * @param containingDOMElementDimension, dimension to use as reference to compute 
	 * from a percent value
	 * @param  fontSize the computed font size of the containing DOMElement, used to compute the PositionOffsetStyleValue if it is a length value
	 * defined in 'em'
	 * @param  xHeight the computed x height of the containing DOMElement, used to compute the PositionOffsetStyleValue if it is a length value
	 * defined in 'ex'
	 </haxe_doc>
		</getComputedPositionOffset>
		<getComputedDimension set="method" line="657">
			<f a="dimensionStyleValue:containingDOMElementDimension:isContainingDimensionAuto:fontSize:xHeight">
				<e path="cocktail.style.DimensionStyleValue"/>
				<c path="Int"/>
				<e path="Bool"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
	 * Compute the content dimension (width or height) of a DOMElement
	 * @param	dimensionStyleValue can be defined as a unit, a percent or auto
	 * @param	containingDOMElementDimension the dimension of the DOMElement into which 
	 * the current DOMElement must fit
	 * @param  isContainingDimensionAuto wether the containinDOMElementDimension is defined as 'auto'
	 * @param  fontSize the computed font size of the containing DOMElement, used to compute the DimensionStyleValue if it is a length value
	 * defined in 'em'
	 * @param  xHeight the computed x height of the containing DOMElement, used to compute the DimensionStyleValue if it is a length value
	 * defined in 'ex'
	 * @return a computed dimension in pixel
	 </haxe_doc>
		</getComputedDimension>
		<getComputedPadding set="method" line="695">
			<f a="paddingStyleValue:containingDOMElementDimension:isContainingDimensionAuto:fontSize:xHeight">
				<e path="cocktail.style.PaddingStyleValue"/>
				<c path="Int"/>
				<e path="Bool"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
	 * Compute a padding's thickness from a padding style value
	 * @param	paddingStyleValue can be defined as a unit (px, em...) or a percentage
	 * @param	containingDOMElementDimension the dimensions of the DOMElement into which 
	 * the current DOMElement must fit
	 * @param  isContainingDimensionAuto wether the containinDOMElementDimension is defined as 'auto'
	 * @param  fontSize the computed font size of the containing DOMElement, used to compute the PaddingStyleValue if it is a length value
	 * defined in 'em'
	 * @param  xHeight the computed x height of the containing DOMElement, used to compute the PaddingStyleValue if it is a length value
	 * defined in 'ex'
	 * @return a computed padding in pixel
	 </haxe_doc>
		</getComputedPadding>
		<new public="1" set="method" line="41">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * class constructor
	 </haxe_doc>
		</new>
		<haxe_doc>
 * This is the base class for all classes computing a DOMElement's box model. 
 * The box model is determined by a combination of styles such as the display of
 * an element, its width, its margins, paddings...
 * 
 * This class use the defined styles value and compute a value for them that will
 * actually be used. 
 * For example, if a width is determined as a percentage, this class compute
 * a pixel width value from it.
 * 
 * In this base class it is assumed that the DOMElement is a block, non-replaced
 * element, each deriving case as its own inherithing class
 * 
 * @author Yannick DOMINGUEZ
 </haxe_doc>
	</class>
	<class path="cocktailCore.style.computer.boxComputers.InlineBlockBoxStylesComputer" params="" file="/Users/lexa/Documents/repositories/lexoyo_Cocktail/demo/games/libs/cocktailCore/style/computer/boxComputers/InlineBlockBoxStylesComputer.hx">
		<extends path="cocktailCore.style.computer.BoxStylesComputer"/>
		<getComputedAutoMargin set="method" line="33" override="1">
			<f a="marginStyleValue:opositeMarginStyleValue:containingDOMElementDimension:computedDimension:isDimensionAuto:computedPaddingsDimension:fontSize:xHeight:?isHorizontalMargin">
				<e path="cocktail.style.MarginStyleValue"/>
				<e path="cocktail.style.MarginStyleValue"/>
				<c path="Int"/>
				<c path="Int"/>
				<e path="Bool"/>
				<c path="Int"/>
				<c path="Float"/>
				<c path="Float"/>
				<e path="Bool"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
	 * for inlineBlock non-embedded DOMElements, auto margin compute to 0
	 </haxe_doc>
		</getComputedAutoMargin>
		<shrinkToFit public="1" set="method" line="42" override="1">
			<f a="style:containingDOMElementData:minimumWidth">
				<c path="cocktailCore.style.abstract.AbstractStyle"/>
				<t path="cocktailCore.style.ContainingDOMElementData"/>
				<c path="Int"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
	 * if the width is set to 'auto', then this method is called once all the children
	 * of the inlineBlock are laid out
	 </haxe_doc>
		</shrinkToFit>
		<new public="1" set="method" line="25">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * class constructor
	 </haxe_doc>
		</new>
		<haxe_doc>
 * This is the box computer for inlineBlock non-embedded
 * DOMElement
 * 
 * @author Yannick DOMINGUEZ
 </haxe_doc>
	</class>
	<class path="cocktailCore.mouse.abstract.AbstractMouse" params="" file="/Users/lexa/Documents/repositories/lexoyo_Cocktail/demo/games/libs/cocktailCore/mouse/abstract/AbstractMouse.hx">
		<_onMouseDown>
			<f a="">
				<t path="cocktail.mouse.MouseEventData"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * The callback to call when
	 * the native element is clicked
	 </haxe_doc>
		</_onMouseDown>
		<onMouseDown public="1" get="getOnMouseDown" set="setOnMouseDown"><f a="">
	<t path="cocktail.mouse.MouseEventData"/>
	<e path="Void"/>
</f></onMouseDown>
		<_onMouseUp>
			<f a="">
				<t path="cocktail.mouse.MouseEventData"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * The callback to call when 
	 * the native element is released
	 </haxe_doc>
		</_onMouseUp>
		<onMouseUp public="1" get="getOnMouseUp" set="setOnMouseUp"><f a="">
	<t path="cocktail.mouse.MouseEventData"/>
	<e path="Void"/>
</f></onMouseUp>
		<_onMouseOver>
			<f a="">
				<t path="cocktail.mouse.MouseEventData"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * the callback to call when the native element
	 * is hovered
	 </haxe_doc>
		</_onMouseOver>
		<onMouseOver public="1" get="getOnMouseOver" set="setOnMouseOver"><f a="">
	<t path="cocktail.mouse.MouseEventData"/>
	<e path="Void"/>
</f></onMouseOver>
		<_onMouseOut>
			<f a="">
				<t path="cocktail.mouse.MouseEventData"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * The callback to call when the native element
	 * is moused out
	 </haxe_doc>
		</_onMouseOut>
		<onMouseOut public="1" get="getOnMouseOut" set="setOnMouseOut"><f a="">
	<t path="cocktail.mouse.MouseEventData"/>
	<e path="Void"/>
</f></onMouseOut>
		<_onMouseMove>
			<f a="">
				<t path="cocktail.mouse.MouseEventData"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * The callback to call when the mouse move while
	 * over the native element
	 </haxe_doc>
		</_onMouseMove>
		<onMouseMove public="1" get="getOnMouseMove" set="setOnMouseMove"><f a="">
	<t path="cocktail.mouse.MouseEventData"/>
	<e path="Void"/>
</f></onMouseMove>
		<_onMouseDoubleClick>
			<f a="">
				<t path="cocktail.mouse.MouseEventData"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * The callback to call when the native element
	 * is double-clicked
	 </haxe_doc>
		</_onMouseDoubleClick>
		<onMouseDoubleClick public="1" get="getOnMouseDoubleClick" set="setOnMouseDoubleClick"><f a="">
	<t path="cocktail.mouse.MouseEventData"/>
	<e path="Void"/>
</f></onMouseDoubleClick>
		<_nativeElement>
			<t path="cocktail.nativeElement.NativeElement"/>
			<haxe_doc>
	 * The NativeElement on which mouse event are listened to
	 </haxe_doc>
		</_nativeElement>
		<onNativeMouseDown set="method" line="95">
			<f a="event">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Calls the onMouseDown callback with the current mouse data
	 * @param	event the native mouse down event
	 </haxe_doc>
		</onNativeMouseDown>
		<onNativeMouseUp set="method" line="107">
			<f a="event">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Calls the onMouseUp callback with the current mouse data
	 * @param	event the native mouse up event
	 </haxe_doc>
		</onNativeMouseUp>
		<onNativeMouseOver set="method" line="119">
			<f a="event">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Calls the onMouseOver callback with the current mouse data
	 * @param	event the native mouse over event
	 </haxe_doc>
		</onNativeMouseOver>
		<onNativeMouseOut set="method" line="131">
			<f a="event">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Calls the onMouseOut callback with the current mouse data
	 * @param	event the native mouse out event
	 </haxe_doc>
		</onNativeMouseOut>
		<onNativeMouseMove set="method" line="144">
			<f a="event">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Calls the onMouseMove callback with the current mouse data
	 * @param	event the native mouse move event
	 </haxe_doc>
		</onNativeMouseMove>
		<onNativeMouseDoubleClick set="method" line="156">
			<f a="event">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Calls the onMousedoubleClick callback with the current mouse data
	 * @param	event the native mouse double-click event
	 </haxe_doc>
		</onNativeMouseDoubleClick>
		<getMouseData set="method" line="173">
			<f a="event">
				<d/>
				<t path="cocktail.mouse.MouseEventData"/>
			</f>
			<haxe_doc>
	 * Returns the current mouse data
	 * @param	event the native mouse event
	 * @return a sruct containing the mouse current data
	 </haxe_doc>
		</getMouseData>
		<setOnMouseDown set="method" line="182"><f a="value">
	<f a="">
		<t path="cocktail.mouse.MouseEventData"/>
		<e path="Void"/>
	</f>
	<f a="">
		<t path="cocktail.mouse.MouseEventData"/>
		<e path="Void"/>
	</f>
</f></setOnMouseDown>
		<getOnMouseDown set="method" line="187"><f a=""><f a="">
	<t path="cocktail.mouse.MouseEventData"/>
	<e path="Void"/>
</f></f></getOnMouseDown>
		<setOnMouseUp set="method" line="192"><f a="value">
	<f a="">
		<t path="cocktail.mouse.MouseEventData"/>
		<e path="Void"/>
	</f>
	<f a="">
		<t path="cocktail.mouse.MouseEventData"/>
		<e path="Void"/>
	</f>
</f></setOnMouseUp>
		<getOnMouseUp set="method" line="197"><f a=""><f a="">
	<t path="cocktail.mouse.MouseEventData"/>
	<e path="Void"/>
</f></f></getOnMouseUp>
		<setOnMouseOver set="method" line="202"><f a="value">
	<f a="">
		<t path="cocktail.mouse.MouseEventData"/>
		<e path="Void"/>
	</f>
	<f a="">
		<t path="cocktail.mouse.MouseEventData"/>
		<e path="Void"/>
	</f>
</f></setOnMouseOver>
		<getOnMouseOver set="method" line="207"><f a=""><f a="">
	<t path="cocktail.mouse.MouseEventData"/>
	<e path="Void"/>
</f></f></getOnMouseOver>
		<setOnMouseOut set="method" line="212"><f a="value">
	<f a="">
		<t path="cocktail.mouse.MouseEventData"/>
		<e path="Void"/>
	</f>
	<f a="">
		<t path="cocktail.mouse.MouseEventData"/>
		<e path="Void"/>
	</f>
</f></setOnMouseOut>
		<getOnMouseOut set="method" line="217"><f a=""><f a="">
	<t path="cocktail.mouse.MouseEventData"/>
	<e path="Void"/>
</f></f></getOnMouseOut>
		<setOnMouseMove set="method" line="222"><f a="value">
	<f a="">
		<t path="cocktail.mouse.MouseEventData"/>
		<e path="Void"/>
	</f>
	<f a="">
		<t path="cocktail.mouse.MouseEventData"/>
		<e path="Void"/>
	</f>
</f></setOnMouseMove>
		<getOnMouseMove set="method" line="227"><f a=""><f a="">
	<t path="cocktail.mouse.MouseEventData"/>
	<e path="Void"/>
</f></f></getOnMouseMove>
		<setOnMouseDoubleClick set="method" line="232"><f a="value">
	<f a="">
		<t path="cocktail.mouse.MouseEventData"/>
		<e path="Void"/>
	</f>
	<f a="">
		<t path="cocktail.mouse.MouseEventData"/>
		<e path="Void"/>
	</f>
</f></setOnMouseDoubleClick>
		<getOnMouseDoubleClick set="method" line="237"><f a=""><f a="">
	<t path="cocktail.mouse.MouseEventData"/>
	<e path="Void"/>
</f></f></getOnMouseDoubleClick>
		<new public="1" set="method" line="81">
			<f a="nativeElement">
				<t path="cocktail.nativeElement.NativeElement"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * class constructor
	 </haxe_doc>
		</new>
		<haxe_doc>
 * This package is made to offer a simple API for mouse interactions.
 *
 * This class is the base class for mouse interaction. It listens to 
 * mouse events thanks to runtime specific implementations and calls
 * the appropriate registered callbacks.
 * 
 * It takes a target native element objects onto which the mouse
 * event will be listened.
 * 
 * The mouse event callbacks are called with a struct containing the mouse
 * current data
 * 
 * @author Yannick DOMINGUEZ
 </haxe_doc>
	</class>
	<class path="cocktailCore.mouse.js.Mouse" params="" file="/Users/lexa/Documents/repositories/lexoyo_Cocktail/demo/games/libs/cocktailCore/mouse/js/Mouse.hx">
		<extends path="cocktailCore.mouse.abstract.AbstractMouse"/>
		<setOnMouseDown set="method" line="37" override="1"><f a="value">
	<f a="">
		<t path="cocktail.mouse.MouseEventData"/>
		<e path="Void"/>
	</f>
	<f a="">
		<t path="cocktail.mouse.MouseEventData"/>
		<e path="Void"/>
	</f>
</f></setOnMouseDown>
		<setOnMouseUp set="method" line="51" override="1"><f a="value">
	<f a="">
		<t path="cocktail.mouse.MouseEventData"/>
		<e path="Void"/>
	</f>
	<f a="">
		<t path="cocktail.mouse.MouseEventData"/>
		<e path="Void"/>
	</f>
</f></setOnMouseUp>
		<setOnMouseOver set="method" line="64" override="1"><f a="value">
	<f a="">
		<t path="cocktail.mouse.MouseEventData"/>
		<e path="Void"/>
	</f>
	<f a="">
		<t path="cocktail.mouse.MouseEventData"/>
		<e path="Void"/>
	</f>
</f></setOnMouseOver>
		<setOnMouseOut set="method" line="77" override="1"><f a="value">
	<f a="">
		<t path="cocktail.mouse.MouseEventData"/>
		<e path="Void"/>
	</f>
	<f a="">
		<t path="cocktail.mouse.MouseEventData"/>
		<e path="Void"/>
	</f>
</f></setOnMouseOut>
		<setOnMouseMove set="method" line="90" override="1"><f a="value">
	<f a="">
		<t path="cocktail.mouse.MouseEventData"/>
		<e path="Void"/>
	</f>
	<f a="">
		<t path="cocktail.mouse.MouseEventData"/>
		<e path="Void"/>
	</f>
</f></setOnMouseMove>
		<setOnMouseDoubleClick set="method" line="103" override="1"><f a="value">
	<f a="">
		<t path="cocktail.mouse.MouseEventData"/>
		<e path="Void"/>
	</f>
	<f a="">
		<t path="cocktail.mouse.MouseEventData"/>
		<e path="Void"/>
	</f>
</f></setOnMouseDoubleClick>
		<getMouseData set="method" line="125" override="1">
			<f a="event">
				<d/>
				<t path="cocktail.mouse.MouseEventData"/>
			</f>
			<haxe_doc>
	 * Returns the current mouse data
	 * @param	event the native mouse event
	 * @return a sruct containing the mouse current data
	 </haxe_doc>
		</getMouseData>
		<new public="1" set="method" line="28">
			<f a="nativeElement">
				<t path="cocktail.nativeElement.NativeElement"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * class constructor.
	 </haxe_doc>
		</new>
		<haxe_doc>
 * This is the JavaScript implementation of the mouse event manager.
 * Listens to JavaScript native mouse event on the provided
 * HTML element object.
 * 
 * @author Yannick DOMINGUEZ
 </haxe_doc>
	</class>
	<typedef path="cocktail.textElement.TextElement" params="" file="/Users/lexa/Documents/repositories/lexoyo_Cocktail/demo/games/libs/cocktail/textElement/TextElement.hx">
		<c path="cocktailCore.textElement.js.TextElement"/>
		<haxe_doc>
 * Set the right runtime specific TextElement at compile-time
 </haxe_doc>
	</typedef>
	<class path="cocktailCore.keyboard.abstract.AbstractKeyboard" params="" file="/Users/lexa/Documents/repositories/lexoyo_Cocktail/demo/games/libs/cocktailCore/keyboard/abstract/AbstractKeyboard.hx">
		<_onKeyDown>
			<f a="">
				<t path="cocktail.keyboard.KeyEventData"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * The callback to call when
	 * a key is pressed
	 </haxe_doc>
		</_onKeyDown>
		<onKeyDown public="1" get="getOnKeyDown" set="setOnKeyDown"><f a="">
	<t path="cocktail.keyboard.KeyEventData"/>
	<e path="Void"/>
</f></onKeyDown>
		<_onKeyUp>
			<f a="">
				<t path="cocktail.keyboard.KeyEventData"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * The callback to call when 
	 * a key is released
	 </haxe_doc>
		</_onKeyUp>
		<onKeyUp public="1" get="getOnKeyUp" set="setOnKeyUp"><f a="">
	<t path="cocktail.keyboard.KeyEventData"/>
	<e path="Void"/>
</f></onKeyUp>
		<onNativeKeyDown set="method" line="62">
			<f a="event">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Calls the onKeyDown callback with the pressed key data
	 * @param	event the native key down event
	 </haxe_doc>
		</onNativeKeyDown>
		<onNativeKeyUp set="method" line="75">
			<f a="event">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Calls the onKeyUp callback with the released
	 * key data
	 * @param	event the native key up event
	 </haxe_doc>
		</onNativeKeyUp>
		<setOnKeyDown set="method" line="87"><f a="value">
	<f a="">
		<t path="cocktail.keyboard.KeyEventData"/>
		<e path="Void"/>
	</f>
	<f a="">
		<t path="cocktail.keyboard.KeyEventData"/>
		<e path="Void"/>
	</f>
</f></setOnKeyDown>
		<getOnKeyDown set="method" line="92"><f a=""><f a="">
	<t path="cocktail.keyboard.KeyEventData"/>
	<e path="Void"/>
</f></f></getOnKeyDown>
		<setOnKeyUp set="method" line="97"><f a="value">
	<f a="">
		<t path="cocktail.keyboard.KeyEventData"/>
		<e path="Void"/>
	</f>
	<f a="">
		<t path="cocktail.keyboard.KeyEventData"/>
		<e path="Void"/>
	</f>
</f></setOnKeyUp>
		<getOnKeyUp set="method" line="102"><f a=""><f a="">
	<t path="cocktail.keyboard.KeyEventData"/>
	<e path="Void"/>
</f></f></getOnKeyUp>
		<getKeyData set="method" line="116">
			<f a="event">
				<d/>
				<t path="cocktail.keyboard.KeyEventData"/>
			</f>
			<haxe_doc>
	 * Returns the key that triggered the keyboard event
	 * @param	event the native key up or down event
	 * @return a sruct containing the key code and ascii value
	 </haxe_doc>
		</getKeyData>
		<getKeyValue set="method" line="127">
			<f a="keyCode">
				<c path="Int"/>
				<e path="cocktail.keyboard.KeyboardKeyValue"/>
			</f>
			<haxe_doc>
	 * Return a key enum value from a key code
	 * @param	keyCode the target key code
	 * @return a key enum value. Default to "unknown" if the
	 * key isn't listed in the enum values
	 </haxe_doc>
		</getKeyValue>
		<new public="1" set="method" line="48">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * class constructor
	 </haxe_doc>
		</new>
		<haxe_doc>
 * This package is made to offer a simple API for keyboard interactions.
 *
 * We choose not to use a singleton pattern or static class and found
 * a simple way for exposing the keyboard state and for calling a custom callback function.
 * 
 * The class is to be instantiated, and then you can set the instance attributes 
 * onKeyDown and onKeyUp to your callbacks. These callbacks will receive a Key
 * object with the key code and modifier key state as a parameter.
 * 
 * This is a base abstract class, implemented for each runtime
 * 
 * @author a.hoyau [at] silexlabs.org
 * @author Yannick DOMINGUEZ
 </haxe_doc>
	</class>
	<typedef path="cocktail.domElement.EmbeddedDOMElement" params="" file="/Users/lexa/Documents/repositories/lexoyo_Cocktail/demo/games/libs/cocktail/domElement/EmbeddedDOMElement.hx">
		<c path="cocktailCore.domElement.js.EmbeddedDOMElement"/>
		<haxe_doc>
 * Set the right runtime specific EmbeddedDOMElement at compile-time
 </haxe_doc>
	</typedef>
	<typedef path="cocktail.keyboard.KeyEventData" params="" file="/Users/lexa/Documents/repositories/lexoyo_Cocktail/demo/games/libs/cocktail/keyboard/KeyboardData.hx" module="cocktail.keyboard.KeyboardData">
		<a>
			<value><e path="cocktail.keyboard.KeyboardKeyValue"/></value>
			<shiftKey>
				<e path="Bool"/>
				<haxe_doc>
	 * wether shift is pressed
	 </haxe_doc>
			</shiftKey>
			<controlKey>
				<e path="Bool"/>
				<haxe_doc>
	 * wether ctrl is pressed
	 </haxe_doc>
			</controlKey>
			<code>
				<c path="Int"/>
				<haxe_doc>
	 * the key code
	 </haxe_doc>
			</code>
			<ascii>
				<c path="Int"/>
				<haxe_doc>
	 * the key ascii code
	 </haxe_doc>
			</ascii>
			<altKey>
				<e path="Bool"/>
				<haxe_doc>
	 * wether alt is pressed
	 </haxe_doc>
			</altKey>
		</a>
		<haxe_doc>
 * Represents a keyboard key on a up/down event
 * and the state of the modifier keys then
 </haxe_doc>
	</typedef>
	<enum path="cocktail.keyboard.KeyboardKeyValue" params="" file="/Users/lexa/Documents/repositories/lexoyo_Cocktail/demo/games/libs/cocktail/keyboard/KeyboardData.hx" module="cocktail.keyboard.KeyboardData">
		<z/>
		<y/>
		<x/>
		<w/>
		<v/>
		<up/>
		<unknown/>
		<u/>
		<tab/>
		<t/>
		<space/>
		<shift/>
		<s/>
		<right/>
		<r/>
		<q/>
		<pageUp/>
		<pageDown/>
		<p/>
		<o/>
		<numpadSubstract/>
		<numpadSpecial/>
		<numpadMultiply/>
		<numpadEnter/>
		<numpadDivide/>
		<numpadDecimal/>
		<numpadAdd/>
		<numpad9/>
		<numpad8/>
		<numpad7/>
		<numpad6/>
		<numpad5/>
		<numpad4/>
		<numpad3/>
		<numpad2/>
		<numpad1/>
		<numpad0/>
		<n/>
		<m/>
		<left/>
		<l/>
		<k/>
		<j/>
		<insert/>
		<i/>
		<home/>
		<h/>
		<g/>
		<f/>
		<escape/>
		<enter/>
		<end/>
		<e/>
		<down/>
		<del/>
		<d/>
		<control/>
		<capsLock/>
		<c/>
		<backSpace/>
		<b/>
		<a/>
		<F9/>
		<F8/>
		<F7/>
		<F6/>
		<F5/>
		<F4/>
		<F3/>
		<F2/>
		<F15/>
		<F14/>
		<F13/>
		<F12/>
		<F11/>
		<F10/>
		<F1/>
		<haxe_doc>
 * Lists all the keyboard's keys. Default to "unknow" for
 * non listed keys
 </haxe_doc>
	</enum>
	<class path="js.HtmlCollection" params="T" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/js/Dom.hx" module="js.Dom" extern="1">
		<length public="1" set="null"><c path="Int"/></length>
		<haxe_dynamic><c path="js.HtmlCollection.T"/></haxe_dynamic>
	</class>
	<typedef path="js.MetaDom" params="T" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/js/Dom.hx" module="js.Dom"><a>
	<setAttribute set="method"><f a="attr:val">
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></setAttribute>
	<replaceChild set="method"><f a="child:oldChild">
	<c path="js.MetaDom.T"/>
	<c path="js.MetaDom.T"/>
	<e path="Void"/>
</f></replaceChild>
	<removeChild set="method"><f a="child">
	<c path="js.MetaDom.T"/>
	<c path="js.MetaDom.T"/>
</f></removeChild>
	<previousSibling><c path="js.MetaDom.T"/></previousSibling>
	<parentNode><c path="js.MetaDom.T"/></parentNode>
	<nodeValue><c path="String"/></nodeValue>
	<nodeType><c path="Int"/></nodeType>
	<nodeName><c path="String"/></nodeName>
	<nextSibling><c path="js.MetaDom.T"/></nextSibling>
	<lastChild><c path="js.MetaDom.T"/></lastChild>
	<insertBefore set="method"><f a="newChild:refChild">
	<c path="js.MetaDom.T"/>
	<c path="js.MetaDom.T"/>
	<e path="Void"/>
</f></insertBefore>
	<hasChildNodes set="method"><f a=""><e path="Bool"/></f></hasChildNodes>
	<getAttribute set="method"><f a="attr">
	<c path="String"/>
	<c path="String"/>
</f></getAttribute>
	<firstChild><c path="js.MetaDom.T"/></firstChild>
	<cloneNode set="method"><f a="deep">
	<e path="Bool"/>
	<c path="js.MetaDom.T"/>
</f></cloneNode>
	<childNodes><c path="js.HtmlCollection"><c path="js.MetaDom.T"/></c></childNodes>
	<appendChild set="method"><f a="child">
	<c path="js.MetaDom.T"/>
	<e path="Void"/>
</f></appendChild>
</a></typedef>
	<typedef path="js.Dom" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/js/Dom.hx"><t path="js.MetaDom"><t path="js.Dom"/></t></typedef>
	<typedef path="js.HtmlDom" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/js/Dom.hx" module="js.Dom"><a>
	<title><c path="String"/></title>
	<style><t path="js.Style"/></style>
	<setAttribute set="method"><f a="attr:val">
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></setAttribute>
	<scrollWidth set="null"><c path="Int"/></scrollWidth>
	<scrollTop><c path="Int"/></scrollTop>
	<scrollLeft><c path="Int"/></scrollLeft>
	<scrollHeight set="null"><c path="Int"/></scrollHeight>
	<replaceChild set="method"><f a="child:oldChild">
	<t path="js.HtmlDom"/>
	<t path="js.HtmlDom"/>
	<e path="Void"/>
</f></replaceChild>
	<removeChild set="method"><f a="child">
	<t path="js.HtmlDom"/>
	<t path="js.HtmlDom"/>
</f></removeChild>
	<previousSibling><t path="js.HtmlDom"/></previousSibling>
	<parentNode><t path="js.HtmlDom"/></parentNode>
	<onscroll><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onscroll>
	<onresize><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onresize>
	<onmouseup><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmouseup>
	<onmouseover><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmouseover>
	<onmouseout><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmouseout>
	<onmousemove><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmousemove>
	<onmousedown><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmousedown>
	<onkeyup><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onkeyup>
	<onkeypress><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onkeypress>
	<onkeydown><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onkeydown>
	<onfocus><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onfocus>
	<ondblclick><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></ondblclick>
	<onclick><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onclick>
	<onblur><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onblur>
	<offsetWidth><c path="Int"/></offsetWidth>
	<offsetTop><c path="Int"/></offsetTop>
	<offsetParent><t path="js.HtmlDom"/></offsetParent>
	<offsetLeft><c path="Int"/></offsetLeft>
	<offsetHeight><c path="Int"/></offsetHeight>
	<nodeValue><c path="String"/></nodeValue>
	<nodeType><c path="Int"/></nodeType>
	<nodeName><c path="String"/></nodeName>
	<nextSibling><t path="js.HtmlDom"/></nextSibling>
	<lastChild><t path="js.HtmlDom"/></lastChild>
	<lang><c path="String"/></lang>
	<insertBefore set="method"><f a="newChild:refChild">
	<t path="js.HtmlDom"/>
	<t path="js.HtmlDom"/>
	<e path="Void"/>
</f></insertBefore>
	<innerHTML><c path="String"/></innerHTML>
	<id><c path="String"/></id>
	<hasChildNodes set="method"><f a=""><e path="Bool"/></f></hasChildNodes>
	<getElementsByTagName set="method"><f a="tag">
	<c path="String"/>
	<c path="js.HtmlCollection"><t path="js.HtmlDom"/></c>
</f></getElementsByTagName>
	<getAttribute set="method"><f a="attr">
	<c path="String"/>
	<c path="String"/>
</f></getAttribute>
	<focus set="method"><f a=""><e path="Void"/></f></focus>
	<firstChild><t path="js.HtmlDom"/></firstChild>
	<dir><c path="String"/></dir>
	<cloneNode set="method"><f a="deep">
	<e path="Bool"/>
	<t path="js.HtmlDom"/>
</f></cloneNode>
	<clientWidth set="null"><c path="Int"/></clientWidth>
	<clientHeight set="null"><c path="Int"/></clientHeight>
	<click set="method"><f a=""><e path="Void"/></f></click>
	<className><c path="String"/></className>
	<childNodes><c path="js.HtmlCollection"><t path="js.HtmlDom"/></c></childNodes>
	<blur set="method"><f a=""><e path="Void"/></f></blur>
	<appendChild set="method"><f a="child">
	<t path="js.HtmlDom"/>
	<e path="Void"/>
</f></appendChild>
</a></typedef>
	<typedef path="js.FormElement" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/js/Dom.hx" module="js.Dom"><a>
	<value><c path="String"/></value>
	<type><c path="String"/></type>
	<title><c path="String"/></title>
	<style><t path="js.Style"/></style>
	<setAttribute set="method"><f a="attr:val">
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></setAttribute>
	<select set="method"><f a=""><e path="Void"/></f></select>
	<scrollWidth set="null"><c path="Int"/></scrollWidth>
	<scrollTop><c path="Int"/></scrollTop>
	<scrollLeft><c path="Int"/></scrollLeft>
	<scrollHeight set="null"><c path="Int"/></scrollHeight>
	<replaceChild set="method"><f a="child:oldChild">
	<t path="js.HtmlDom"/>
	<t path="js.HtmlDom"/>
	<e path="Void"/>
</f></replaceChild>
	<removeChild set="method"><f a="child">
	<t path="js.HtmlDom"/>
	<t path="js.HtmlDom"/>
</f></removeChild>
	<previousSibling><t path="js.HtmlDom"/></previousSibling>
	<parentNode><t path="js.HtmlDom"/></parentNode>
	<onselect><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onselect>
	<onscroll><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onscroll>
	<onresize><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onresize>
	<onmouseup><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmouseup>
	<onmouseover><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmouseover>
	<onmouseout><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmouseout>
	<onmousemove><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmousemove>
	<onmousedown><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmousedown>
	<onkeyup><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onkeyup>
	<onkeypress><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onkeypress>
	<onkeydown><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onkeydown>
	<onfocus><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onfocus>
	<ondblclick><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></ondblclick>
	<onclick><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onclick>
	<onchange><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onchange>
	<onblur><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onblur>
	<offsetWidth><c path="Int"/></offsetWidth>
	<offsetTop><c path="Int"/></offsetTop>
	<offsetParent><t path="js.HtmlDom"/></offsetParent>
	<offsetLeft><c path="Int"/></offsetLeft>
	<offsetHeight><c path="Int"/></offsetHeight>
	<nodeValue><c path="String"/></nodeValue>
	<nodeType><c path="Int"/></nodeType>
	<nodeName><c path="String"/></nodeName>
	<nextSibling><t path="js.HtmlDom"/></nextSibling>
	<name><c path="String"/></name>
	<lastChild><t path="js.HtmlDom"/></lastChild>
	<lang><c path="String"/></lang>
	<insertBefore set="method"><f a="newChild:refChild">
	<t path="js.HtmlDom"/>
	<t path="js.HtmlDom"/>
	<e path="Void"/>
</f></insertBefore>
	<innerHTML><c path="String"/></innerHTML>
	<id><c path="String"/></id>
	<hasChildNodes set="method"><f a=""><e path="Bool"/></f></hasChildNodes>
	<getElementsByTagName set="method"><f a="tag">
	<c path="String"/>
	<c path="js.HtmlCollection"><t path="js.HtmlDom"/></c>
</f></getElementsByTagName>
	<getAttribute set="method"><f a="attr">
	<c path="String"/>
	<c path="String"/>
</f></getAttribute>
	<form><t path="js.Form"/></form>
	<focus set="method"><f a=""><e path="Void"/></f></focus>
	<firstChild><t path="js.HtmlDom"/></firstChild>
	<disabled><e path="Bool"/></disabled>
	<dir><c path="String"/></dir>
	<cloneNode set="method"><f a="deep">
	<e path="Bool"/>
	<t path="js.HtmlDom"/>
</f></cloneNode>
	<clientWidth set="null"><c path="Int"/></clientWidth>
	<clientHeight set="null"><c path="Int"/></clientHeight>
	<click set="method"><f a=""><e path="Void"/></f></click>
	<className><c path="String"/></className>
	<childNodes><c path="js.HtmlCollection"><t path="js.HtmlDom"/></c></childNodes>
	<blur set="method"><f a=""><e path="Void"/></f></blur>
	<appendChild set="method"><f a="child">
	<t path="js.HtmlDom"/>
	<e path="Void"/>
</f></appendChild>
</a></typedef>
	<typedef path="js.Anchor" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/js/Dom.hx" module="js.Dom"><a>
	<title><c path="String"/></title>
	<target><c path="String"/></target>
	<tabIndex><c path="Int"/></tabIndex>
	<style><t path="js.Style"/></style>
	<setAttribute set="method"><f a="attr:val">
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></setAttribute>
	<scrollWidth set="null"><c path="Int"/></scrollWidth>
	<scrollTop><c path="Int"/></scrollTop>
	<scrollLeft><c path="Int"/></scrollLeft>
	<scrollHeight set="null"><c path="Int"/></scrollHeight>
	<rev><c path="String"/></rev>
	<replaceChild set="method"><f a="child:oldChild">
	<t path="js.HtmlDom"/>
	<t path="js.HtmlDom"/>
	<e path="Void"/>
</f></replaceChild>
	<removeChild set="method"><f a="child">
	<t path="js.HtmlDom"/>
	<t path="js.HtmlDom"/>
</f></removeChild>
	<rel><c path="String"/></rel>
	<previousSibling><t path="js.HtmlDom"/></previousSibling>
	<parentNode><t path="js.HtmlDom"/></parentNode>
	<onscroll><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onscroll>
	<onresize><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onresize>
	<onmouseup><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmouseup>
	<onmouseover><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmouseover>
	<onmouseout><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmouseout>
	<onmousemove><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmousemove>
	<onmousedown><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmousedown>
	<onkeyup><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onkeyup>
	<onkeypress><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onkeypress>
	<onkeydown><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onkeydown>
	<onfocus><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onfocus>
	<ondblclick><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></ondblclick>
	<onclick><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onclick>
	<onblur><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onblur>
	<offsetWidth><c path="Int"/></offsetWidth>
	<offsetTop><c path="Int"/></offsetTop>
	<offsetParent><t path="js.HtmlDom"/></offsetParent>
	<offsetLeft><c path="Int"/></offsetLeft>
	<offsetHeight><c path="Int"/></offsetHeight>
	<nodeValue><c path="String"/></nodeValue>
	<nodeType><c path="Int"/></nodeType>
	<nodeName><c path="String"/></nodeName>
	<nextSibling><t path="js.HtmlDom"/></nextSibling>
	<name><c path="String"/></name>
	<lastChild><t path="js.HtmlDom"/></lastChild>
	<lang><c path="String"/></lang>
	<insertBefore set="method"><f a="newChild:refChild">
	<t path="js.HtmlDom"/>
	<t path="js.HtmlDom"/>
	<e path="Void"/>
</f></insertBefore>
	<innerHTML><c path="String"/></innerHTML>
	<id><c path="String"/></id>
	<href><c path="String"/></href>
	<hasChildNodes set="method"><f a=""><e path="Bool"/></f></hasChildNodes>
	<getElementsByTagName set="method"><f a="tag">
	<c path="String"/>
	<c path="js.HtmlCollection"><t path="js.HtmlDom"/></c>
</f></getElementsByTagName>
	<getAttribute set="method"><f a="attr">
	<c path="String"/>
	<c path="String"/>
</f></getAttribute>
	<focus set="method"><f a=""><e path="Void"/></f></focus>
	<firstChild><t path="js.HtmlDom"/></firstChild>
	<dir><c path="String"/></dir>
	<cloneNode set="method"><f a="deep">
	<e path="Bool"/>
	<t path="js.HtmlDom"/>
</f></cloneNode>
	<clientWidth set="null"><c path="Int"/></clientWidth>
	<clientHeight set="null"><c path="Int"/></clientHeight>
	<click set="method"><f a=""><e path="Void"/></f></click>
	<className><c path="String"/></className>
	<childNodes><c path="js.HtmlCollection"><t path="js.HtmlDom"/></c></childNodes>
	<blur set="method"><f a=""><e path="Void"/></f></blur>
	<appendChild set="method"><f a="child">
	<t path="js.HtmlDom"/>
	<e path="Void"/>
</f></appendChild>
	<accessKey><c path="String"/></accessKey>
</a></typedef>
	<typedef path="js.Body" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/js/Dom.hx" module="js.Dom"><a>
	<vLink><c path="String"/></vLink>
	<title><c path="String"/></title>
	<text><c path="String"/></text>
	<style><t path="js.Style"/></style>
	<setAttribute set="method"><f a="attr:val">
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></setAttribute>
	<scrollWidth set="null"><c path="Int"/></scrollWidth>
	<scrollTop><c path="Int"/></scrollTop>
	<scrollLeft><c path="Int"/></scrollLeft>
	<scrollHeight set="null"><c path="Int"/></scrollHeight>
	<replaceChild set="method"><f a="child:oldChild">
	<t path="js.HtmlDom"/>
	<t path="js.HtmlDom"/>
	<e path="Void"/>
</f></replaceChild>
	<removeChild set="method"><f a="child">
	<t path="js.HtmlDom"/>
	<t path="js.HtmlDom"/>
</f></removeChild>
	<previousSibling><t path="js.HtmlDom"/></previousSibling>
	<parentNode><t path="js.HtmlDom"/></parentNode>
	<onscroll><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onscroll>
	<onresize><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onresize>
	<onmouseup><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmouseup>
	<onmouseover><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmouseover>
	<onmouseout><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmouseout>
	<onmousemove><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmousemove>
	<onmousedown><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmousedown>
	<onkeyup><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onkeyup>
	<onkeypress><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onkeypress>
	<onkeydown><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onkeydown>
	<onfocus><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onfocus>
	<ondblclick><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></ondblclick>
	<onclick><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onclick>
	<onblur><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onblur>
	<offsetWidth><c path="Int"/></offsetWidth>
	<offsetTop><c path="Int"/></offsetTop>
	<offsetParent><t path="js.HtmlDom"/></offsetParent>
	<offsetLeft><c path="Int"/></offsetLeft>
	<offsetHeight><c path="Int"/></offsetHeight>
	<nodeValue><c path="String"/></nodeValue>
	<nodeType><c path="Int"/></nodeType>
	<nodeName><c path="String"/></nodeName>
	<nextSibling><t path="js.HtmlDom"/></nextSibling>
	<link><c path="String"/></link>
	<lastChild><t path="js.HtmlDom"/></lastChild>
	<lang><c path="String"/></lang>
	<insertBefore set="method"><f a="newChild:refChild">
	<t path="js.HtmlDom"/>
	<t path="js.HtmlDom"/>
	<e path="Void"/>
</f></insertBefore>
	<innerHTML><c path="String"/></innerHTML>
	<id><c path="String"/></id>
	<hasChildNodes set="method"><f a=""><e path="Bool"/></f></hasChildNodes>
	<getElementsByTagName set="method"><f a="tag">
	<c path="String"/>
	<c path="js.HtmlCollection"><t path="js.HtmlDom"/></c>
</f></getElementsByTagName>
	<getAttribute set="method"><f a="attr">
	<c path="String"/>
	<c path="String"/>
</f></getAttribute>
	<focus set="method"><f a=""><e path="Void"/></f></focus>
	<firstChild><t path="js.HtmlDom"/></firstChild>
	<dir><c path="String"/></dir>
	<cloneNode set="method"><f a="deep">
	<e path="Bool"/>
	<t path="js.HtmlDom"/>
</f></cloneNode>
	<clientWidth set="null"><c path="Int"/></clientWidth>
	<clientHeight set="null"><c path="Int"/></clientHeight>
	<click set="method"><f a=""><e path="Void"/></f></click>
	<className><c path="String"/></className>
	<childNodes><c path="js.HtmlCollection"><t path="js.HtmlDom"/></c></childNodes>
	<blur set="method"><f a=""><e path="Void"/></f></blur>
	<bgColor><c path="String"/></bgColor>
	<background><c path="String"/></background>
	<appendChild set="method"><f a="child">
	<t path="js.HtmlDom"/>
	<e path="Void"/>
</f></appendChild>
	<aLink><c path="String"/></aLink>
</a></typedef>
	<typedef path="js.Button" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/js/Dom.hx" module="js.Dom"><a>
	<value><c path="String"/></value>
	<type><c path="String"/></type>
	<title><c path="String"/></title>
	<style><t path="js.Style"/></style>
	<setAttribute set="method"><f a="attr:val">
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></setAttribute>
	<select set="method"><f a=""><e path="Void"/></f></select>
	<scrollWidth set="null"><c path="Int"/></scrollWidth>
	<scrollTop><c path="Int"/></scrollTop>
	<scrollLeft><c path="Int"/></scrollLeft>
	<scrollHeight set="null"><c path="Int"/></scrollHeight>
	<replaceChild set="method"><f a="child:oldChild">
	<t path="js.HtmlDom"/>
	<t path="js.HtmlDom"/>
	<e path="Void"/>
</f></replaceChild>
	<removeChild set="method"><f a="child">
	<t path="js.HtmlDom"/>
	<t path="js.HtmlDom"/>
</f></removeChild>
	<previousSibling><t path="js.HtmlDom"/></previousSibling>
	<parentNode><t path="js.HtmlDom"/></parentNode>
	<onselect><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onselect>
	<onscroll><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onscroll>
	<onresize><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onresize>
	<onmouseup><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmouseup>
	<onmouseover><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmouseover>
	<onmouseout><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmouseout>
	<onmousemove><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmousemove>
	<onmousedown><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmousedown>
	<onkeyup><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onkeyup>
	<onkeypress><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onkeypress>
	<onkeydown><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onkeydown>
	<onfocus><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onfocus>
	<ondblclick><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></ondblclick>
	<onclick><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onclick>
	<onchange><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onchange>
	<onblur><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onblur>
	<offsetWidth><c path="Int"/></offsetWidth>
	<offsetTop><c path="Int"/></offsetTop>
	<offsetParent><t path="js.HtmlDom"/></offsetParent>
	<offsetLeft><c path="Int"/></offsetLeft>
	<offsetHeight><c path="Int"/></offsetHeight>
	<nodeValue><c path="String"/></nodeValue>
	<nodeType><c path="Int"/></nodeType>
	<nodeName><c path="String"/></nodeName>
	<nextSibling><t path="js.HtmlDom"/></nextSibling>
	<name><c path="String"/></name>
	<lastChild><t path="js.HtmlDom"/></lastChild>
	<lang><c path="String"/></lang>
	<insertBefore set="method"><f a="newChild:refChild">
	<t path="js.HtmlDom"/>
	<t path="js.HtmlDom"/>
	<e path="Void"/>
</f></insertBefore>
	<innerHTML><c path="String"/></innerHTML>
	<id><c path="String"/></id>
	<hasChildNodes set="method"><f a=""><e path="Bool"/></f></hasChildNodes>
	<getElementsByTagName set="method"><f a="tag">
	<c path="String"/>
	<c path="js.HtmlCollection"><t path="js.HtmlDom"/></c>
</f></getElementsByTagName>
	<getAttribute set="method"><f a="attr">
	<c path="String"/>
	<c path="String"/>
</f></getAttribute>
	<form><t path="js.Form"/></form>
	<focus set="method"><f a=""><e path="Void"/></f></focus>
	<firstChild><t path="js.HtmlDom"/></firstChild>
	<disabled><e path="Bool"/></disabled>
	<dir><c path="String"/></dir>
	<cloneNode set="method"><f a="deep">
	<e path="Bool"/>
	<t path="js.HtmlDom"/>
</f></cloneNode>
	<clientWidth set="null"><c path="Int"/></clientWidth>
	<clientHeight set="null"><c path="Int"/></clientHeight>
	<click set="method"><f a=""><e path="Void"/></f></click>
	<className><c path="String"/></className>
	<childNodes><c path="js.HtmlCollection"><t path="js.HtmlDom"/></c></childNodes>
	<blur set="method"><f a=""><e path="Void"/></f></blur>
	<appendChild set="method"><f a="child">
	<t path="js.HtmlDom"/>
	<e path="Void"/>
</f></appendChild>
</a></typedef>
	<typedef path="js.Checkbox" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/js/Dom.hx" module="js.Dom"><a>
	<value><c path="String"/></value>
	<type><c path="String"/></type>
	<title><c path="String"/></title>
	<style><t path="js.Style"/></style>
	<setAttribute set="method"><f a="attr:val">
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></setAttribute>
	<select set="method"><f a=""><e path="Void"/></f></select>
	<scrollWidth set="null"><c path="Int"/></scrollWidth>
	<scrollTop><c path="Int"/></scrollTop>
	<scrollLeft><c path="Int"/></scrollLeft>
	<scrollHeight set="null"><c path="Int"/></scrollHeight>
	<replaceChild set="method"><f a="child:oldChild">
	<t path="js.HtmlDom"/>
	<t path="js.HtmlDom"/>
	<e path="Void"/>
</f></replaceChild>
	<removeChild set="method"><f a="child">
	<t path="js.HtmlDom"/>
	<t path="js.HtmlDom"/>
</f></removeChild>
	<previousSibling><t path="js.HtmlDom"/></previousSibling>
	<parentNode><t path="js.HtmlDom"/></parentNode>
	<onselect><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onselect>
	<onscroll><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onscroll>
	<onresize><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onresize>
	<onmouseup><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmouseup>
	<onmouseover><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmouseover>
	<onmouseout><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmouseout>
	<onmousemove><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmousemove>
	<onmousedown><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmousedown>
	<onkeyup><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onkeyup>
	<onkeypress><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onkeypress>
	<onkeydown><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onkeydown>
	<onfocus><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onfocus>
	<ondblclick><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></ondblclick>
	<onclick><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onclick>
	<onchange><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onchange>
	<onblur><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onblur>
	<offsetWidth><c path="Int"/></offsetWidth>
	<offsetTop><c path="Int"/></offsetTop>
	<offsetParent><t path="js.HtmlDom"/></offsetParent>
	<offsetLeft><c path="Int"/></offsetLeft>
	<offsetHeight><c path="Int"/></offsetHeight>
	<nodeValue><c path="String"/></nodeValue>
	<nodeType><c path="Int"/></nodeType>
	<nodeName><c path="String"/></nodeName>
	<nextSibling><t path="js.HtmlDom"/></nextSibling>
	<name><c path="String"/></name>
	<lastChild><t path="js.HtmlDom"/></lastChild>
	<lang><c path="String"/></lang>
	<insertBefore set="method"><f a="newChild:refChild">
	<t path="js.HtmlDom"/>
	<t path="js.HtmlDom"/>
	<e path="Void"/>
</f></insertBefore>
	<innerHTML><c path="String"/></innerHTML>
	<id><c path="String"/></id>
	<hasChildNodes set="method"><f a=""><e path="Bool"/></f></hasChildNodes>
	<getElementsByTagName set="method"><f a="tag">
	<c path="String"/>
	<c path="js.HtmlCollection"><t path="js.HtmlDom"/></c>
</f></getElementsByTagName>
	<getAttribute set="method"><f a="attr">
	<c path="String"/>
	<c path="String"/>
</f></getAttribute>
	<form><t path="js.Form"/></form>
	<focus set="method"><f a=""><e path="Void"/></f></focus>
	<firstChild><t path="js.HtmlDom"/></firstChild>
	<disabled><e path="Bool"/></disabled>
	<dir><c path="String"/></dir>
	<defaultChecked><e path="Bool"/></defaultChecked>
	<cloneNode set="method"><f a="deep">
	<e path="Bool"/>
	<t path="js.HtmlDom"/>
</f></cloneNode>
	<clientWidth set="null"><c path="Int"/></clientWidth>
	<clientHeight set="null"><c path="Int"/></clientHeight>
	<click set="method"><f a=""><e path="Void"/></f></click>
	<className><c path="String"/></className>
	<childNodes><c path="js.HtmlCollection"><t path="js.HtmlDom"/></c></childNodes>
	<checked><e path="Bool"/></checked>
	<blur set="method"><f a=""><e path="Void"/></f></blur>
	<appendChild set="method"><f a="child">
	<t path="js.HtmlDom"/>
	<e path="Void"/>
</f></appendChild>
</a></typedef>
	<typedef path="js.Document" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/js/Dom.hx" module="js.Dom"><a>
	<writeln set="method"><f a="str">
	<c path="String"/>
	<e path="Void"/>
</f></writeln>
	<write set="method"><f a="str">
	<c path="String"/>
	<e path="Void"/>
</f></write>
	<title><c path="String"/></title>
	<styleSheets><c path="js.HtmlCollection"><t path="js.StyleSheet"/></c></styleSheets>
	<style><t path="js.Style"/></style>
	<setAttribute set="method"><f a="attr:val">
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></setAttribute>
	<scrollWidth set="null"><c path="Int"/></scrollWidth>
	<scrollTop><c path="Int"/></scrollTop>
	<scrollLeft><c path="Int"/></scrollLeft>
	<scrollHeight set="null"><c path="Int"/></scrollHeight>
	<replaceChild set="method"><f a="child:oldChild">
	<t path="js.HtmlDom"/>
	<t path="js.HtmlDom"/>
	<e path="Void"/>
</f></replaceChild>
	<removeChild set="method"><f a="child">
	<t path="js.HtmlDom"/>
	<t path="js.HtmlDom"/>
</f></removeChild>
	<referrer><c path="String"/></referrer>
	<previousSibling><t path="js.HtmlDom"/></previousSibling>
	<parentNode><t path="js.HtmlDom"/></parentNode>
	<open set="method"><f a=""><e path="Void"/></f></open>
	<onscroll><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onscroll>
	<onresize><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onresize>
	<onmouseup><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmouseup>
	<onmouseover><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmouseover>
	<onmouseout><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmouseout>
	<onmousemove><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmousemove>
	<onmousedown><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmousedown>
	<onkeyup><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onkeyup>
	<onkeypress><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onkeypress>
	<onkeydown><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onkeydown>
	<onfocus><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onfocus>
	<ondblclick><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></ondblclick>
	<onclick><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onclick>
	<onblur><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onblur>
	<offsetWidth><c path="Int"/></offsetWidth>
	<offsetTop><c path="Int"/></offsetTop>
	<offsetParent><t path="js.HtmlDom"/></offsetParent>
	<offsetLeft><c path="Int"/></offsetLeft>
	<offsetHeight><c path="Int"/></offsetHeight>
	<nodeValue><c path="String"/></nodeValue>
	<nodeType><c path="Int"/></nodeType>
	<nodeName><c path="String"/></nodeName>
	<nextSibling><t path="js.HtmlDom"/></nextSibling>
	<links><c path="js.HtmlCollection"><t path="js.Link"/></c></links>
	<lastChild><t path="js.HtmlDom"/></lastChild>
	<lang><c path="String"/></lang>
	<insertBefore set="method"><f a="newChild:refChild">
	<t path="js.HtmlDom"/>
	<t path="js.HtmlDom"/>
	<e path="Void"/>
</f></insertBefore>
	<innerHTML><c path="String"/></innerHTML>
	<images><c path="js.HtmlCollection"><t path="js.Image"/></c></images>
	<id><c path="String"/></id>
	<hasChildNodes set="method"><f a=""><e path="Bool"/></f></hasChildNodes>
	<getElementsByTagName set="method"><f a="tag">
	<c path="String"/>
	<c path="js.HtmlCollection"><t path="js.HtmlDom"/></c>
</f></getElementsByTagName>
	<getElementsByTag set="method"><f a="tag">
	<c path="String"/>
	<c path="js.HtmlCollection"><t path="js.HtmlDom"/></c>
</f></getElementsByTag>
	<getElementsByName set="method"><f a="name">
	<c path="String"/>
	<c path="js.HtmlCollection"><t path="js.HtmlDom"/></c>
</f></getElementsByName>
	<getElementById set="method"><f a="id">
	<c path="String"/>
	<t path="js.HtmlDom"/>
</f></getElementById>
	<getAttribute set="method"><f a="attr">
	<c path="String"/>
	<c path="String"/>
</f></getAttribute>
	<forms><c path="js.HtmlCollection"><t path="js.Form"/></c></forms>
	<focus set="method"><f a=""><e path="Void"/></f></focus>
	<firstChild><t path="js.HtmlDom"/></firstChild>
	<domain><c path="String"/></domain>
	<dir><c path="String"/></dir>
	<createTextNode set="method"><f a="text">
	<c path="String"/>
	<t path="js.HtmlDom"/>
</f></createTextNode>
	<createElement set="method"><f a="name">
	<c path="String"/>
	<t path="js.HtmlDom"/>
</f></createElement>
	<cookie><c path="String"/></cookie>
	<close set="method"><f a=""><e path="Void"/></f></close>
	<cloneNode set="method"><f a="deep">
	<e path="Bool"/>
	<t path="js.HtmlDom"/>
</f></cloneNode>
	<clientWidth set="null"><c path="Int"/></clientWidth>
	<clientHeight set="null"><c path="Int"/></clientHeight>
	<click set="method"><f a=""><e path="Void"/></f></click>
	<className><c path="String"/></className>
	<childNodes><c path="js.HtmlCollection"><t path="js.HtmlDom"/></c></childNodes>
	<body><t path="js.Body"/></body>
	<blur set="method"><f a=""><e path="Void"/></f></blur>
	<appendChild set="method"><f a="child">
	<t path="js.HtmlDom"/>
	<e path="Void"/>
</f></appendChild>
	<anchors><c path="js.HtmlCollection"><t path="js.Anchor"/></c></anchors>
</a></typedef>
	<typedef path="js.Event" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/js/Dom.hx" module="js.Dom"><a>
	<type><c path="String"/></type>
	<target><t path="js.HtmlDom"/></target>
	<stopPropagation set="method"><f a=""><e path="Void"/></f></stopPropagation>
	<shiftKey><e path="Bool"/></shiftKey>
	<screenY><c path="Int"/></screenY>
	<screenX><c path="Int"/></screenX>
	<keyCode><c path="Int"/></keyCode>
	<ctrlKey><e path="Bool"/></ctrlKey>
	<clientY><c path="Int"/></clientY>
	<clientX><c path="Int"/></clientX>
	<cancelBubble><e path="Bool"/></cancelBubble>
	<button><c path="Int"/></button>
	<altKey><e path="Bool"/></altKey>
</a></typedef>
	<typedef path="js.FileUpload" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/js/Dom.hx" module="js.Dom"><a>
	<value><c path="String"/></value>
	<type><c path="String"/></type>
	<title><c path="String"/></title>
	<style><t path="js.Style"/></style>
	<setAttribute set="method"><f a="attr:val">
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></setAttribute>
	<select set="method"><f a=""><e path="Void"/></f></select>
	<scrollWidth set="null"><c path="Int"/></scrollWidth>
	<scrollTop><c path="Int"/></scrollTop>
	<scrollLeft><c path="Int"/></scrollLeft>
	<scrollHeight set="null"><c path="Int"/></scrollHeight>
	<replaceChild set="method"><f a="child:oldChild">
	<t path="js.HtmlDom"/>
	<t path="js.HtmlDom"/>
	<e path="Void"/>
</f></replaceChild>
	<removeChild set="method"><f a="child">
	<t path="js.HtmlDom"/>
	<t path="js.HtmlDom"/>
</f></removeChild>
	<previousSibling><t path="js.HtmlDom"/></previousSibling>
	<parentNode><t path="js.HtmlDom"/></parentNode>
	<onselect><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onselect>
	<onscroll><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onscroll>
	<onresize><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onresize>
	<onmouseup><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmouseup>
	<onmouseover><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmouseover>
	<onmouseout><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmouseout>
	<onmousemove><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmousemove>
	<onmousedown><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmousedown>
	<onkeyup><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onkeyup>
	<onkeypress><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onkeypress>
	<onkeydown><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onkeydown>
	<onfocus><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onfocus>
	<ondblclick><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></ondblclick>
	<onclick><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onclick>
	<onchange><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onchange>
	<onblur><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onblur>
	<offsetWidth><c path="Int"/></offsetWidth>
	<offsetTop><c path="Int"/></offsetTop>
	<offsetParent><t path="js.HtmlDom"/></offsetParent>
	<offsetLeft><c path="Int"/></offsetLeft>
	<offsetHeight><c path="Int"/></offsetHeight>
	<nodeValue><c path="String"/></nodeValue>
	<nodeType><c path="Int"/></nodeType>
	<nodeName><c path="String"/></nodeName>
	<nextSibling><t path="js.HtmlDom"/></nextSibling>
	<name><c path="String"/></name>
	<lastChild><t path="js.HtmlDom"/></lastChild>
	<lang><c path="String"/></lang>
	<insertBefore set="method"><f a="newChild:refChild">
	<t path="js.HtmlDom"/>
	<t path="js.HtmlDom"/>
	<e path="Void"/>
</f></insertBefore>
	<innerHTML><c path="String"/></innerHTML>
	<id><c path="String"/></id>
	<hasChildNodes set="method"><f a=""><e path="Bool"/></f></hasChildNodes>
	<getElementsByTagName set="method"><f a="tag">
	<c path="String"/>
	<c path="js.HtmlCollection"><t path="js.HtmlDom"/></c>
</f></getElementsByTagName>
	<getAttribute set="method"><f a="attr">
	<c path="String"/>
	<c path="String"/>
</f></getAttribute>
	<form><t path="js.Form"/></form>
	<focus set="method"><f a=""><e path="Void"/></f></focus>
	<firstChild><t path="js.HtmlDom"/></firstChild>
	<disabled><e path="Bool"/></disabled>
	<dir><c path="String"/></dir>
	<defaultValue><c path="String"/></defaultValue>
	<cloneNode set="method"><f a="deep">
	<e path="Bool"/>
	<t path="js.HtmlDom"/>
</f></cloneNode>
	<clientWidth set="null"><c path="Int"/></clientWidth>
	<clientHeight set="null"><c path="Int"/></clientHeight>
	<click set="method"><f a=""><e path="Void"/></f></click>
	<className><c path="String"/></className>
	<childNodes><c path="js.HtmlCollection"><t path="js.HtmlDom"/></c></childNodes>
	<blur set="method"><f a=""><e path="Void"/></f></blur>
	<appendChild set="method"><f a="child">
	<t path="js.HtmlDom"/>
	<e path="Void"/>
</f></appendChild>
</a></typedef>
	<typedef path="js.Form" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/js/Dom.hx" module="js.Dom"><a>
	<title><c path="String"/></title>
	<target><c path="String"/></target>
	<tabIndex><c path="Int"/></tabIndex>
	<submit set="method"><f a=""><e path="Void"/></f></submit>
	<style><t path="js.Style"/></style>
	<setAttribute set="method"><f a="attr:val">
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></setAttribute>
	<scrollWidth set="null"><c path="Int"/></scrollWidth>
	<scrollTop><c path="Int"/></scrollTop>
	<scrollLeft><c path="Int"/></scrollLeft>
	<scrollHeight set="null"><c path="Int"/></scrollHeight>
	<reset set="method"><f a=""><e path="Void"/></f></reset>
	<replaceChild set="method"><f a="child:oldChild">
	<t path="js.HtmlDom"/>
	<t path="js.HtmlDom"/>
	<e path="Void"/>
</f></replaceChild>
	<removeChild set="method"><f a="child">
	<t path="js.HtmlDom"/>
	<t path="js.HtmlDom"/>
</f></removeChild>
	<previousSibling><t path="js.HtmlDom"/></previousSibling>
	<parentNode><t path="js.HtmlDom"/></parentNode>
	<onsubmit><f a="">
	<t path="js.Event"/>
	<e path="Bool"/>
</f></onsubmit>
	<onscroll><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onscroll>
	<onresize><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onresize>
	<onreset><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onreset>
	<onmouseup><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmouseup>
	<onmouseover><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmouseover>
	<onmouseout><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmouseout>
	<onmousemove><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmousemove>
	<onmousedown><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmousedown>
	<onkeyup><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onkeyup>
	<onkeypress><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onkeypress>
	<onkeydown><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onkeydown>
	<onfocus><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onfocus>
	<ondblclick><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></ondblclick>
	<onclick><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onclick>
	<onblur><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onblur>
	<offsetWidth><c path="Int"/></offsetWidth>
	<offsetTop><c path="Int"/></offsetTop>
	<offsetParent><t path="js.HtmlDom"/></offsetParent>
	<offsetLeft><c path="Int"/></offsetLeft>
	<offsetHeight><c path="Int"/></offsetHeight>
	<nodeValue><c path="String"/></nodeValue>
	<nodeType><c path="Int"/></nodeType>
	<nodeName><c path="String"/></nodeName>
	<nextSibling><t path="js.HtmlDom"/></nextSibling>
	<name><c path="String"/></name>
	<method><c path="String"/></method>
	<length><c path="Int"/></length>
	<lastChild><t path="js.HtmlDom"/></lastChild>
	<lang><c path="String"/></lang>
	<insertBefore set="method"><f a="newChild:refChild">
	<t path="js.HtmlDom"/>
	<t path="js.HtmlDom"/>
	<e path="Void"/>
</f></insertBefore>
	<innerHTML><c path="String"/></innerHTML>
	<id><c path="String"/></id>
	<hasChildNodes set="method"><f a=""><e path="Bool"/></f></hasChildNodes>
	<getElementsByTagName set="method"><f a="tag">
	<c path="String"/>
	<c path="js.HtmlCollection"><t path="js.HtmlDom"/></c>
</f></getElementsByTagName>
	<getAttribute set="method"><f a="attr">
	<c path="String"/>
	<c path="String"/>
</f></getAttribute>
	<focus set="method"><f a=""><e path="Void"/></f></focus>
	<firstChild><t path="js.HtmlDom"/></firstChild>
	<enctype><c path="String"/></enctype>
	<encoding><c path="String"/></encoding>
	<elements><c path="js.HtmlCollection"><t path="js.FormElement"/></c></elements>
	<dir><c path="String"/></dir>
	<cloneNode set="method"><f a="deep">
	<e path="Bool"/>
	<t path="js.HtmlDom"/>
</f></cloneNode>
	<clientWidth set="null"><c path="Int"/></clientWidth>
	<clientHeight set="null"><c path="Int"/></clientHeight>
	<click set="method"><f a=""><e path="Void"/></f></click>
	<className><c path="String"/></className>
	<childNodes><c path="js.HtmlCollection"><t path="js.HtmlDom"/></c></childNodes>
	<blur set="method"><f a=""><e path="Void"/></f></blur>
	<appendChild set="method"><f a="child">
	<t path="js.HtmlDom"/>
	<e path="Void"/>
</f></appendChild>
	<action><c path="String"/></action>
	<acceptCharset><c path="String"/></acceptCharset>
</a></typedef>
	<typedef path="js.Frame" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/js/Dom.hx" module="js.Dom"><a>
	<title><c path="String"/></title>
	<style><t path="js.Style"/></style>
	<src><c path="String"/></src>
	<setAttribute set="method"><f a="attr:val">
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></setAttribute>
	<scrolling><c path="String"/></scrolling>
	<scrollWidth set="null"><c path="Int"/></scrollWidth>
	<scrollTop><c path="Int"/></scrollTop>
	<scrollLeft><c path="Int"/></scrollLeft>
	<scrollHeight set="null"><c path="Int"/></scrollHeight>
	<replaceChild set="method"><f a="child:oldChild">
	<t path="js.HtmlDom"/>
	<t path="js.HtmlDom"/>
	<e path="Void"/>
</f></replaceChild>
	<removeChild set="method"><f a="child">
	<t path="js.HtmlDom"/>
	<t path="js.HtmlDom"/>
</f></removeChild>
	<previousSibling><t path="js.HtmlDom"/></previousSibling>
	<parentNode><t path="js.HtmlDom"/></parentNode>
	<onscroll><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onscroll>
	<onresize><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onresize>
	<onmouseup><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmouseup>
	<onmouseover><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmouseover>
	<onmouseout><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmouseout>
	<onmousemove><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmousemove>
	<onmousedown><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmousedown>
	<onkeyup><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onkeyup>
	<onkeypress><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onkeypress>
	<onkeydown><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onkeydown>
	<onfocus><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onfocus>
	<ondblclick><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></ondblclick>
	<onclick><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onclick>
	<onblur><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onblur>
	<offsetWidth><c path="Int"/></offsetWidth>
	<offsetTop><c path="Int"/></offsetTop>
	<offsetParent><t path="js.HtmlDom"/></offsetParent>
	<offsetLeft><c path="Int"/></offsetLeft>
	<offsetHeight><c path="Int"/></offsetHeight>
	<nodeValue><c path="String"/></nodeValue>
	<nodeType><c path="Int"/></nodeType>
	<nodeName><c path="String"/></nodeName>
	<noResize><e path="Bool"/></noResize>
	<nextSibling><t path="js.HtmlDom"/></nextSibling>
	<name><c path="String"/></name>
	<marginWidth><c path="String"/></marginWidth>
	<marginHeight><c path="String"/></marginHeight>
	<lastChild><t path="js.HtmlDom"/></lastChild>
	<lang><c path="String"/></lang>
	<insertBefore set="method"><f a="newChild:refChild">
	<t path="js.HtmlDom"/>
	<t path="js.HtmlDom"/>
	<e path="Void"/>
</f></insertBefore>
	<innerHTML><c path="String"/></innerHTML>
	<id><c path="String"/></id>
	<hasChildNodes set="method"><f a=""><e path="Bool"/></f></hasChildNodes>
	<getElementsByTagName set="method"><f a="tag">
	<c path="String"/>
	<c path="js.HtmlCollection"><t path="js.HtmlDom"/></c>
</f></getElementsByTagName>
	<getAttribute set="method"><f a="attr">
	<c path="String"/>
	<c path="String"/>
</f></getAttribute>
	<frameBorder><c path="String"/></frameBorder>
	<focus set="method"><f a=""><e path="Void"/></f></focus>
	<firstChild><t path="js.HtmlDom"/></firstChild>
	<dir><c path="String"/></dir>
	<contentDocument><t path="js.Document"/></contentDocument>
	<cloneNode set="method"><f a="deep">
	<e path="Bool"/>
	<t path="js.HtmlDom"/>
</f></cloneNode>
	<clientWidth set="null"><c path="Int"/></clientWidth>
	<clientHeight set="null"><c path="Int"/></clientHeight>
	<click set="method"><f a=""><e path="Void"/></f></click>
	<className><c path="String"/></className>
	<childNodes><c path="js.HtmlCollection"><t path="js.HtmlDom"/></c></childNodes>
	<blur set="method"><f a=""><e path="Void"/></f></blur>
	<appendChild set="method"><f a="child">
	<t path="js.HtmlDom"/>
	<e path="Void"/>
</f></appendChild>
</a></typedef>
	<typedef path="js.Frameset" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/js/Dom.hx" module="js.Dom"><a>
	<title><c path="String"/></title>
	<style><t path="js.Style"/></style>
	<setAttribute set="method"><f a="attr:val">
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></setAttribute>
	<scrollWidth set="null"><c path="Int"/></scrollWidth>
	<scrollTop><c path="Int"/></scrollTop>
	<scrollLeft><c path="Int"/></scrollLeft>
	<scrollHeight set="null"><c path="Int"/></scrollHeight>
	<rows><c path="Int"/></rows>
	<replaceChild set="method"><f a="child:oldChild">
	<t path="js.HtmlDom"/>
	<t path="js.HtmlDom"/>
	<e path="Void"/>
</f></replaceChild>
	<removeChild set="method"><f a="child">
	<t path="js.HtmlDom"/>
	<t path="js.HtmlDom"/>
</f></removeChild>
	<previousSibling><t path="js.HtmlDom"/></previousSibling>
	<parentNode><t path="js.HtmlDom"/></parentNode>
	<onscroll><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onscroll>
	<onresize><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onresize>
	<onmouseup><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmouseup>
	<onmouseover><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmouseover>
	<onmouseout><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmouseout>
	<onmousemove><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmousemove>
	<onmousedown><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmousedown>
	<onkeyup><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onkeyup>
	<onkeypress><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onkeypress>
	<onkeydown><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onkeydown>
	<onfocus><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onfocus>
	<ondblclick><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></ondblclick>
	<onclick><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onclick>
	<onblur><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onblur>
	<offsetWidth><c path="Int"/></offsetWidth>
	<offsetTop><c path="Int"/></offsetTop>
	<offsetParent><t path="js.HtmlDom"/></offsetParent>
	<offsetLeft><c path="Int"/></offsetLeft>
	<offsetHeight><c path="Int"/></offsetHeight>
	<nodeValue><c path="String"/></nodeValue>
	<nodeType><c path="Int"/></nodeType>
	<nodeName><c path="String"/></nodeName>
	<nextSibling><t path="js.HtmlDom"/></nextSibling>
	<lastChild><t path="js.HtmlDom"/></lastChild>
	<lang><c path="String"/></lang>
	<insertBefore set="method"><f a="newChild:refChild">
	<t path="js.HtmlDom"/>
	<t path="js.HtmlDom"/>
	<e path="Void"/>
</f></insertBefore>
	<innerHTML><c path="String"/></innerHTML>
	<id><c path="String"/></id>
	<hasChildNodes set="method"><f a=""><e path="Bool"/></f></hasChildNodes>
	<getElementsByTagName set="method"><f a="tag">
	<c path="String"/>
	<c path="js.HtmlCollection"><t path="js.HtmlDom"/></c>
</f></getElementsByTagName>
	<getAttribute set="method"><f a="attr">
	<c path="String"/>
	<c path="String"/>
</f></getAttribute>
	<focus set="method"><f a=""><e path="Void"/></f></focus>
	<firstChild><t path="js.HtmlDom"/></firstChild>
	<dir><c path="String"/></dir>
	<cols><c path="Int"/></cols>
	<cloneNode set="method"><f a="deep">
	<e path="Bool"/>
	<t path="js.HtmlDom"/>
</f></cloneNode>
	<clientWidth set="null"><c path="Int"/></clientWidth>
	<clientHeight set="null"><c path="Int"/></clientHeight>
	<click set="method"><f a=""><e path="Void"/></f></click>
	<className><c path="String"/></className>
	<childNodes><c path="js.HtmlCollection"><t path="js.HtmlDom"/></c></childNodes>
	<blur set="method"><f a=""><e path="Void"/></f></blur>
	<appendChild set="method"><f a="child">
	<t path="js.HtmlDom"/>
	<e path="Void"/>
</f></appendChild>
</a></typedef>
	<typedef path="js.Hidden" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/js/Dom.hx" module="js.Dom"><a>
	<value><c path="String"/></value>
	<type><c path="String"/></type>
	<title><c path="String"/></title>
	<style><t path="js.Style"/></style>
	<setAttribute set="method"><f a="attr:val">
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></setAttribute>
	<select set="method"><f a=""><e path="Void"/></f></select>
	<scrollWidth set="null"><c path="Int"/></scrollWidth>
	<scrollTop><c path="Int"/></scrollTop>
	<scrollLeft><c path="Int"/></scrollLeft>
	<scrollHeight set="null"><c path="Int"/></scrollHeight>
	<replaceChild set="method"><f a="child:oldChild">
	<t path="js.HtmlDom"/>
	<t path="js.HtmlDom"/>
	<e path="Void"/>
</f></replaceChild>
	<removeChild set="method"><f a="child">
	<t path="js.HtmlDom"/>
	<t path="js.HtmlDom"/>
</f></removeChild>
	<previousSibling><t path="js.HtmlDom"/></previousSibling>
	<parentNode><t path="js.HtmlDom"/></parentNode>
	<onselect><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onselect>
	<onscroll><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onscroll>
	<onresize><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onresize>
	<onmouseup><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmouseup>
	<onmouseover><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmouseover>
	<onmouseout><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmouseout>
	<onmousemove><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmousemove>
	<onmousedown><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmousedown>
	<onkeyup><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onkeyup>
	<onkeypress><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onkeypress>
	<onkeydown><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onkeydown>
	<onfocus><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onfocus>
	<ondblclick><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></ondblclick>
	<onclick><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onclick>
	<onchange><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onchange>
	<onblur><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onblur>
	<offsetWidth><c path="Int"/></offsetWidth>
	<offsetTop><c path="Int"/></offsetTop>
	<offsetParent><t path="js.HtmlDom"/></offsetParent>
	<offsetLeft><c path="Int"/></offsetLeft>
	<offsetHeight><c path="Int"/></offsetHeight>
	<nodeValue><c path="String"/></nodeValue>
	<nodeType><c path="Int"/></nodeType>
	<nodeName><c path="String"/></nodeName>
	<nextSibling><t path="js.HtmlDom"/></nextSibling>
	<name><c path="String"/></name>
	<lastChild><t path="js.HtmlDom"/></lastChild>
	<lang><c path="String"/></lang>
	<insertBefore set="method"><f a="newChild:refChild">
	<t path="js.HtmlDom"/>
	<t path="js.HtmlDom"/>
	<e path="Void"/>
</f></insertBefore>
	<innerHTML><c path="String"/></innerHTML>
	<id><c path="String"/></id>
	<hasChildNodes set="method"><f a=""><e path="Bool"/></f></hasChildNodes>
	<getElementsByTagName set="method"><f a="tag">
	<c path="String"/>
	<c path="js.HtmlCollection"><t path="js.HtmlDom"/></c>
</f></getElementsByTagName>
	<getAttribute set="method"><f a="attr">
	<c path="String"/>
	<c path="String"/>
</f></getAttribute>
	<form><t path="js.Form"/></form>
	<focus set="method"><f a=""><e path="Void"/></f></focus>
	<firstChild><t path="js.HtmlDom"/></firstChild>
	<disabled><e path="Bool"/></disabled>
	<dir><c path="String"/></dir>
	<defaultValue><c path="String"/></defaultValue>
	<cloneNode set="method"><f a="deep">
	<e path="Bool"/>
	<t path="js.HtmlDom"/>
</f></cloneNode>
	<clientWidth set="null"><c path="Int"/></clientWidth>
	<clientHeight set="null"><c path="Int"/></clientHeight>
	<click set="method"><f a=""><e path="Void"/></f></click>
	<className><c path="String"/></className>
	<childNodes><c path="js.HtmlCollection"><t path="js.HtmlDom"/></c></childNodes>
	<blur set="method"><f a=""><e path="Void"/></f></blur>
	<appendChild set="method"><f a="child">
	<t path="js.HtmlDom"/>
	<e path="Void"/>
</f></appendChild>
</a></typedef>
	<typedef path="js.History" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/js/Dom.hx" module="js.Dom"><a>
	<length><c path="Int"/></length>
	<go set="method"><f a="p">
	<d/>
	<e path="Void"/>
</f></go>
	<forward set="method"><f a=""><e path="Void"/></f></forward>
	<back set="method"><f a=""><e path="Void"/></f></back>
</a></typedef>
	<typedef path="js.IFrame" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/js/Dom.hx" module="js.Dom"><a>
	<width><c path="Int"/></width>
	<title><c path="String"/></title>
	<style><t path="js.Style"/></style>
	<src><c path="String"/></src>
	<setAttribute set="method"><f a="attr:val">
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></setAttribute>
	<scrolling><c path="String"/></scrolling>
	<scrollWidth set="null"><c path="Int"/></scrollWidth>
	<scrollTop><c path="Int"/></scrollTop>
	<scrollLeft><c path="Int"/></scrollLeft>
	<scrollHeight set="null"><c path="Int"/></scrollHeight>
	<replaceChild set="method"><f a="child:oldChild">
	<t path="js.HtmlDom"/>
	<t path="js.HtmlDom"/>
	<e path="Void"/>
</f></replaceChild>
	<removeChild set="method"><f a="child">
	<t path="js.HtmlDom"/>
	<t path="js.HtmlDom"/>
</f></removeChild>
	<previousSibling><t path="js.HtmlDom"/></previousSibling>
	<parentNode><t path="js.HtmlDom"/></parentNode>
	<onscroll><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onscroll>
	<onresize><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onresize>
	<onmouseup><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmouseup>
	<onmouseover><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmouseover>
	<onmouseout><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmouseout>
	<onmousemove><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmousemove>
	<onmousedown><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmousedown>
	<onkeyup><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onkeyup>
	<onkeypress><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onkeypress>
	<onkeydown><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onkeydown>
	<onfocus><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onfocus>
	<ondblclick><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></ondblclick>
	<onclick><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onclick>
	<onblur><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onblur>
	<offsetWidth><c path="Int"/></offsetWidth>
	<offsetTop><c path="Int"/></offsetTop>
	<offsetParent><t path="js.HtmlDom"/></offsetParent>
	<offsetLeft><c path="Int"/></offsetLeft>
	<offsetHeight><c path="Int"/></offsetHeight>
	<nodeValue><c path="String"/></nodeValue>
	<nodeType><c path="Int"/></nodeType>
	<nodeName><c path="String"/></nodeName>
	<nextSibling><t path="js.HtmlDom"/></nextSibling>
	<name><c path="String"/></name>
	<marginWidth><c path="String"/></marginWidth>
	<marginHeight><c path="String"/></marginHeight>
	<lastChild><t path="js.HtmlDom"/></lastChild>
	<lang><c path="String"/></lang>
	<insertBefore set="method"><f a="newChild:refChild">
	<t path="js.HtmlDom"/>
	<t path="js.HtmlDom"/>
	<e path="Void"/>
</f></insertBefore>
	<innerHTML><c path="String"/></innerHTML>
	<id><c path="String"/></id>
	<height><c path="Int"/></height>
	<hasChildNodes set="method"><f a=""><e path="Bool"/></f></hasChildNodes>
	<getElementsByTagName set="method"><f a="tag">
	<c path="String"/>
	<c path="js.HtmlCollection"><t path="js.HtmlDom"/></c>
</f></getElementsByTagName>
	<getAttribute set="method"><f a="attr">
	<c path="String"/>
	<c path="String"/>
</f></getAttribute>
	<frameBorder><c path="String"/></frameBorder>
	<focus set="method"><f a=""><e path="Void"/></f></focus>
	<firstChild><t path="js.HtmlDom"/></firstChild>
	<dir><c path="String"/></dir>
	<contentWindow><t path="js.Window"/></contentWindow>
	<cloneNode set="method"><f a="deep">
	<e path="Bool"/>
	<t path="js.HtmlDom"/>
</f></cloneNode>
	<clientWidth set="null"><c path="Int"/></clientWidth>
	<clientHeight set="null"><c path="Int"/></clientHeight>
	<click set="method"><f a=""><e path="Void"/></f></click>
	<className><c path="String"/></className>
	<childNodes><c path="js.HtmlCollection"><t path="js.HtmlDom"/></c></childNodes>
	<blur set="method"><f a=""><e path="Void"/></f></blur>
	<appendChild set="method"><f a="child">
	<t path="js.HtmlDom"/>
	<e path="Void"/>
</f></appendChild>
</a></typedef>
	<typedef path="js.Image" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/js/Dom.hx" module="js.Dom"><a>
	<width><c path="Int"/></width>
	<vspace><c path="Int"/></vspace>
	<useMap><c path="String"/></useMap>
	<title><c path="String"/></title>
	<style><t path="js.Style"/></style>
	<src><c path="String"/></src>
	<setAttribute set="method"><f a="attr:val">
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></setAttribute>
	<scrollWidth set="null"><c path="Int"/></scrollWidth>
	<scrollTop><c path="Int"/></scrollTop>
	<scrollLeft><c path="Int"/></scrollLeft>
	<scrollHeight set="null"><c path="Int"/></scrollHeight>
	<replaceChild set="method"><f a="child:oldChild">
	<t path="js.HtmlDom"/>
	<t path="js.HtmlDom"/>
	<e path="Void"/>
</f></replaceChild>
	<removeChild set="method"><f a="child">
	<t path="js.HtmlDom"/>
	<t path="js.HtmlDom"/>
</f></removeChild>
	<previousSibling><t path="js.HtmlDom"/></previousSibling>
	<parentNode><t path="js.HtmlDom"/></parentNode>
	<onscroll><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onscroll>
	<onresize><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onresize>
	<onmouseup><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmouseup>
	<onmouseover><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmouseover>
	<onmouseout><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmouseout>
	<onmousemove><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmousemove>
	<onmousedown><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmousedown>
	<onload><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onload>
	<onkeyup><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onkeyup>
	<onkeypress><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onkeypress>
	<onkeydown><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onkeydown>
	<onfocus><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onfocus>
	<onerror><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onerror>
	<ondblclick><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></ondblclick>
	<onclick><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onclick>
	<onblur><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onblur>
	<onabort><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onabort>
	<offsetWidth><c path="Int"/></offsetWidth>
	<offsetTop><c path="Int"/></offsetTop>
	<offsetParent><t path="js.HtmlDom"/></offsetParent>
	<offsetLeft><c path="Int"/></offsetLeft>
	<offsetHeight><c path="Int"/></offsetHeight>
	<nodeValue><c path="String"/></nodeValue>
	<nodeType><c path="Int"/></nodeType>
	<nodeName><c path="String"/></nodeName>
	<nextSibling><t path="js.HtmlDom"/></nextSibling>
	<name><c path="String"/></name>
	<lowsrc><c path="String"/></lowsrc>
	<lastChild><t path="js.HtmlDom"/></lastChild>
	<lang><c path="String"/></lang>
	<isMap><e path="Bool"/></isMap>
	<insertBefore set="method"><f a="newChild:refChild">
	<t path="js.HtmlDom"/>
	<t path="js.HtmlDom"/>
	<e path="Void"/>
</f></insertBefore>
	<innerHTML><c path="String"/></innerHTML>
	<id><c path="String"/></id>
	<hspace><c path="Int"/></hspace>
	<height><c path="Int"/></height>
	<hasChildNodes set="method"><f a=""><e path="Bool"/></f></hasChildNodes>
	<getElementsByTagName set="method"><f a="tag">
	<c path="String"/>
	<c path="js.HtmlCollection"><t path="js.HtmlDom"/></c>
</f></getElementsByTagName>
	<getAttribute set="method"><f a="attr">
	<c path="String"/>
	<c path="String"/>
</f></getAttribute>
	<focus set="method"><f a=""><e path="Void"/></f></focus>
	<firstChild><t path="js.HtmlDom"/></firstChild>
	<dir><c path="String"/></dir>
	<complete><e path="Bool"/></complete>
	<cloneNode set="method"><f a="deep">
	<e path="Bool"/>
	<t path="js.HtmlDom"/>
</f></cloneNode>
	<clientWidth set="null"><c path="Int"/></clientWidth>
	<clientHeight set="null"><c path="Int"/></clientHeight>
	<click set="method"><f a=""><e path="Void"/></f></click>
	<className><c path="String"/></className>
	<childNodes><c path="js.HtmlCollection"><t path="js.HtmlDom"/></c></childNodes>
	<border><c path="String"/></border>
	<blur set="method"><f a=""><e path="Void"/></f></blur>
	<appendChild set="method"><f a="child">
	<t path="js.HtmlDom"/>
	<e path="Void"/>
</f></appendChild>
	<alt><c path="String"/></alt>
	<align><c path="String"/></align>
</a></typedef>
	<typedef path="js.Link" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/js/Dom.hx" module="js.Dom"><a>
	<type><c path="String"/></type>
	<title><c path="String"/></title>
	<target><c path="String"/></target>
	<style><t path="js.Style"/></style>
	<setAttribute set="method"><f a="attr:val">
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></setAttribute>
	<scrollWidth set="null"><c path="Int"/></scrollWidth>
	<scrollTop><c path="Int"/></scrollTop>
	<scrollLeft><c path="Int"/></scrollLeft>
	<scrollHeight set="null"><c path="Int"/></scrollHeight>
	<rev><c path="String"/></rev>
	<replaceChild set="method"><f a="child:oldChild">
	<t path="js.HtmlDom"/>
	<t path="js.HtmlDom"/>
	<e path="Void"/>
</f></replaceChild>
	<removeChild set="method"><f a="child">
	<t path="js.HtmlDom"/>
	<t path="js.HtmlDom"/>
</f></removeChild>
	<rel><c path="String"/></rel>
	<previousSibling><t path="js.HtmlDom"/></previousSibling>
	<parentNode><t path="js.HtmlDom"/></parentNode>
	<onscroll><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onscroll>
	<onresize><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onresize>
	<onmouseup><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmouseup>
	<onmouseover><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmouseover>
	<onmouseout><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmouseout>
	<onmousemove><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmousemove>
	<onmousedown><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmousedown>
	<onload><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onload>
	<onkeyup><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onkeyup>
	<onkeypress><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onkeypress>
	<onkeydown><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onkeydown>
	<onfocus><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onfocus>
	<ondblclick><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></ondblclick>
	<onclick><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onclick>
	<onblur><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onblur>
	<offsetWidth><c path="Int"/></offsetWidth>
	<offsetTop><c path="Int"/></offsetTop>
	<offsetParent><t path="js.HtmlDom"/></offsetParent>
	<offsetLeft><c path="Int"/></offsetLeft>
	<offsetHeight><c path="Int"/></offsetHeight>
	<nodeValue><c path="String"/></nodeValue>
	<nodeType><c path="Int"/></nodeType>
	<nodeName><c path="String"/></nodeName>
	<nextSibling><t path="js.HtmlDom"/></nextSibling>
	<name><c path="String"/></name>
	<media><c path="String"/></media>
	<lastChild><t path="js.HtmlDom"/></lastChild>
	<lang><c path="String"/></lang>
	<insertBefore set="method"><f a="newChild:refChild">
	<t path="js.HtmlDom"/>
	<t path="js.HtmlDom"/>
	<e path="Void"/>
</f></insertBefore>
	<innerHTML><c path="String"/></innerHTML>
	<id><c path="String"/></id>
	<hreflang><c path="String"/></hreflang>
	<href><c path="String"/></href>
	<hasChildNodes set="method"><f a=""><e path="Bool"/></f></hasChildNodes>
	<getElementsByTagName set="method"><f a="tag">
	<c path="String"/>
	<c path="js.HtmlCollection"><t path="js.HtmlDom"/></c>
</f></getElementsByTagName>
	<getAttribute set="method"><f a="attr">
	<c path="String"/>
	<c path="String"/>
</f></getAttribute>
	<focus set="method"><f a=""><e path="Void"/></f></focus>
	<firstChild><t path="js.HtmlDom"/></firstChild>
	<disabled><e path="Bool"/></disabled>
	<dir><c path="String"/></dir>
	<cloneNode set="method"><f a="deep">
	<e path="Bool"/>
	<t path="js.HtmlDom"/>
</f></cloneNode>
	<clientWidth set="null"><c path="Int"/></clientWidth>
	<clientHeight set="null"><c path="Int"/></clientHeight>
	<click set="method"><f a=""><e path="Void"/></f></click>
	<className><c path="String"/></className>
	<childNodes><c path="js.HtmlCollection"><t path="js.HtmlDom"/></c></childNodes>
	<charset><c path="String"/></charset>
	<blur set="method"><f a=""><e path="Void"/></f></blur>
	<appendChild set="method"><f a="child">
	<t path="js.HtmlDom"/>
	<e path="Void"/>
</f></appendChild>
</a></typedef>
	<typedef path="js.Location" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/js/Dom.hx" module="js.Dom"><a>
	<search><c path="String"/></search>
	<replace set="method"><f a="url">
	<c path="String"/>
	<e path="Void"/>
</f></replace>
	<reload set="method"><f a="?forceReload">
	<e path="Bool"/>
	<e path="Void"/>
</f></reload>
	<protocol><c path="String"/></protocol>
	<port><c path="Int"/></port>
	<pathname><c path="String"/></pathname>
	<href><c path="String"/></href>
	<hostname><c path="String"/></hostname>
	<host><c path="String"/></host>
	<hash><c path="String"/></hash>
	<assign set="method"><f a="url">
	<c path="String"/>
	<e path="Void"/>
</f></assign>
</a></typedef>
	<typedef path="js.Navigator" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/js/Dom.hx" module="js.Dom"><a>
	<userAgent><c path="String"/></userAgent>
	<taintEnabled set="method"><f a=""><e path="Bool"/></f></taintEnabled>
	<platform><c path="String"/></platform>
	<javaEnabled set="method"><f a=""><e path="Bool"/></f></javaEnabled>
	<cookieEnabled><e path="Bool"/></cookieEnabled>
	<appVersion><c path="String"/></appVersion>
	<appName><c path="String"/></appName>
	<appCodeName><c path="String"/></appCodeName>
</a></typedef>
	<typedef path="js.Option" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/js/Dom.hx" module="js.Dom"><a>
	<value><c path="String"/></value>
	<type><c path="String"/></type>
	<title><c path="String"/></title>
	<text><c path="String"/></text>
	<style><t path="js.Style"/></style>
	<setAttribute set="method"><f a="attr:val">
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></setAttribute>
	<selected><e path="Bool"/></selected>
	<select set="method"><f a=""><e path="Void"/></f></select>
	<scrollWidth set="null"><c path="Int"/></scrollWidth>
	<scrollTop><c path="Int"/></scrollTop>
	<scrollLeft><c path="Int"/></scrollLeft>
	<scrollHeight set="null"><c path="Int"/></scrollHeight>
	<replaceChild set="method"><f a="child:oldChild">
	<t path="js.HtmlDom"/>
	<t path="js.HtmlDom"/>
	<e path="Void"/>
</f></replaceChild>
	<removeChild set="method"><f a="child">
	<t path="js.HtmlDom"/>
	<t path="js.HtmlDom"/>
</f></removeChild>
	<previousSibling><t path="js.HtmlDom"/></previousSibling>
	<parentNode><t path="js.HtmlDom"/></parentNode>
	<onselect><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onselect>
	<onscroll><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onscroll>
	<onresize><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onresize>
	<onmouseup><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmouseup>
	<onmouseover><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmouseover>
	<onmouseout><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmouseout>
	<onmousemove><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmousemove>
	<onmousedown><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmousedown>
	<onkeyup><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onkeyup>
	<onkeypress><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onkeypress>
	<onkeydown><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onkeydown>
	<onfocus><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onfocus>
	<ondblclick><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></ondblclick>
	<onclick><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onclick>
	<onchange><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onchange>
	<onblur><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onblur>
	<offsetWidth><c path="Int"/></offsetWidth>
	<offsetTop><c path="Int"/></offsetTop>
	<offsetParent><t path="js.HtmlDom"/></offsetParent>
	<offsetLeft><c path="Int"/></offsetLeft>
	<offsetHeight><c path="Int"/></offsetHeight>
	<nodeValue><c path="String"/></nodeValue>
	<nodeType><c path="Int"/></nodeType>
	<nodeName><c path="String"/></nodeName>
	<nextSibling><t path="js.HtmlDom"/></nextSibling>
	<name><c path="String"/></name>
	<lastChild><t path="js.HtmlDom"/></lastChild>
	<lang><c path="String"/></lang>
	<insertBefore set="method"><f a="newChild:refChild">
	<t path="js.HtmlDom"/>
	<t path="js.HtmlDom"/>
	<e path="Void"/>
</f></insertBefore>
	<innerHTML><c path="String"/></innerHTML>
	<id><c path="String"/></id>
	<hasChildNodes set="method"><f a=""><e path="Bool"/></f></hasChildNodes>
	<getElementsByTagName set="method"><f a="tag">
	<c path="String"/>
	<c path="js.HtmlCollection"><t path="js.HtmlDom"/></c>
</f></getElementsByTagName>
	<getAttribute set="method"><f a="attr">
	<c path="String"/>
	<c path="String"/>
</f></getAttribute>
	<form><t path="js.Form"/></form>
	<focus set="method"><f a=""><e path="Void"/></f></focus>
	<firstChild><t path="js.HtmlDom"/></firstChild>
	<disabled><e path="Bool"/></disabled>
	<dir><c path="String"/></dir>
	<defaultSelected><e path="Bool"/></defaultSelected>
	<cloneNode set="method"><f a="deep">
	<e path="Bool"/>
	<t path="js.HtmlDom"/>
</f></cloneNode>
	<clientWidth set="null"><c path="Int"/></clientWidth>
	<clientHeight set="null"><c path="Int"/></clientHeight>
	<click set="method"><f a=""><e path="Void"/></f></click>
	<className><c path="String"/></className>
	<childNodes><c path="js.HtmlCollection"><t path="js.HtmlDom"/></c></childNodes>
	<blur set="method"><f a=""><e path="Void"/></f></blur>
	<appendChild set="method"><f a="child">
	<t path="js.HtmlDom"/>
	<e path="Void"/>
</f></appendChild>
</a></typedef>
	<typedef path="js.Password" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/js/Dom.hx" module="js.Dom"><a>
	<value><c path="String"/></value>
	<type><c path="String"/></type>
	<title><c path="String"/></title>
	<style><t path="js.Style"/></style>
	<size><c path="Int"/></size>
	<setAttribute set="method"><f a="attr:val">
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></setAttribute>
	<select set="method"><f a=""><e path="Void"/></f></select>
	<scrollWidth set="null"><c path="Int"/></scrollWidth>
	<scrollTop><c path="Int"/></scrollTop>
	<scrollLeft><c path="Int"/></scrollLeft>
	<scrollHeight set="null"><c path="Int"/></scrollHeight>
	<replaceChild set="method"><f a="child:oldChild">
	<t path="js.HtmlDom"/>
	<t path="js.HtmlDom"/>
	<e path="Void"/>
</f></replaceChild>
	<removeChild set="method"><f a="child">
	<t path="js.HtmlDom"/>
	<t path="js.HtmlDom"/>
</f></removeChild>
	<readOnly><e path="Bool"/></readOnly>
	<previousSibling><t path="js.HtmlDom"/></previousSibling>
	<parentNode><t path="js.HtmlDom"/></parentNode>
	<onselect><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onselect>
	<onscroll><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onscroll>
	<onresize><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onresize>
	<onmouseup><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmouseup>
	<onmouseover><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmouseover>
	<onmouseout><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmouseout>
	<onmousemove><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmousemove>
	<onmousedown><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmousedown>
	<onkeyup><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onkeyup>
	<onkeypress><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onkeypress>
	<onkeydown><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onkeydown>
	<onfocus><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onfocus>
	<ondblclick><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></ondblclick>
	<onclick><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onclick>
	<onchange><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onchange>
	<onblur><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onblur>
	<offsetWidth><c path="Int"/></offsetWidth>
	<offsetTop><c path="Int"/></offsetTop>
	<offsetParent><t path="js.HtmlDom"/></offsetParent>
	<offsetLeft><c path="Int"/></offsetLeft>
	<offsetHeight><c path="Int"/></offsetHeight>
	<nodeValue><c path="String"/></nodeValue>
	<nodeType><c path="Int"/></nodeType>
	<nodeName><c path="String"/></nodeName>
	<nextSibling><t path="js.HtmlDom"/></nextSibling>
	<name><c path="String"/></name>
	<maxLength><c path="Int"/></maxLength>
	<lastChild><t path="js.HtmlDom"/></lastChild>
	<lang><c path="String"/></lang>
	<insertBefore set="method"><f a="newChild:refChild">
	<t path="js.HtmlDom"/>
	<t path="js.HtmlDom"/>
	<e path="Void"/>
</f></insertBefore>
	<innerHTML><c path="String"/></innerHTML>
	<id><c path="String"/></id>
	<hasChildNodes set="method"><f a=""><e path="Bool"/></f></hasChildNodes>
	<getElementsByTagName set="method"><f a="tag">
	<c path="String"/>
	<c path="js.HtmlCollection"><t path="js.HtmlDom"/></c>
</f></getElementsByTagName>
	<getAttribute set="method"><f a="attr">
	<c path="String"/>
	<c path="String"/>
</f></getAttribute>
	<form><t path="js.Form"/></form>
	<focus set="method"><f a=""><e path="Void"/></f></focus>
	<firstChild><t path="js.HtmlDom"/></firstChild>
	<disabled><e path="Bool"/></disabled>
	<dir><c path="String"/></dir>
	<defaultValue><c path="String"/></defaultValue>
	<cloneNode set="method"><f a="deep">
	<e path="Bool"/>
	<t path="js.HtmlDom"/>
</f></cloneNode>
	<clientWidth set="null"><c path="Int"/></clientWidth>
	<clientHeight set="null"><c path="Int"/></clientHeight>
	<click set="method"><f a=""><e path="Void"/></f></click>
	<className><c path="String"/></className>
	<childNodes><c path="js.HtmlCollection"><t path="js.HtmlDom"/></c></childNodes>
	<blur set="method"><f a=""><e path="Void"/></f></blur>
	<appendChild set="method"><f a="child">
	<t path="js.HtmlDom"/>
	<e path="Void"/>
</f></appendChild>
</a></typedef>
	<typedef path="js.Radio" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/js/Dom.hx" module="js.Dom"><a>
	<value><c path="String"/></value>
	<type><c path="String"/></type>
	<title><c path="String"/></title>
	<style><t path="js.Style"/></style>
	<size><c path="Int"/></size>
	<setAttribute set="method"><f a="attr:val">
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></setAttribute>
	<select set="method"><f a=""><e path="Void"/></f></select>
	<scrollWidth set="null"><c path="Int"/></scrollWidth>
	<scrollTop><c path="Int"/></scrollTop>
	<scrollLeft><c path="Int"/></scrollLeft>
	<scrollHeight set="null"><c path="Int"/></scrollHeight>
	<replaceChild set="method"><f a="child:oldChild">
	<t path="js.HtmlDom"/>
	<t path="js.HtmlDom"/>
	<e path="Void"/>
</f></replaceChild>
	<removeChild set="method"><f a="child">
	<t path="js.HtmlDom"/>
	<t path="js.HtmlDom"/>
</f></removeChild>
	<previousSibling><t path="js.HtmlDom"/></previousSibling>
	<parentNode><t path="js.HtmlDom"/></parentNode>
	<onselect><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onselect>
	<onscroll><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onscroll>
	<onresize><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onresize>
	<onmouseup><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmouseup>
	<onmouseover><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmouseover>
	<onmouseout><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmouseout>
	<onmousemove><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmousemove>
	<onmousedown><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmousedown>
	<onkeyup><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onkeyup>
	<onkeypress><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onkeypress>
	<onkeydown><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onkeydown>
	<onfocus><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onfocus>
	<ondblclick><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></ondblclick>
	<onclick><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onclick>
	<onchange><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onchange>
	<onblur><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onblur>
	<offsetWidth><c path="Int"/></offsetWidth>
	<offsetTop><c path="Int"/></offsetTop>
	<offsetParent><t path="js.HtmlDom"/></offsetParent>
	<offsetLeft><c path="Int"/></offsetLeft>
	<offsetHeight><c path="Int"/></offsetHeight>
	<nodeValue><c path="String"/></nodeValue>
	<nodeType><c path="Int"/></nodeType>
	<nodeName><c path="String"/></nodeName>
	<nextSibling><t path="js.HtmlDom"/></nextSibling>
	<name><c path="String"/></name>
	<lastChild><t path="js.HtmlDom"/></lastChild>
	<lang><c path="String"/></lang>
	<insertBefore set="method"><f a="newChild:refChild">
	<t path="js.HtmlDom"/>
	<t path="js.HtmlDom"/>
	<e path="Void"/>
</f></insertBefore>
	<innerHTML><c path="String"/></innerHTML>
	<id><c path="String"/></id>
	<hasChildNodes set="method"><f a=""><e path="Bool"/></f></hasChildNodes>
	<getElementsByTagName set="method"><f a="tag">
	<c path="String"/>
	<c path="js.HtmlCollection"><t path="js.HtmlDom"/></c>
</f></getElementsByTagName>
	<getAttribute set="method"><f a="attr">
	<c path="String"/>
	<c path="String"/>
</f></getAttribute>
	<form><t path="js.Form"/></form>
	<focus set="method"><f a=""><e path="Void"/></f></focus>
	<firstChild><t path="js.HtmlDom"/></firstChild>
	<disabled><e path="Bool"/></disabled>
	<dir><c path="String"/></dir>
	<defaultChecked><e path="Bool"/></defaultChecked>
	<cloneNode set="method"><f a="deep">
	<e path="Bool"/>
	<t path="js.HtmlDom"/>
</f></cloneNode>
	<clientWidth set="null"><c path="Int"/></clientWidth>
	<clientHeight set="null"><c path="Int"/></clientHeight>
	<click set="method"><f a=""><e path="Void"/></f></click>
	<className><c path="String"/></className>
	<childNodes><c path="js.HtmlCollection"><t path="js.HtmlDom"/></c></childNodes>
	<checked><e path="Bool"/></checked>
	<blur set="method"><f a=""><e path="Void"/></f></blur>
	<appendChild set="method"><f a="child">
	<t path="js.HtmlDom"/>
	<e path="Void"/>
</f></appendChild>
</a></typedef>
	<typedef path="js.Reset" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/js/Dom.hx" module="js.Dom"><a>
	<value><c path="String"/></value>
	<type><c path="String"/></type>
	<title><c path="String"/></title>
	<style><t path="js.Style"/></style>
	<setAttribute set="method"><f a="attr:val">
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></setAttribute>
	<select set="method"><f a=""><e path="Void"/></f></select>
	<scrollWidth set="null"><c path="Int"/></scrollWidth>
	<scrollTop><c path="Int"/></scrollTop>
	<scrollLeft><c path="Int"/></scrollLeft>
	<scrollHeight set="null"><c path="Int"/></scrollHeight>
	<replaceChild set="method"><f a="child:oldChild">
	<t path="js.HtmlDom"/>
	<t path="js.HtmlDom"/>
	<e path="Void"/>
</f></replaceChild>
	<removeChild set="method"><f a="child">
	<t path="js.HtmlDom"/>
	<t path="js.HtmlDom"/>
</f></removeChild>
	<previousSibling><t path="js.HtmlDom"/></previousSibling>
	<parentNode><t path="js.HtmlDom"/></parentNode>
	<onselect><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onselect>
	<onscroll><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onscroll>
	<onresize><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onresize>
	<onmouseup><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmouseup>
	<onmouseover><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmouseover>
	<onmouseout><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmouseout>
	<onmousemove><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmousemove>
	<onmousedown><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmousedown>
	<onkeyup><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onkeyup>
	<onkeypress><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onkeypress>
	<onkeydown><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onkeydown>
	<onfocus><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onfocus>
	<ondblclick><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></ondblclick>
	<onclick><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onclick>
	<onchange><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onchange>
	<onblur><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onblur>
	<offsetWidth><c path="Int"/></offsetWidth>
	<offsetTop><c path="Int"/></offsetTop>
	<offsetParent><t path="js.HtmlDom"/></offsetParent>
	<offsetLeft><c path="Int"/></offsetLeft>
	<offsetHeight><c path="Int"/></offsetHeight>
	<nodeValue><c path="String"/></nodeValue>
	<nodeType><c path="Int"/></nodeType>
	<nodeName><c path="String"/></nodeName>
	<nextSibling><t path="js.HtmlDom"/></nextSibling>
	<name><c path="String"/></name>
	<lastChild><t path="js.HtmlDom"/></lastChild>
	<lang><c path="String"/></lang>
	<insertBefore set="method"><f a="newChild:refChild">
	<t path="js.HtmlDom"/>
	<t path="js.HtmlDom"/>
	<e path="Void"/>
</f></insertBefore>
	<innerHTML><c path="String"/></innerHTML>
	<id><c path="String"/></id>
	<hasChildNodes set="method"><f a=""><e path="Bool"/></f></hasChildNodes>
	<getElementsByTagName set="method"><f a="tag">
	<c path="String"/>
	<c path="js.HtmlCollection"><t path="js.HtmlDom"/></c>
</f></getElementsByTagName>
	<getAttribute set="method"><f a="attr">
	<c path="String"/>
	<c path="String"/>
</f></getAttribute>
	<form><t path="js.Form"/></form>
	<focus set="method"><f a=""><e path="Void"/></f></focus>
	<firstChild><t path="js.HtmlDom"/></firstChild>
	<disabled><e path="Bool"/></disabled>
	<dir><c path="String"/></dir>
	<cloneNode set="method"><f a="deep">
	<e path="Bool"/>
	<t path="js.HtmlDom"/>
</f></cloneNode>
	<clientWidth set="null"><c path="Int"/></clientWidth>
	<clientHeight set="null"><c path="Int"/></clientHeight>
	<click set="method"><f a=""><e path="Void"/></f></click>
	<className><c path="String"/></className>
	<childNodes><c path="js.HtmlCollection"><t path="js.HtmlDom"/></c></childNodes>
	<blur set="method"><f a=""><e path="Void"/></f></blur>
	<appendChild set="method"><f a="child">
	<t path="js.HtmlDom"/>
	<e path="Void"/>
</f></appendChild>
</a></typedef>
	<typedef path="js.Screen" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/js/Dom.hx" module="js.Dom"><a>
	<width><c path="Int"/></width>
	<height><c path="Int"/></height>
	<colorDepth><c path="Int"/></colorDepth>
	<availWidth><c path="Int"/></availWidth>
	<availHeight><c path="Int"/></availHeight>
</a></typedef>
	<typedef path="js.Select" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/js/Dom.hx" module="js.Dom"><a>
	<value><c path="String"/></value>
	<type><c path="String"/></type>
	<title><c path="String"/></title>
	<style><t path="js.Style"/></style>
	<size><c path="Int"/></size>
	<setAttribute set="method"><f a="attr:val">
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></setAttribute>
	<selectedIndex><c path="Int"/></selectedIndex>
	<select set="method"><f a=""><e path="Void"/></f></select>
	<scrollWidth set="null"><c path="Int"/></scrollWidth>
	<scrollTop><c path="Int"/></scrollTop>
	<scrollLeft><c path="Int"/></scrollLeft>
	<scrollHeight set="null"><c path="Int"/></scrollHeight>
	<replaceChild set="method"><f a="child:oldChild">
	<t path="js.HtmlDom"/>
	<t path="js.HtmlDom"/>
	<e path="Void"/>
</f></replaceChild>
	<removeChild set="method"><f a="child">
	<t path="js.HtmlDom"/>
	<t path="js.HtmlDom"/>
</f></removeChild>
	<remove set="method"><f a="o">
	<c path="Int"/>
	<e path="Void"/>
</f></remove>
	<previousSibling><t path="js.HtmlDom"/></previousSibling>
	<parentNode><t path="js.HtmlDom"/></parentNode>
	<options><c path="js.HtmlCollection"><t path="js.Option"/></c></options>
	<onselect><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onselect>
	<onscroll><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onscroll>
	<onresize><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onresize>
	<onmouseup><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmouseup>
	<onmouseover><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmouseover>
	<onmouseout><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmouseout>
	<onmousemove><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmousemove>
	<onmousedown><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmousedown>
	<onkeyup><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onkeyup>
	<onkeypress><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onkeypress>
	<onkeydown><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onkeydown>
	<onfocus><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onfocus>
	<ondblclick><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></ondblclick>
	<onclick><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onclick>
	<onchange><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onchange>
	<onblur><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onblur>
	<offsetWidth><c path="Int"/></offsetWidth>
	<offsetTop><c path="Int"/></offsetTop>
	<offsetParent><t path="js.HtmlDom"/></offsetParent>
	<offsetLeft><c path="Int"/></offsetLeft>
	<offsetHeight><c path="Int"/></offsetHeight>
	<nodeValue><c path="String"/></nodeValue>
	<nodeType><c path="Int"/></nodeType>
	<nodeName><c path="String"/></nodeName>
	<nextSibling><t path="js.HtmlDom"/></nextSibling>
	<name><c path="String"/></name>
	<multiple><e path="Bool"/></multiple>
	<length><c path="Int"/></length>
	<lastChild><t path="js.HtmlDom"/></lastChild>
	<lang><c path="String"/></lang>
	<insertBefore set="method"><f a="newChild:refChild">
	<t path="js.HtmlDom"/>
	<t path="js.HtmlDom"/>
	<e path="Void"/>
</f></insertBefore>
	<innerHTML><c path="String"/></innerHTML>
	<id><c path="String"/></id>
	<hasChildNodes set="method"><f a=""><e path="Bool"/></f></hasChildNodes>
	<getElementsByTagName set="method"><f a="tag">
	<c path="String"/>
	<c path="js.HtmlCollection"><t path="js.HtmlDom"/></c>
</f></getElementsByTagName>
	<getAttribute set="method"><f a="attr">
	<c path="String"/>
	<c path="String"/>
</f></getAttribute>
	<form><t path="js.Form"/></form>
	<focus set="method"><f a=""><e path="Void"/></f></focus>
	<firstChild><t path="js.HtmlDom"/></firstChild>
	<disabled><e path="Bool"/></disabled>
	<dir><c path="String"/></dir>
	<cloneNode set="method"><f a="deep">
	<e path="Bool"/>
	<t path="js.HtmlDom"/>
</f></cloneNode>
	<clientWidth set="null"><c path="Int"/></clientWidth>
	<clientHeight set="null"><c path="Int"/></clientHeight>
	<click set="method"><f a=""><e path="Void"/></f></click>
	<className><c path="String"/></className>
	<childNodes><c path="js.HtmlCollection"><t path="js.HtmlDom"/></c></childNodes>
	<blur set="method"><f a=""><e path="Void"/></f></blur>
	<appendChild set="method"><f a="child">
	<t path="js.HtmlDom"/>
	<e path="Void"/>
</f></appendChild>
</a></typedef>
	<typedef path="js.Style" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/js/Dom.hx" module="js.Dom"><a>
	<zoom><d/></zoom>
	<zIndex><c path="Int"/></zIndex>
	<writingMode><d/></writingMode>
	<wordWrap><d/></wordWrap>
	<wordSpacing><d/></wordSpacing>
	<wordBreak><d/></wordBreak>
	<width><c path="String"/></width>
	<whiteSpace><d/></whiteSpace>
	<visibility><d/></visibility>
	<verticalAlign><d/></verticalAlign>
	<unicodeBidi><d/></unicodeBidi>
	<top><c path="String"/></top>
	<textUnderlinePosition><d/></textUnderlinePosition>
	<textTransform><d/></textTransform>
	<textShadow><d/></textShadow>
	<textOverflow><d/></textOverflow>
	<textKashidaSpace><d/></textKashidaSpace>
	<textJustifyTrim><d/></textJustifyTrim>
	<textJustify><d/></textJustify>
	<textIndent><d/></textIndent>
	<textDecorationLineUnderline><d/></textDecorationLineUnderline>
	<textDecorationLineThrough><d/></textDecorationLineThrough>
	<textDecorationLineOverline><d/></textDecorationLineOverline>
	<textDecorationLineNone><d/></textDecorationLineNone>
	<textDecorationBlink><d/></textDecorationBlink>
	<textDecoration><d/></textDecoration>
	<textAutospace><d/></textAutospace>
	<textAlignLast><d/></textAlignLast>
	<textAlign><d/></textAlign>
	<styleFloat><d/></styleFloat>
	<rubyPosition><d/></rubyPosition>
	<rubyOverhang><d/></rubyOverhang>
	<rubyAlign><d/></rubyAlign>
	<right><c path="String"/></right>
	<quotes><d/></quotes>
	<position><d/></position>
	<paddingTop><d/></paddingTop>
	<paddingRight><d/></paddingRight>
	<paddingLeft><d/></paddingLeft>
	<paddingBottom><d/></paddingBottom>
	<padding><d/></padding>
	<overflowY><d/></overflowY>
	<overflowX><d/></overflowX>
	<overflow><d/></overflow>
	<outlineWidth><d/></outlineWidth>
	<outlineStyle><d/></outlineStyle>
	<outlineColor><d/></outlineColor>
	<outline><d/></outline>
	<minWidth><d/></minWidth>
	<minHeight><d/></minHeight>
	<maxWidth><d/></maxWidth>
	<maxHeight><d/></maxHeight>
	<marks><d/></marks>
	<markerOffset><d/></markerOffset>
	<marginTop><d/></marginTop>
	<marginRight><d/></marginRight>
	<marginLeft><d/></marginLeft>
	<marginBottom><d/></marginBottom>
	<margin><d/></margin>
	<listStyleType><c path="String"/></listStyleType>
	<listStylePosition><d/></listStylePosition>
	<listStyleImage><d/></listStyleImage>
	<listStyle><d/></listStyle>
	<lineHeight><d/></lineHeight>
	<lineBreak><d/></lineBreak>
	<letterSpacing><d/></letterSpacing>
	<left><c path="String"/></left>
	<height><c path="String"/></height>
	<fontWeight><d/></fontWeight>
	<fontVariant><d/></fontVariant>
	<fontStyle><d/></fontStyle>
	<fontStretch><d/></fontStretch>
	<fontSizeAdjust><d/></fontSizeAdjust>
	<fontSize><d/></fontSize>
	<fontFamily><d/></fontFamily>
	<font><d/></font>
	<display><d/></display>
	<direction><d/></direction>
	<cursor><d/></cursor>
	<cssText><d/></cssText>
	<cssFloat><d/></cssFloat>
	<counterReset><d/></counterReset>
	<counterIncrement><d/></counterIncrement>
	<content><d/></content>
	<color><d/></color>
	<clipTop><d/></clipTop>
	<clipRight><d/></clipRight>
	<clipLeft><d/></clipLeft>
	<clipBottom><d/></clipBottom>
	<clip><d/></clip>
	<clear><c path="String"/></clear>
	<bottom><c path="String"/></bottom>
	<borderWidth><d/></borderWidth>
	<borderTopWidth><d/></borderTopWidth>
	<borderTopStyle><d/></borderTopStyle>
	<borderTopColor><d/></borderTopColor>
	<borderTop><d/></borderTop>
	<borderStyle><c path="String"/></borderStyle>
	<borderRightWidth><d/></borderRightWidth>
	<borderRightStyle><d/></borderRightStyle>
	<borderRightColor><d/></borderRightColor>
	<borderRight><d/></borderRight>
	<borderLeftWidth><d/></borderLeftWidth>
	<borderLeftStyle><d/></borderLeftStyle>
	<borderLeftColor><d/></borderLeftColor>
	<borderLeft><d/></borderLeft>
	<borderColor><d/></borderColor>
	<borderBottomWidth><d/></borderBottomWidth>
	<borderBottomStyle><d/></borderBottomStyle>
	<borderBottomColor><d/></borderBottomColor>
	<borderBottom><d/></borderBottom>
	<border><d/></border>
	<backgroundRepeat><d/></backgroundRepeat>
	<backgroundPosition><d/></backgroundPosition>
	<backgroundImage><d/></backgroundImage>
	<backgroundColor><d/></backgroundColor>
	<backgroundAttachment><d/></backgroundAttachment>
	<background><d/></background>
</a></typedef>
	<typedef path="js.StyleSheet" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/js/Dom.hx" module="js.Dom"><a>
	<type><c path="String"/></type>
	<title><c path="String"/></title>
	<href><c path="String"/></href>
	<disabled><e path="Bool"/></disabled>
</a></typedef>
	<typedef path="js.Submit" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/js/Dom.hx" module="js.Dom"><a>
	<value><c path="String"/></value>
	<type><c path="String"/></type>
	<title><c path="String"/></title>
	<style><t path="js.Style"/></style>
	<setAttribute set="method"><f a="attr:val">
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></setAttribute>
	<select set="method"><f a=""><e path="Void"/></f></select>
	<scrollWidth set="null"><c path="Int"/></scrollWidth>
	<scrollTop><c path="Int"/></scrollTop>
	<scrollLeft><c path="Int"/></scrollLeft>
	<scrollHeight set="null"><c path="Int"/></scrollHeight>
	<replaceChild set="method"><f a="child:oldChild">
	<t path="js.HtmlDom"/>
	<t path="js.HtmlDom"/>
	<e path="Void"/>
</f></replaceChild>
	<removeChild set="method"><f a="child">
	<t path="js.HtmlDom"/>
	<t path="js.HtmlDom"/>
</f></removeChild>
	<previousSibling><t path="js.HtmlDom"/></previousSibling>
	<parentNode><t path="js.HtmlDom"/></parentNode>
	<onselectstart><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onselectstart>
	<onselect><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onselect>
	<onscroll><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onscroll>
	<onresize><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onresize>
	<onmouseup><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmouseup>
	<onmouseover><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmouseover>
	<onmouseout><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmouseout>
	<onmousemove><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmousemove>
	<onmousedown><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmousedown>
	<onkeyup><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onkeyup>
	<onkeypress><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onkeypress>
	<onkeydown><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onkeydown>
	<onfocus><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onfocus>
	<ondblclick><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></ondblclick>
	<onclick><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onclick>
	<onchange><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onchange>
	<onblur><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onblur>
	<offsetWidth><c path="Int"/></offsetWidth>
	<offsetTop><c path="Int"/></offsetTop>
	<offsetParent><t path="js.HtmlDom"/></offsetParent>
	<offsetLeft><c path="Int"/></offsetLeft>
	<offsetHeight><c path="Int"/></offsetHeight>
	<nodeValue><c path="String"/></nodeValue>
	<nodeType><c path="Int"/></nodeType>
	<nodeName><c path="String"/></nodeName>
	<nextSibling><t path="js.HtmlDom"/></nextSibling>
	<name><c path="String"/></name>
	<lastChild><t path="js.HtmlDom"/></lastChild>
	<lang><c path="String"/></lang>
	<insertBefore set="method"><f a="newChild:refChild">
	<t path="js.HtmlDom"/>
	<t path="js.HtmlDom"/>
	<e path="Void"/>
</f></insertBefore>
	<innerHTML><c path="String"/></innerHTML>
	<id><c path="String"/></id>
	<hasChildNodes set="method"><f a=""><e path="Bool"/></f></hasChildNodes>
	<getElementsByTagName set="method"><f a="tag">
	<c path="String"/>
	<c path="js.HtmlCollection"><t path="js.HtmlDom"/></c>
</f></getElementsByTagName>
	<getAttribute set="method"><f a="attr">
	<c path="String"/>
	<c path="String"/>
</f></getAttribute>
	<form><t path="js.Form"/></form>
	<focus set="method"><f a=""><e path="Void"/></f></focus>
	<firstChild><t path="js.HtmlDom"/></firstChild>
	<disabled><e path="Bool"/></disabled>
	<dir><c path="String"/></dir>
	<cloneNode set="method"><f a="deep">
	<e path="Bool"/>
	<t path="js.HtmlDom"/>
</f></cloneNode>
	<clientWidth set="null"><c path="Int"/></clientWidth>
	<clientHeight set="null"><c path="Int"/></clientHeight>
	<click set="method"><f a=""><e path="Void"/></f></click>
	<className><c path="String"/></className>
	<childNodes><c path="js.HtmlCollection"><t path="js.HtmlDom"/></c></childNodes>
	<blur set="method"><f a=""><e path="Void"/></f></blur>
	<appendChild set="method"><f a="child">
	<t path="js.HtmlDom"/>
	<e path="Void"/>
</f></appendChild>
</a></typedef>
	<typedef path="js.Text" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/js/Dom.hx" module="js.Dom"><a>
	<value><c path="String"/></value>
	<type><c path="String"/></type>
	<title><c path="String"/></title>
	<style><t path="js.Style"/></style>
	<size><c path="Int"/></size>
	<setAttribute set="method"><f a="attr:val">
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></setAttribute>
	<select set="method"><f a=""><e path="Void"/></f></select>
	<scrollWidth set="null"><c path="Int"/></scrollWidth>
	<scrollTop><c path="Int"/></scrollTop>
	<scrollLeft><c path="Int"/></scrollLeft>
	<scrollHeight set="null"><c path="Int"/></scrollHeight>
	<replaceChild set="method"><f a="child:oldChild">
	<t path="js.HtmlDom"/>
	<t path="js.HtmlDom"/>
	<e path="Void"/>
</f></replaceChild>
	<removeChild set="method"><f a="child">
	<t path="js.HtmlDom"/>
	<t path="js.HtmlDom"/>
</f></removeChild>
	<readOnly><e path="Bool"/></readOnly>
	<previousSibling><t path="js.HtmlDom"/></previousSibling>
	<parentNode><t path="js.HtmlDom"/></parentNode>
	<onselect><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onselect>
	<onscroll><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onscroll>
	<onresize><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onresize>
	<onmouseup><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmouseup>
	<onmouseover><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmouseover>
	<onmouseout><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmouseout>
	<onmousemove><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmousemove>
	<onmousedown><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmousedown>
	<onkeyup><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onkeyup>
	<onkeypress><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onkeypress>
	<onkeydown><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onkeydown>
	<onfocus><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onfocus>
	<ondblclick><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></ondblclick>
	<onclick><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onclick>
	<onchange><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onchange>
	<onblur><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onblur>
	<offsetWidth><c path="Int"/></offsetWidth>
	<offsetTop><c path="Int"/></offsetTop>
	<offsetParent><t path="js.HtmlDom"/></offsetParent>
	<offsetLeft><c path="Int"/></offsetLeft>
	<offsetHeight><c path="Int"/></offsetHeight>
	<nodeValue><c path="String"/></nodeValue>
	<nodeType><c path="Int"/></nodeType>
	<nodeName><c path="String"/></nodeName>
	<nextSibling><t path="js.HtmlDom"/></nextSibling>
	<name><c path="String"/></name>
	<maxLength><c path="Int"/></maxLength>
	<lastChild><t path="js.HtmlDom"/></lastChild>
	<lang><c path="String"/></lang>
	<insertBefore set="method"><f a="newChild:refChild">
	<t path="js.HtmlDom"/>
	<t path="js.HtmlDom"/>
	<e path="Void"/>
</f></insertBefore>
	<innerHTML><c path="String"/></innerHTML>
	<id><c path="String"/></id>
	<hasChildNodes set="method"><f a=""><e path="Bool"/></f></hasChildNodes>
	<getElementsByTagName set="method"><f a="tag">
	<c path="String"/>
	<c path="js.HtmlCollection"><t path="js.HtmlDom"/></c>
</f></getElementsByTagName>
	<getAttribute set="method"><f a="attr">
	<c path="String"/>
	<c path="String"/>
</f></getAttribute>
	<form><t path="js.Form"/></form>
	<focus set="method"><f a=""><e path="Void"/></f></focus>
	<firstChild><t path="js.HtmlDom"/></firstChild>
	<disabled><e path="Bool"/></disabled>
	<dir><c path="String"/></dir>
	<defaultValue><c path="String"/></defaultValue>
	<cloneNode set="method"><f a="deep">
	<e path="Bool"/>
	<t path="js.HtmlDom"/>
</f></cloneNode>
	<clientWidth set="null"><c path="Int"/></clientWidth>
	<clientHeight set="null"><c path="Int"/></clientHeight>
	<click set="method"><f a=""><e path="Void"/></f></click>
	<className><c path="String"/></className>
	<childNodes><c path="js.HtmlCollection"><t path="js.HtmlDom"/></c></childNodes>
	<blur set="method"><f a=""><e path="Void"/></f></blur>
	<appendChild set="method"><f a="child">
	<t path="js.HtmlDom"/>
	<e path="Void"/>
</f></appendChild>
</a></typedef>
	<typedef path="js.Textarea" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/js/Dom.hx" module="js.Dom"><a>
	<value><c path="String"/></value>
	<type><c path="String"/></type>
	<title><c path="String"/></title>
	<style><t path="js.Style"/></style>
	<setAttribute set="method"><f a="attr:val">
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></setAttribute>
	<select set="method"><f a=""><e path="Void"/></f></select>
	<scrollWidth set="null"><c path="Int"/></scrollWidth>
	<scrollTop><c path="Int"/></scrollTop>
	<scrollLeft><c path="Int"/></scrollLeft>
	<scrollHeight set="null"><c path="Int"/></scrollHeight>
	<rows><c path="Int"/></rows>
	<replaceChild set="method"><f a="child:oldChild">
	<t path="js.HtmlDom"/>
	<t path="js.HtmlDom"/>
	<e path="Void"/>
</f></replaceChild>
	<removeChild set="method"><f a="child">
	<t path="js.HtmlDom"/>
	<t path="js.HtmlDom"/>
</f></removeChild>
	<readOnly><e path="Bool"/></readOnly>
	<previousSibling><t path="js.HtmlDom"/></previousSibling>
	<parentNode><t path="js.HtmlDom"/></parentNode>
	<onselect><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onselect>
	<onscroll><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onscroll>
	<onresize><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onresize>
	<onmouseup><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmouseup>
	<onmouseover><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmouseover>
	<onmouseout><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmouseout>
	<onmousemove><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmousemove>
	<onmousedown><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onmousedown>
	<onkeyup><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onkeyup>
	<onkeypress><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onkeypress>
	<onkeydown><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onkeydown>
	<onfocus><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onfocus>
	<ondblclick><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></ondblclick>
	<onclick><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onclick>
	<onchange><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onchange>
	<onblur><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onblur>
	<offsetWidth><c path="Int"/></offsetWidth>
	<offsetTop><c path="Int"/></offsetTop>
	<offsetParent><t path="js.HtmlDom"/></offsetParent>
	<offsetLeft><c path="Int"/></offsetLeft>
	<offsetHeight><c path="Int"/></offsetHeight>
	<nodeValue><c path="String"/></nodeValue>
	<nodeType><c path="Int"/></nodeType>
	<nodeName><c path="String"/></nodeName>
	<nextSibling><t path="js.HtmlDom"/></nextSibling>
	<name><c path="String"/></name>
	<lastChild><t path="js.HtmlDom"/></lastChild>
	<lang><c path="String"/></lang>
	<insertBefore set="method"><f a="newChild:refChild">
	<t path="js.HtmlDom"/>
	<t path="js.HtmlDom"/>
	<e path="Void"/>
</f></insertBefore>
	<innerHTML><c path="String"/></innerHTML>
	<id><c path="String"/></id>
	<hasChildNodes set="method"><f a=""><e path="Bool"/></f></hasChildNodes>
	<getElementsByTagName set="method"><f a="tag">
	<c path="String"/>
	<c path="js.HtmlCollection"><t path="js.HtmlDom"/></c>
</f></getElementsByTagName>
	<getAttribute set="method"><f a="attr">
	<c path="String"/>
	<c path="String"/>
</f></getAttribute>
	<form><t path="js.Form"/></form>
	<focus set="method"><f a=""><e path="Void"/></f></focus>
	<firstChild><t path="js.HtmlDom"/></firstChild>
	<disabled><e path="Bool"/></disabled>
	<dir><c path="String"/></dir>
	<defaultValue><c path="String"/></defaultValue>
	<cols><c path="Int"/></cols>
	<cloneNode set="method"><f a="deep">
	<e path="Bool"/>
	<t path="js.HtmlDom"/>
</f></cloneNode>
	<clientWidth set="null"><c path="Int"/></clientWidth>
	<clientHeight set="null"><c path="Int"/></clientHeight>
	<click set="method"><f a=""><e path="Void"/></f></click>
	<className><c path="String"/></className>
	<childNodes><c path="js.HtmlCollection"><t path="js.HtmlDom"/></c></childNodes>
	<blur set="method"><f a=""><e path="Void"/></f></blur>
	<appendChild set="method"><f a="child">
	<t path="js.HtmlDom"/>
	<e path="Void"/>
</f></appendChild>
</a></typedef>
	<typedef path="js.Window" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/js/Dom.hx" module="js.Dom"><a>
	<top><t path="js.Window"/></top>
	<status><c path="String"/></status>
	<self><t path="js.Window"/></self>
	<scrollTo set="method"><f a="x:y">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></scrollTo>
	<scrollBy set="method"><f a="dx:dy">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></scrollBy>
	<screen><t path="js.Screen"/></screen>
	<prompt set="method"><f a="msg:?def">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
</f></prompt>
	<print set="method"><f a=""><e path="Void"/></f></print>
	<parent><t path="js.Window"/></parent>
	<outerWidth><c path="Int"/></outerWidth>
	<outerHeight><c path="Int"/></outerHeight>
	<opener><t path="js.Window"/></opener>
	<open set="method"><f a="url:?name:?features">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<t path="js.Window"/>
</f></open>
	<onunload><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onunload>
	<onscroll><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onscroll>
	<onresize><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onresize>
	<onload><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onload>
	<onerror><f a="">
	<t path="js.Event"/>
	<e path="Void"/>
</f></onerror>
	<navigator><t path="js.Navigator"/></navigator>
	<name><c path="String"/></name>
	<moveTo set="method"><f a="x:y">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></moveTo>
	<moveBy set="method"><f a="dx:dy">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></moveBy>
	<location><t path="js.Location"/></location>
	<length><c path="Int"/></length>
	<innerWidth><c path="Int"/></innerWidth>
	<innerHeight><c path="Int"/></innerHeight>
	<history><t path="js.History"/></history>
	<frames><c path="js.HtmlCollection"><t path="js.Frame"/></c></frames>
	<focus set="method"><f a=""><e path="Void"/></f></focus>
	<document><t path="js.Document"/></document>
	<defaultStatus><c path="String"/></defaultStatus>
	<confirm set="method"><f a="msg">
	<c path="String"/>
	<e path="Bool"/>
</f></confirm>
	<closed><e path="Bool"/></closed>
	<close set="method"><f a=""><e path="Void"/></f></close>
	<blur set="method"><f a=""><e path="Void"/></f></blur>
	<alert set="method"><f a="msg">
	<c path="String"/>
	<e path="Void"/>
</f></alert>
</a></typedef>
	<class path="haxe.Http" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/haxe/Http.hx">
		<requestUrl public="1" set="method" line="630" static="1"><f a="url">
	<c path="String"/>
	<c path="String"/>
</f></requestUrl>
		<url public="1"><c path="String"/></url>
		<async public="1"><e path="Bool"/></async>
		<postData><c path="String"/></postData>
		<headers><c path="Hash"><c path="String"/></c></headers>
		<params><c path="Hash"><c path="String"/></c></params>
		<setHeader public="1" set="method" line="90"><f a="header:value">
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></setHeader>
		<setParameter public="1" set="method" line="94"><f a="param:value">
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></setParameter>
		<setPostData public="1" set="method" line="99"><f a="data">
	<c path="String"/>
	<e path="Void"/>
</f></setPostData>
		<request public="1" set="method" line="104"><f a="post">
	<e path="Bool"/>
	<e path="Void"/>
</f></request>
		<onData public="1" set="dynamic" line="620"><f a="data">
	<c path="String"/>
	<e path="Void"/>
</f></onData>
		<onError public="1" set="dynamic" line="623"><f a="msg">
	<c path="String"/>
	<e path="Void"/>
</f></onError>
		<onStatus public="1" set="dynamic" line="626"><f a="status">
	<c path="Int"/>
	<e path="Void"/>
</f></onStatus>
		<new public="1" set="method" line="76">
			<f a="url">
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * In PHP Https (SSL) connections are allowed only if the OpenSSL extension is enabled.
	 * @param	url
	 </haxe_doc>
		</new>
	</class>
	<class path="String" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/String.hx" extern="1">
		<fromCharCode public="1" set="method" static="1"><f a="code">
	<c path="Int"/>
	<c path="String"/>
</f></fromCharCode>
		<length public="1" set="null">
			<c path="Int"/>
			<haxe_doc>
		The number of characters in the String.
	</haxe_doc>
		</length>
		<toUpperCase public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns an String where all characters have been uppercased.
	</haxe_doc>
		</toUpperCase>
		<toLowerCase public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns an String where all characters have been lowercased.
	</haxe_doc>
		</toLowerCase>
		<charAt public="1" set="method">
			<f a="index">
				<c path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Returns the character at the given position.
		Returns the empty String if outside of String bounds.
	</haxe_doc>
		</charAt>
		<charCodeAt public="1" set="method">
			<f a="index">
				<c path="Int"/>
				<t path="Null"><c path="Int"/></t>
			</f>
			<haxe_doc>
		Returns the character code at the given position.
		Returns [null] if outside of String bounds.
	</haxe_doc>
		</charCodeAt>
		<indexOf public="1" set="method">
			<f a="str:?startIndex">
				<c path="String"/>
				<c path="Int"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
		Returns the index of first occurence of [value]
		Returns [1-1] if [value] is not found.
		The optional [startIndex] parameter allows you to specify at which character to start searching.
		The position returned is still relative to the beginning of the string.
	</haxe_doc>
		</indexOf>
		<lastIndexOf public="1" set="method">
			<f a="str:?startIndex">
				<c path="String"/>
				<c path="Int"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
		Similar to [indexOf] but returns the latest index.
	</haxe_doc>
		</lastIndexOf>
		<split public="1" set="method">
			<f a="delimiter">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>
		Split the string using the specified delimiter.
	</haxe_doc>
		</split>
		<substr public="1" set="method">
			<f a="pos:?len">
				<c path="Int"/>
				<c path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Returns a part of the String, taking [len] characters starting from [pos].
		If [len] is not specified, it takes all the remaining characters.
	</haxe_doc>
		</substr>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns the String itself.
	</haxe_doc>
		</toString>
		<new public="1" set="method">
			<f a="string">
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Creates a copy from a given String.
	</haxe_doc>
		</new>
		<haxe_doc>
	The basic String class.
</haxe_doc>
	</class>
	<typedef path="cocktailCore.style.ContainerStyle" params="" file="/Users/lexa/Documents/repositories/lexoyo_Cocktail/demo/games/libs/cocktailCore/style/ContainerStyle.hx">
		<c path="cocktailCore.style.js.ContainerStyle"/>
		<haxe_doc>
 * Set the right runtime specific ContainerStyle at compile-time
 </haxe_doc>
	</typedef>
	<typedef path="cocktail.domElement.DOMElement" params="" file="/Users/lexa/Documents/repositories/lexoyo_Cocktail/demo/games/libs/cocktail/domElement/DOMElement.hx">
		<c path="cocktailCore.domElement.js.DOMElement"/>
		<haxe_doc>
 * Set the right runtime specific DOMElement at compile-time
 </haxe_doc>
	</typedef>
	<enum path="Void" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/StdTypes.hx" module="StdTypes"><haxe_doc>
	The standard Void type. Only [null] values can be of the type [Void].
</haxe_doc></enum>
	<class path="Float" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/StdTypes.hx" module="StdTypes" extern="1"><haxe_doc>
	The standard Float type, this is a double-precision IEEE 64bit float.
</haxe_doc></class>
	<class path="Int" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/StdTypes.hx" module="StdTypes" extern="1">
		<extends path="Float"/>
		<haxe_doc>
	The standard Int type. Its precision depends on the platform.
</haxe_doc>
	</class>
	<typedef path="Null" params="T" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/StdTypes.hx" module="StdTypes">
		<c path="Null.T"/>
		<haxe_doc>
	[Null] can be useful in two cases. In order to document some methods
	that accepts or can return a [null] value, or for the Flash9 compiler and AS3
	generator to distinguish between base values that can be null and others that
	can't.
</haxe_doc>
	</typedef>
	<enum path="Bool" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/StdTypes.hx" module="StdTypes">
		<true/>
		<false/>
		<haxe_doc>
	The standard Boolean type is represented as an enum with two choices.
</haxe_doc>
	</enum>
	<class path="Dynamic" params="T" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/StdTypes.hx" module="StdTypes" extern="1"><haxe_doc>
	Dynamic is an internal compiler type which has special behavior.
	See the haXe language reference for more informations.
</haxe_doc></class>
	<typedef path="Iterator" params="T" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/StdTypes.hx" module="StdTypes">
		<a>
			<next set="method"><f a=""><c path="Iterator.T"/></f></next>
			<hasNext set="method"><f a=""><e path="Bool"/></f></hasNext>
		</a>
		<haxe_doc>
	An Iterator is a structure that permits to list a given container
	values. It can be used by your own data structures. See the haXe
	documentation for more informations.
</haxe_doc>
	</typedef>
	<typedef path="Iterable" params="T" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/StdTypes.hx" module="StdTypes">
		<a><iterator set="method"><f a=""><t path="Iterator"><c path="Iterable.T"/></t></f></iterator></a>
		<haxe_doc>
	An Iterable is a data structure which has an iterator() method.
	See [Lambda] for generic functions on iterable structures.
</haxe_doc>
	</typedef>
	<class path="ArrayAccess" params="T" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/StdTypes.hx" module="StdTypes" extern="1" interface="1"><haxe_doc>
	ArrayAccess is used to indicate a class that can be accessed using brackets.
	The type parameter represent the type of the elements stored.
</haxe_doc></class>
	<class path="cocktailCore.style.abstract.AbstractStyle" params="" file="/Users/lexa/Documents/repositories/lexoyo_Cocktail/demo/games/libs/cocktailCore/style/abstract/AbstractStyle.hx">
		<getDefaultStyle set="method" line="411" static="1">
			<f a=""><t path="cocktailCore.style.DefaultStylesData"/></f>
			<haxe_doc>
	 * Return default value for style defined by the User Agent
	 * in a browser, those styles are hard coded for other
	 * runtimes
	 </haxe_doc>
		</getDefaultStyle>
		<_display>
			<e path="cocktail.style.DisplayStyleValue"/>
			<haxe_doc>
	 * display styles
	 </haxe_doc>
		</_display>
		<display public="1" get="getDisplay" set="setDisplay"><e path="cocktail.style.DisplayStyleValue"/></display>
		<_position><e path="cocktail.style.PositionStyleValue"/></_position>
		<position public="1" get="getPosition" set="setPosition"><e path="cocktail.style.PositionStyleValue"/></position>
		<_float><e path="cocktail.style.FloatStyleValue"/></_float>
		<float public="1" get="getFloat" set="setFloat"><e path="cocktail.style.FloatStyleValue"/></float>
		<_clear><e path="cocktail.style.ClearStyleValue"/></_clear>
		<clear public="1" get="getClear" set="setClear"><e path="cocktail.style.ClearStyleValue"/></clear>
		<_opacity><e path="cocktail.style.OpacityStyleValue"/></_opacity>
		<opacity public="1" get="getOpacity" set="setOpacity"><e path="cocktail.style.OpacityStyleValue"/></opacity>
		<_visibility><e path="cocktail.style.VisibilityStyleValue"/></_visibility>
		<visibility public="1" get="getVisibility" set="setVisibility"><e path="cocktail.style.VisibilityStyleValue"/></visibility>
		<_tranformOrigin><t path="cocktail.style.TransformOriginStyleData"/></_tranformOrigin>
		<transformOrigin public="1" get="getTransformOrigin" set="setTransformOrigin"><t path="cocktail.style.TransformOriginStyleData"/></transformOrigin>
		<_transform><e path="cocktail.style.TransformStyleValue"/></_transform>
		<transform public="1" get="getTransform" set="setTransform"><e path="cocktail.style.TransformStyleValue"/></transform>
		<_marginLeft>
			<e path="cocktail.style.MarginStyleValue"/>
			<haxe_doc>
	 * box model styles
	 </haxe_doc>
		</_marginLeft>
		<marginLeft public="1" get="getMarginLeft" set="setMarginLeft"><e path="cocktail.style.MarginStyleValue"/></marginLeft>
		<_marginRight><e path="cocktail.style.MarginStyleValue"/></_marginRight>
		<marginRight public="1" get="getMarginRight" set="setMarginRight"><e path="cocktail.style.MarginStyleValue"/></marginRight>
		<_marginTop><e path="cocktail.style.MarginStyleValue"/></_marginTop>
		<marginTop public="1" get="getMarginTop" set="setMarginTop"><e path="cocktail.style.MarginStyleValue"/></marginTop>
		<_marginBottom><e path="cocktail.style.MarginStyleValue"/></_marginBottom>
		<marginBottom public="1" get="getMarginBottom" set="setMarginBottom"><e path="cocktail.style.MarginStyleValue"/></marginBottom>
		<_paddingLeft><e path="cocktail.style.PaddingStyleValue"/></_paddingLeft>
		<paddingLeft public="1" get="getPaddingLeft" set="setPaddingLeft"><e path="cocktail.style.PaddingStyleValue"/></paddingLeft>
		<_paddingRight><e path="cocktail.style.PaddingStyleValue"/></_paddingRight>
		<paddingRight public="1" get="getPaddingRight" set="setPaddingRight"><e path="cocktail.style.PaddingStyleValue"/></paddingRight>
		<_paddingTop><e path="cocktail.style.PaddingStyleValue"/></_paddingTop>
		<paddingTop public="1" get="getPaddingTop" set="setPaddingTop"><e path="cocktail.style.PaddingStyleValue"/></paddingTop>
		<_paddingBottom><e path="cocktail.style.PaddingStyleValue"/></_paddingBottom>
		<paddingBottom public="1" get="getPaddingBottom" set="setPaddingBottom"><e path="cocktail.style.PaddingStyleValue"/></paddingBottom>
		<_width><e path="cocktail.style.DimensionStyleValue"/></_width>
		<width public="1" get="getWidth" set="setWidth"><e path="cocktail.style.DimensionStyleValue"/></width>
		<_height><e path="cocktail.style.DimensionStyleValue"/></_height>
		<height public="1" get="getHeight" set="setHeight"><e path="cocktail.style.DimensionStyleValue"/></height>
		<_minHeight><e path="cocktail.style.ConstrainedDimensionStyleValue"/></_minHeight>
		<minHeight public="1" get="getMinHeight" set="setMinHeight"><e path="cocktail.style.ConstrainedDimensionStyleValue"/></minHeight>
		<_maxHeight><e path="cocktail.style.ConstrainedDimensionStyleValue"/></_maxHeight>
		<maxHeight public="1" get="getMaxHeight" set="setMaxHeight"><e path="cocktail.style.ConstrainedDimensionStyleValue"/></maxHeight>
		<_minWidth><e path="cocktail.style.ConstrainedDimensionStyleValue"/></_minWidth>
		<minWidth public="1" get="getMinWidth" set="setMinWidth"><e path="cocktail.style.ConstrainedDimensionStyleValue"/></minWidth>
		<_maxWidth><e path="cocktail.style.ConstrainedDimensionStyleValue"/></_maxWidth>
		<maxWidth public="1" get="getMaxWidth" set="setMaxWidth"><e path="cocktail.style.ConstrainedDimensionStyleValue"/></maxWidth>
		<_top><e path="cocktail.style.PositionOffsetStyleValue"/></_top>
		<top public="1" get="getTop" set="setTop"><e path="cocktail.style.PositionOffsetStyleValue"/></top>
		<_left><e path="cocktail.style.PositionOffsetStyleValue"/></_left>
		<left public="1" get="getLeft" set="setLeft"><e path="cocktail.style.PositionOffsetStyleValue"/></left>
		<_bottom><e path="cocktail.style.PositionOffsetStyleValue"/></_bottom>
		<bottom public="1" get="getBottom" set="setBottom"><e path="cocktail.style.PositionOffsetStyleValue"/></bottom>
		<_right><e path="cocktail.style.PositionOffsetStyleValue"/></_right>
		<right public="1" get="getRight" set="setRight"><e path="cocktail.style.PositionOffsetStyleValue"/></right>
		<_fontSize>
			<e path="cocktail.style.FontSizeStyleValue"/>
			<haxe_doc>
	 * font styles
	 </haxe_doc>
		</_fontSize>
		<fontSize public="1" get="getFontSize" set="setFontSize"><e path="cocktail.style.FontSizeStyleValue"/></fontSize>
		<_fontWeight><e path="cocktail.style.FontWeightStyleValue"/></_fontWeight>
		<fontWeight public="1" get="getFontWeight" set="setFontWeight"><e path="cocktail.style.FontWeightStyleValue"/></fontWeight>
		<_fontStyle><e path="cocktail.style.FontStyleStyleValue"/></_fontStyle>
		<fontStyle public="1" get="getFontStyle" set="setFontStyle"><e path="cocktail.style.FontStyleStyleValue"/></fontStyle>
		<_fontFamily><c path="Array"><e path="cocktail.style.FontFamilyStyleValue"/></c></_fontFamily>
		<fontFamily public="1" get="getFontFamily" set="setFontFamily"><c path="Array"><e path="cocktail.style.FontFamilyStyleValue"/></c></fontFamily>
		<_fontVariant><e path="cocktail.style.FontVariantStyleValue"/></_fontVariant>
		<fontVariant public="1" get="getFontVariant" set="setFontVariant"><e path="cocktail.style.FontVariantStyleValue"/></fontVariant>
		<_color><e path="cocktail.unit.ColorValue"/></_color>
		<color public="1" get="getColor" set="setColor"><e path="cocktail.unit.ColorValue"/></color>
		<_lineHeight>
			<e path="cocktail.style.LineHeightStyleValue"/>
			<haxe_doc>
	 * text styles
	 </haxe_doc>
		</_lineHeight>
		<lineHeight public="1" get="getLineHeight" set="setLineHeight"><e path="cocktail.style.LineHeightStyleValue"/></lineHeight>
		<_textTransform><e path="cocktail.style.TextTransformStyleValue"/></_textTransform>
		<textTransform public="1" get="getTextTransform" set="setTextTransform"><e path="cocktail.style.TextTransformStyleValue"/></textTransform>
		<_letterSpacing><e path="cocktail.style.LetterSpacingStyleValue"/></_letterSpacing>
		<letterSpacing public="1" get="getLetterSpacing" set="setLetterSpacing"><e path="cocktail.style.LetterSpacingStyleValue"/></letterSpacing>
		<_wordSpacing><e path="cocktail.style.WordSpacingStyleValue"/></_wordSpacing>
		<wordSpacing public="1" get="getWordSpacing" set="setWordSpacing"><e path="cocktail.style.WordSpacingStyleValue"/></wordSpacing>
		<_whiteSpace><e path="cocktail.style.WhiteSpaceStyleValue"/></_whiteSpace>
		<whiteSpace public="1" get="getWhiteSpace" set="setWhiteSpace"><e path="cocktail.style.WhiteSpaceStyleValue"/></whiteSpace>
		<_textAlign><e path="cocktail.style.TextAlignStyleValue"/></_textAlign>
		<textAlign public="1" get="getTextAlign" set="setTextAlign"><e path="cocktail.style.TextAlignStyleValue"/></textAlign>
		<_textIndent><e path="cocktail.style.TextIndentStyleValue"/></_textIndent>
		<textIndent public="1" get="getTextIndent" set="setTextIndent"><e path="cocktail.style.TextIndentStyleValue"/></textIndent>
		<_verticalAlign><e path="cocktail.style.VerticalAlignStyleValue"/></_verticalAlign>
		<verticalAlign public="1" get="getVerticalAlign" set="setVerticalAlign"><e path="cocktail.style.VerticalAlignStyleValue"/></verticalAlign>
		<_computedStyle>
			<t path="cocktailCore.style.ComputedStyleData"/>
			<haxe_doc>
	 * Stores all of the value of styles once computed.
	 * For example, if a size is set as a percentage, it will
	 * be stored once computed to pixels into this structure
	 </haxe_doc>
		</_computedStyle>
		<computedStyle public="1" get="getComputedStyle" set="setComputedStyle"><t path="cocktailCore.style.ComputedStyleData"/></computedStyle>
		<_domElement>
			<t path="cocktail.domElement.DOMElement"/>
			<haxe_doc>
	 * A reference to the DOMElement to which these styles
	 * apply
	 </haxe_doc>
		</_domElement>
		<domElement public="1" get="getDOMElement" set="null"><t path="cocktail.domElement.DOMElement"/></domElement>
		<_fontMetrics>
			<t path="cocktailCore.style.FontMetricsData"/>
			<haxe_doc>
	 * Returns metrics info for the currently defined
	 * font and font size. Uused in inline formatting context
	 * to determine lineBoxes sizes and text vertical
	 * alignement
	 </haxe_doc>
		</_fontMetrics>
		<fontMetrics public="1" get="getFontMetricsData" set="null"><t path="cocktailCore.style.FontMetricsData"/></fontMetrics>
		<_isInvalid>
			<e path="Bool"/>
			<haxe_doc>
	 * determine wether the DOMElement and its chidlren must
	 * be laid out again
	 </haxe_doc>
		</_isInvalid>
		<_nativeX>
			<c path="Int"/>
			<haxe_doc>
	 * Store the x position of the NativeElement
	 * relative to its parent
	 </haxe_doc>
		</_nativeX>
		<_nativeY>
			<c path="Int"/>
			<haxe_doc>
	 * Store the y position of the NativeElement
	 * relative to its parent
	 </haxe_doc>
		</_nativeY>
		<_nativeWidth>
			<c path="Int"/>
			<haxe_doc>
	 * Store the width of the NativeElement
	 </haxe_doc>
		</_nativeWidth>
		<_nativeHeight>
			<c path="Int"/>
			<haxe_doc>
	 * Store the height of the NativeElement
	 </haxe_doc>
		</_nativeHeight>
		<_nativeScaleX>
			<c path="Float"/>
			<haxe_doc>
	 * Store the x scale of the NativeElement
	 </haxe_doc>
		</_nativeScaleX>
		<_nativeScaleY>
			<c path="Float"/>
			<haxe_doc>
	 * Store the y scale of the NativeElement
	 </haxe_doc>
		</_nativeScaleY>
		<_nativeRotation>
			<c path="Float"/>
			<haxe_doc>
	 * Store the rotation of the NativeElement
	 </haxe_doc>
		</_nativeRotation>
		<_nativeOpacity>
			<c path="Float"/>
			<haxe_doc>
	 * Store the opacity of the NativeElement
	 </haxe_doc>
		</_nativeOpacity>
		<_nativeVisibility>
			<e path="Bool"/>
			<haxe_doc>
	 * Store the visibility of the NativeElement
	 </haxe_doc>
		</_nativeVisibility>
		<_nativeMatrix>
			<c path="cocktail.geom.Matrix"/>
			<haxe_doc>
	 * Store the current transform matrix of the NativeElement
	 </haxe_doc>
		</_nativeMatrix>
		<initDefaultStyleValues set="method" line="277">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * Init the standard default value for styles
	 </haxe_doc>
		</initDefaultStyleValues>
		<initComputedStyles set="method" line="344">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * reset/init the computed style structures
	 </haxe_doc>
		</initComputedStyles>
		<initNativeProperties set="method" line="393">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * init the values representing NativeElements attributes
	 </haxe_doc>
		</initNativeProperties>
		<layout public="1" set="method" line="437">
			<f a="containingDOMElementData:lastPositionedDOMElementData:viewportData:containingDOMElementFontMetricsData">
				<t path="cocktailCore.style.ContainingDOMElementData"/>
				<t path="cocktailCore.style.LastPositionedDOMElementData"/>
				<t path="cocktailCore.style.ContainingDOMElementData"/>
				<t path="cocktailCore.style.FontMetricsData"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * The main layout method. When called, the DOMElement's styles (width, height, margins, paddings...)
	 * are computed, the DOMElement layout its children if it has any then add himself
	 * to the layout.
	 * 
	 * @param	containingDOMElementData the dimensions of the parent DOMElement into which 
	 * this DOMElement must be layout
	 * @param	lastPositionedDOMElementData the dimensions of the first ancestor DOMElement in the hierararchy which is 'positioned', meaning that
	 * it has a 'position' style other than 'static'. When positioning an absolutelty positioned DOMElement (a DOMElement with a 'position' style
	 * of 'absolute'), it it used as origin.
	 * @param	viewportData a reference to the viewport of the document. When positioning a fixed positioned DOMElement
	 * (a DOMElement with a 'position' of 'fixed'), it is used as origin
	 * @param containingDOMElementFontMetricsData contains font metrics used to layout children in an inline formatting context
	 </haxe_doc>
		</layout>
		<flow public="1" set="method" line="464">
			<f a="containingDOMElementData:viewportData:lastPositionedDOMElementData:containingDOMElementFontMetricsData:?formatingContext">
				<t path="cocktailCore.style.ContainingDOMElementData"/>
				<t path="cocktailCore.style.ContainingDOMElementData"/>
				<t path="cocktailCore.style.LastPositionedDOMElementData"/>
				<t path="cocktailCore.style.FontMetricsData"/>
				<c path="cocktailCore.style.formatter.FormattingContext"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * This method is in charge of placing "in-flow" DOMElements (DOMElement with a 'position' style of 'static' or 'relative') into
	 * its parent flow and "positioned" DOMElement (with a 'position' style of 'absolute' or 'fixed') relatively to its first positioned
	 * ancestor.
	 * 
	 * The DOMElement first compute its own styles (box model, font, text...), then insert itself into the document based 
	 * on its positioning scheme.
	 * 
	 * This method is called recursively on every children of the DOMElement if it has any
	 * 
	 * @param	containingDOMElementData the dimensions of the parent DOMElement into which 
	 * this DOMElement must be laid out
	 * @param	viewportData a reference to the viewport of the document. When positioning a fixed positioned DOMElement
	 * (a DOMElement with a 'position' of 'fixed'), it is used as origin
	 * @param	lastPositionedDOMElementData the dimensions of the first ancestor DOMElement in the hierararchy which is 'positioned', meaning that
	 * it has a 'position' other than 'static'. When laying out an absolutelty positioned DOMElement ( a DOMElement with a 'position' style
	 * of 'absolute'), it it used as origin. It also contains a reference to each absolutely positioned AbstractStyle using it as origin
	 * to position their DOMElement
	 * @param   containingDOMElementFontMetricsData contains font metrics used to layout children in an inline formatting context
	 * @param	formatingContext can be an inline or block formatting context. "In-flow" DOMElements insert themselves into the 
	 * formatingContext to be placed in the document flow
	 </haxe_doc>
		</flow>
		<positionElement public="1" set="method" line="513">
			<f a="lastPositionedDOMElementData:viewportData:staticPosition">
				<t path="cocktailCore.style.ContainingDOMElementData"/>
				<t path="cocktailCore.style.ContainingDOMElementData"/>
				<t path="cocktail.geom.PointData"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Place a positioned DOMElement (with a position of 'relative', 'absolute', or 'fixed') using either the normal
	 * flow, the last positioned DOMElement or the viewport of the document, then apply an offset defined by the 'top',
	 * 'left', 'bottom' and 'right' computed styles values
	 </haxe_doc>
		</positionElement>
		<scheduleLayout set="method" line="554">
			<f a="containingDOMElementData:lastPositionedDOMElementData:viewportData">
				<t path="cocktailCore.style.ContainingDOMElementData"/>
				<t path="cocktailCore.style.LastPositionedDOMElementData"/>
				<t path="cocktailCore.style.ContainingDOMElementData"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Set a timer to trigger a layout of the DOMElement asynchronously. this method is used by the invalidation
	 * mechanism. Setting a timer to execute the layout ensure that the layout only happen once when a series of style
	 * value are set instead of happening for each changes.
	 </haxe_doc>
		</scheduleLayout>
		<flowChildren set="method" line="566">
			<f a="containingDOMElementData:viewportData:lastPositionedDOMElementData:containingDOMElementFontMetricsData:?formatingContext">
				<t path="cocktailCore.style.ContainingDOMElementData"/>
				<t path="cocktailCore.style.ContainingDOMElementData"/>
				<t path="cocktailCore.style.LastPositionedDOMElementData"/>
				<t path="cocktailCore.style.FontMetricsData"/>
				<c path="cocktailCore.style.formatter.FormattingContext"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Flow all the children of a DOMElement if it has any, then insert the DOMElement.
	 </haxe_doc>
		</flowChildren>
		<insertDOMElement set="method" line="580">
			<f a="formattingContext:lastPositionedDOMElementData:viewportData">
				<c path="cocktailCore.style.formatter.FormattingContext"/>
				<t path="cocktailCore.style.LastPositionedDOMElementData"/>
				<t path="cocktailCore.style.ContainingDOMElementData"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Insert the DOMElement in the document, in or out of the flow.
	 * Might clear preceding floats
	 * 
	 * @param	formatingContext
	 * @param	lastPositionedDOMElementData
	 * @param	viewportData
	 </haxe_doc>
		</insertDOMElement>
		<insertInFlowDOMElement set="method" line="636">
			<f a="formattingContext">
				<c path="cocktailCore.style.formatter.FormattingContext"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Do insert an inflow DOMElement into the document. Method added to allow
	 * overriding for some inherithing class
	 </haxe_doc>
		</insertInFlowDOMElement>
		<invalidate public="1" set="method" line="655">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * Called when the value of a style that require
	 * a layout (such as width, height, display...) is
	 * changed.
	 * 
	 * An invalidated DOMElement will in turn invalidate its
	 * parent and so on until the root DOMElement is invalidated.
	 * The root DOMElement will then layout itself, laying out
	 * at the same time all its invalidated children.
	 </haxe_doc>
		</invalidate>
		<invalidateText set="method" line="712">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * When a style invalidating the text is called
	 * (font size, font weight...), the font metrics
	 * structure must be reseted so that it is re-created
	 * with updated values on next layout
	 </haxe_doc>
		</invalidateText>
		<invalidatePositionOffset set="method" line="723">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * When a position offset style changes (top, left, 
	 * right, bottom), it only requires a layout if the
	 * DOMElement is positioned (not static).
	 </haxe_doc>
		</invalidatePositionOffset>
		<invalidateMargin set="method" line="735">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * When the margin style changes, if the DOMElement
	 * is absolutely positioned, there is no need for a layout
	 </haxe_doc>
		</invalidateMargin>
		<isParentInvalid set="method" line="749">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>
	 * Determine wheter the parent of the DOMElement needs
	 * to be invalidated too. In some caes, for instance
	 * if the DOMElement is absolutely positioned, invalidating
	 * its parent isn't necessary
	 </haxe_doc>
		</isParentInvalid>
		<computeDOMElement public="1" set="method" line="773">
			<f a="containingDOMElementData:viewportData:lastPositionedDOMElementData:containingDOMElementFontMetricsData">
				<t path="cocktailCore.style.ContainingDOMElementData"/>
				<t path="cocktailCore.style.ContainingDOMElementData"/>
				<t path="cocktailCore.style.ContainingDOMElementData"/>
				<t path="cocktailCore.style.FontMetricsData"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Compute first the styles determining the DOMElement's
	 * positioning scheme (position, float, clear...),
	 * the styles determining its box model (width, height, margins
	 * paddings...), and the styles styling the DOMElement text and
	 * font style
	 </haxe_doc>
		</computeDOMElement>
		<computeDisplayStyles public="1" set="method" line="791">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * This method computes the styles determing
	 * the DOMElement's layout scheme :
	 * position, display, float and clear
	 </haxe_doc>
		</computeDisplayStyles>
		<computeVisualEffectStyles set="method" line="804">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * Compute the visual effect styles (opacity, visibility, transformations)
	 </haxe_doc>
		</computeVisualEffectStyles>
		<computeTextAndFontStyles set="method" line="812">
			<f a="containingDOMElementData:containingDOMElementFontMetricsData">
				<t path="cocktailCore.style.ContainingDOMElementData"/>
				<t path="cocktailCore.style.FontMetricsData"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Computes the DOMElement font and text styles (font size, font name, text color...)
	 </haxe_doc>
		</computeTextAndFontStyles>
		<computeBoxModelStyles set="method" line="821">
			<f a="containingDOMElementData:viewportData:lastPositionedDOMElementData">
				<t path="cocktailCore.style.ContainingDOMElementData"/>
				<t path="cocktailCore.style.ContainingDOMElementData"/>
				<t path="cocktailCore.style.ContainingDOMElementData"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Compute the box model styles (width, height, paddings, margins...) of the DOMElement, based on
	 * its positioning scheme
	 </haxe_doc>
		</computeBoxModelStyles>
		<getBoxStylesComputer set="method" line="839">
			<f a=""><c path="cocktailCore.style.computer.BoxStylesComputer"/></f>
			<haxe_doc>
	 * instantiate the right box computer class
	 *	based on the DOMElement's positioning
	 *	scheme
	 </haxe_doc>
		</getBoxStylesComputer>
		<getContainingDOMElementData set="method" line="881">
			<f a="containingDOMElementData:viewportData:lastPositionedDOMElementData">
				<t path="cocktailCore.style.ContainingDOMElementData"/>
				<t path="cocktailCore.style.ContainingDOMElementData"/>
				<t path="cocktailCore.style.ContainingDOMElementData"/>
				<t path="cocktailCore.style.ContainingDOMElementData"/>
			</f>
			<haxe_doc>
	 * Get the right containing parent dimensions for a DOMElement
	 * based on its position style value
	 </haxe_doc>
		</getContainingDOMElementData>
		<isEmbedded public="1" set="method" line="937">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>
	 * Determine if the DOMElement is an embeded (replaced)
	 * DOMElement. For example an ImageDOMElement is an
	 * embedded DOMElement as it embeds a picture in the
	 * document
	 </haxe_doc>
		</isEmbedded>
		<isFloat public="1" set="method" line="955">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>
	 * Determine if the DOMElement is a floated
	 * DOMElement. A floated DOMElement is first
	 * placed in the flow then moved to the
	 * left-most or right-most of its container.
	 * Any subsequent DOMElement flows
	 * around on the float until a new line 
	 * starts below the float or if it is cleared
	 * by another DOMElement.
	 * 
	 * A DOMElement is float if he declares either
	 * a left or right float
	 </haxe_doc>
		</isFloat>
		<isPositioned public="1" set="method" line="990">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>
	 * A positioned element is one that 
	 * is positioned outside of the normal
	 * flow.
	 * 
	 * The 'relative', 'absolute' and'fixed'
	 * values of the 'position' style makes
	 * a DOMElement 'positioned'. 
	 * 
	 * The 'absolute' and 'fixed' value make
	 * a DOMElement an 'absolutely positioned'
	 * DOMElement. This kind of DOMElement
	 * doesn't affect the normal flow (it is
	 * treated as if it doesn't exist). It
	 * uses as origin its first ancestor
	 * which is also positioned
	 * 
	 * See below for the 'relative' value
	 </haxe_doc>
		</isPositioned>
		<isClear set="method" line="1018">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>
	 * Determine wether the DOMElement introduces
	 * 'clearance', which as the effect of placing
	 * the DOMElement below any preceding floated
	 * DOMElement. A DOMElement introduces clearance
	 * if he clears either left floats, right floats
	 * or both
	 </haxe_doc>
		</isClear>
		<isNotDisplayed set="method" line="1038">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>
	 * Determine wether the DOMElement is added
	 * to the document
	 </haxe_doc>
		</isNotDisplayed>
		<isInline set="method" line="1053">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>
	 * An inline DOMElement is one that is
	 * laid out on a line. It will be placed
	 * either next to the preceding DOMElement
	 * or on a new line if the current line
	 * is too short to host it.
	 * 
	 * Wheter an element is inline is determined
	 * by the display style
	 </haxe_doc>
		</isInline>
		<isRelativePositioned set="method" line="1083">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>
	 * Determine wether a DOMElement has
	 * the 'position' value 'relative'.
	 * 
	 * A 'relative' DOMElement is first placed
	 * normally in the flow then an offset is 
	 * applied to it with the top, left, right
	 * and bottom computed styles.
	 * 
	 * It is used as origin for any 'absolute'
	 * or 'fixed' positioned children and 
	 * grand-children until another positioned
	 * DOMElement is found
	 </haxe_doc>
		</isRelativePositioned>
		<getFirstPositionedAncestorData set="method" line="1092">
			<f a=""><t path="cocktailCore.style.ContainingDOMElementData"/></f>
			<haxe_doc>
	 * Get the data (dimensions and positions) of the first ancestor
	 * of the styled DOMElement which is positioned
	 </haxe_doc>
		</getFirstPositionedAncestorData>
		<getViewportData set="method" line="1133">
			<f a=""><t path="cocktailCore.style.ContainingDOMElementData"/></f>
			<haxe_doc>
	 * Retrieve the data of the viewport. The viewport
	 * position is always to the top left of the window
	 </haxe_doc>
		</getViewportData>
		<setNativeX public="1" set="method" line="1165">
			<f a="domElement:x">
				<t path="cocktail.domElement.DOMElement"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Set the x of the NativeElement of the
	 * target DOMElement
	 </haxe_doc>
		</setNativeX>
		<getNativeX public="1" set="method" line="1177">
			<f a=""><c path="Int"/></f>
			<haxe_doc>
	 * Return the x of the NativeElement of the
	 * DOMElement
	 </haxe_doc>
		</getNativeX>
		<setNativeY public="1" set="method" line="1186">
			<f a="domElement:y">
				<t path="cocktail.domElement.DOMElement"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Set the y of the NativeElement of the
	 * target DOMElement
	 </haxe_doc>
		</setNativeY>
		<getNativeY public="1" set="method" line="1198">
			<f a=""><c path="Int"/></f>
			<haxe_doc>
	 * Return the y of the NativeElement of the
	 * DOMElement
	 </haxe_doc>
		</getNativeY>
		<setNativeWidth public="1" set="method" line="1207">
			<f a="width">
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Set the width of the NativeElement of the
	 * target DOMElement
	 </haxe_doc>
		</setNativeWidth>
		<getNativeWidth public="1" set="method" line="1216">
			<f a=""><c path="Int"/></f>
			<haxe_doc>
	 * Return the width of the NativeElement of the
	 * DOMElement
	 </haxe_doc>
		</getNativeWidth>
		<setNativeHeight public="1" set="method" line="1225">
			<f a="height">
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Set the height of the NativeElement of the
	 * target DOMElement
	 </haxe_doc>
		</setNativeHeight>
		<getNativeHeight public="1" set="method" line="1234">
			<f a=""><c path="Int"/></f>
			<haxe_doc>
	 * Return the height of the NativeElement of the
	 * DOMElement
	 </haxe_doc>
		</getNativeHeight>
		<setNativeScaleX public="1" set="method" line="1242">
			<f a="scaleX">
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Set the x scale of the NativeElement
	 </haxe_doc>
		</setNativeScaleX>
		<getNativeScaleX public="1" set="method" line="1250">
			<f a=""><c path="Float"/></f>
			<haxe_doc>
	 * return the x scale of the NativeElement
	 </haxe_doc>
		</getNativeScaleX>
		<setNativeScaleY public="1" set="method" line="1258">
			<f a="scaleY">
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Set the y scale of the NativeElement
	 </haxe_doc>
		</setNativeScaleY>
		<getNativeScaleY public="1" set="method" line="1266">
			<f a=""><c path="Float"/></f>
			<haxe_doc>
	 * return the y scale of the NativeElement
	 </haxe_doc>
		</getNativeScaleY>
		<setNativeRotation public="1" set="method" line="1274">
			<f a="rotation">
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Set the rotation of the NativeElement in rad
	 </haxe_doc>
		</setNativeRotation>
		<getNativeRotation public="1" set="method" line="1282">
			<f a=""><c path="Float"/></f>
			<haxe_doc>
	 * return the rotation of the NativeElement in rad
	 </haxe_doc>
		</getNativeRotation>
		<setNativeMatrix public="1" set="method" line="1291">
			<f a="matrix">
				<c path="cocktail.geom.Matrix"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Set the transformation matrix on the DOMElement. Overriden
	 * to apply it to the NativeElement
	 </haxe_doc>
		</setNativeMatrix>
		<getNativeMatrix public="1" set="method" line="1299">
			<f a=""><c path="cocktail.geom.Matrix"/></f>
			<haxe_doc>
	 * Get the matrix of the DOMElement
	 </haxe_doc>
		</getNativeMatrix>
		<setNativeOpacity public="1" set="method" line="1307">
			<f a="opacity">
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Set the alpha of the NativeElement
	 </haxe_doc>
		</setNativeOpacity>
		<getNativeOpacity public="1" set="method" line="1315">
			<f a=""><c path="Float"/></f>
			<haxe_doc>
	 * Get the alpha of the NativeElement
	 </haxe_doc>
		</getNativeOpacity>
		<setNativeVisibility public="1" set="method" line="1323">
			<f a="visible">
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Set the visibility of the NativeElement
	 </haxe_doc>
		</setNativeVisibility>
		<getNativeVisibility public="1" set="method" line="1331">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>
	 * Get the visibility of the NativeElement
	 </haxe_doc>
		</getNativeVisibility>
		<getFontMetricsData set="method" line="1340"><f a=""><t path="cocktailCore.style.FontMetricsData"/></f></getFontMetricsData>
		<getComputedStyle set="method" line="1345"><f a=""><t path="cocktailCore.style.ComputedStyleData"/></f></getComputedStyle>
		<setComputedStyle set="method" line="1350"><f a="value">
	<t path="cocktailCore.style.ComputedStyleData"/>
	<t path="cocktailCore.style.ComputedStyleData"/>
</f></setComputedStyle>
		<getDOMElement set="method" line="1355"><f a=""><t path="cocktail.domElement.DOMElement"/></f></getDOMElement>
		<setWidth set="method" line="1366"><f a="value">
	<e path="cocktail.style.DimensionStyleValue"/>
	<e path="cocktail.style.DimensionStyleValue"/>
</f></setWidth>
		<setMarginLeft set="method" line="1372"><f a="value">
	<e path="cocktail.style.MarginStyleValue"/>
	<e path="cocktail.style.MarginStyleValue"/>
</f></setMarginLeft>
		<setMarginRight set="method" line="1378"><f a="value">
	<e path="cocktail.style.MarginStyleValue"/>
	<e path="cocktail.style.MarginStyleValue"/>
</f></setMarginRight>
		<setMarginTop set="method" line="1384"><f a="value">
	<e path="cocktail.style.MarginStyleValue"/>
	<e path="cocktail.style.MarginStyleValue"/>
</f></setMarginTop>
		<setMarginBottom set="method" line="1390"><f a="value">
	<e path="cocktail.style.MarginStyleValue"/>
	<e path="cocktail.style.MarginStyleValue"/>
</f></setMarginBottom>
		<setPaddingLeft set="method" line="1396"><f a="value">
	<e path="cocktail.style.PaddingStyleValue"/>
	<e path="cocktail.style.PaddingStyleValue"/>
</f></setPaddingLeft>
		<setPaddingRight set="method" line="1402"><f a="value">
	<e path="cocktail.style.PaddingStyleValue"/>
	<e path="cocktail.style.PaddingStyleValue"/>
</f></setPaddingRight>
		<setPaddingTop set="method" line="1408"><f a="value">
	<e path="cocktail.style.PaddingStyleValue"/>
	<e path="cocktail.style.PaddingStyleValue"/>
</f></setPaddingTop>
		<setPaddingBottom set="method" line="1414"><f a="value">
	<e path="cocktail.style.PaddingStyleValue"/>
	<e path="cocktail.style.PaddingStyleValue"/>
</f></setPaddingBottom>
		<setDisplay set="method" line="1420"><f a="value">
	<e path="cocktail.style.DisplayStyleValue"/>
	<e path="cocktail.style.DisplayStyleValue"/>
</f></setDisplay>
		<setPosition set="method" line="1426"><f a="value">
	<e path="cocktail.style.PositionStyleValue"/>
	<e path="cocktail.style.PositionStyleValue"/>
</f></setPosition>
		<setHeight set="method" line="1432"><f a="value">
	<e path="cocktail.style.DimensionStyleValue"/>
	<e path="cocktail.style.DimensionStyleValue"/>
</f></setHeight>
		<setMinHeight set="method" line="1438"><f a="value">
	<e path="cocktail.style.ConstrainedDimensionStyleValue"/>
	<e path="cocktail.style.ConstrainedDimensionStyleValue"/>
</f></setMinHeight>
		<setMaxHeight set="method" line="1444"><f a="value">
	<e path="cocktail.style.ConstrainedDimensionStyleValue"/>
	<e path="cocktail.style.ConstrainedDimensionStyleValue"/>
</f></setMaxHeight>
		<setMinWidth set="method" line="1450"><f a="value">
	<e path="cocktail.style.ConstrainedDimensionStyleValue"/>
	<e path="cocktail.style.ConstrainedDimensionStyleValue"/>
</f></setMinWidth>
		<setMaxWidth set="method" line="1456"><f a="value">
	<e path="cocktail.style.ConstrainedDimensionStyleValue"/>
	<e path="cocktail.style.ConstrainedDimensionStyleValue"/>
</f></setMaxWidth>
		<setTop set="method" line="1462"><f a="value">
	<e path="cocktail.style.PositionOffsetStyleValue"/>
	<e path="cocktail.style.PositionOffsetStyleValue"/>
</f></setTop>
		<setLeft set="method" line="1468"><f a="value">
	<e path="cocktail.style.PositionOffsetStyleValue"/>
	<e path="cocktail.style.PositionOffsetStyleValue"/>
</f></setLeft>
		<setBottom set="method" line="1474"><f a="value">
	<e path="cocktail.style.PositionOffsetStyleValue"/>
	<e path="cocktail.style.PositionOffsetStyleValue"/>
</f></setBottom>
		<setRight set="method" line="1480"><f a="value">
	<e path="cocktail.style.PositionOffsetStyleValue"/>
	<e path="cocktail.style.PositionOffsetStyleValue"/>
</f></setRight>
		<setFloat set="method" line="1486"><f a="value">
	<e path="cocktail.style.FloatStyleValue"/>
	<e path="cocktail.style.FloatStyleValue"/>
</f></setFloat>
		<setClear set="method" line="1492"><f a="value">
	<e path="cocktail.style.ClearStyleValue"/>
	<e path="cocktail.style.ClearStyleValue"/>
</f></setClear>
		<setFontSize set="method" line="1498"><f a="value">
	<e path="cocktail.style.FontSizeStyleValue"/>
	<e path="cocktail.style.FontSizeStyleValue"/>
</f></setFontSize>
		<setFontWeight set="method" line="1504"><f a="value">
	<e path="cocktail.style.FontWeightStyleValue"/>
	<e path="cocktail.style.FontWeightStyleValue"/>
</f></setFontWeight>
		<setFontStyle set="method" line="1510"><f a="value">
	<e path="cocktail.style.FontStyleStyleValue"/>
	<e path="cocktail.style.FontStyleStyleValue"/>
</f></setFontStyle>
		<setFontFamily set="method" line="1516"><f a="value">
	<c path="Array"><e path="cocktail.style.FontFamilyStyleValue"/></c>
	<c path="Array"><e path="cocktail.style.FontFamilyStyleValue"/></c>
</f></setFontFamily>
		<setFontVariant set="method" line="1522"><f a="value">
	<e path="cocktail.style.FontVariantStyleValue"/>
	<e path="cocktail.style.FontVariantStyleValue"/>
</f></setFontVariant>
		<setTextTransform set="method" line="1528"><f a="value">
	<e path="cocktail.style.TextTransformStyleValue"/>
	<e path="cocktail.style.TextTransformStyleValue"/>
</f></setTextTransform>
		<setLetterSpacing set="method" line="1534"><f a="value">
	<e path="cocktail.style.LetterSpacingStyleValue"/>
	<e path="cocktail.style.LetterSpacingStyleValue"/>
</f></setLetterSpacing>
		<setWordSpacing set="method" line="1540"><f a="value">
	<e path="cocktail.style.WordSpacingStyleValue"/>
	<e path="cocktail.style.WordSpacingStyleValue"/>
</f></setWordSpacing>
		<setLineHeight set="method" line="1546"><f a="value">
	<e path="cocktail.style.LineHeightStyleValue"/>
	<e path="cocktail.style.LineHeightStyleValue"/>
</f></setLineHeight>
		<setColor set="method" line="1552"><f a="value">
	<e path="cocktail.unit.ColorValue"/>
	<e path="cocktail.unit.ColorValue"/>
</f></setColor>
		<setVerticalAlign set="method" line="1558"><f a="value">
	<e path="cocktail.style.VerticalAlignStyleValue"/>
	<e path="cocktail.style.VerticalAlignStyleValue"/>
</f></setVerticalAlign>
		<setTextIndent set="method" line="1564"><f a="value">
	<e path="cocktail.style.TextIndentStyleValue"/>
	<e path="cocktail.style.TextIndentStyleValue"/>
</f></setTextIndent>
		<setWhiteSpace set="method" line="1570"><f a="value">
	<e path="cocktail.style.WhiteSpaceStyleValue"/>
	<e path="cocktail.style.WhiteSpaceStyleValue"/>
</f></setWhiteSpace>
		<setTextAlign set="method" line="1576"><f a="value">
	<e path="cocktail.style.TextAlignStyleValue"/>
	<e path="cocktail.style.TextAlignStyleValue"/>
</f></setTextAlign>
		<setOpacity set="method" line="1582"><f a="value">
	<e path="cocktail.style.OpacityStyleValue"/>
	<e path="cocktail.style.OpacityStyleValue"/>
</f></setOpacity>
		<setVisibility set="method" line="1589"><f a="value">
	<e path="cocktail.style.VisibilityStyleValue"/>
	<e path="cocktail.style.VisibilityStyleValue"/>
</f></setVisibility>
		<setTransformOrigin set="method" line="1596"><f a="value">
	<t path="cocktail.style.TransformOriginStyleData"/>
	<t path="cocktail.style.TransformOriginStyleData"/>
</f></setTransformOrigin>
		<setTransform set="method" line="1602"><f a="value">
	<e path="cocktail.style.TransformStyleValue"/>
	<e path="cocktail.style.TransformStyleValue"/>
</f></setTransform>
		<getOpacity set="method" line="1612"><f a=""><e path="cocktail.style.OpacityStyleValue"/></f></getOpacity>
		<getVisibility set="method" line="1617"><f a=""><e path="cocktail.style.VisibilityStyleValue"/></f></getVisibility>
		<getMarginLeft set="method" line="1622"><f a=""><e path="cocktail.style.MarginStyleValue"/></f></getMarginLeft>
		<getMarginRight set="method" line="1627"><f a=""><e path="cocktail.style.MarginStyleValue"/></f></getMarginRight>
		<getMarginTop set="method" line="1632"><f a=""><e path="cocktail.style.MarginStyleValue"/></f></getMarginTop>
		<getMarginBottom set="method" line="1637"><f a=""><e path="cocktail.style.MarginStyleValue"/></f></getMarginBottom>
		<getPaddingLeft set="method" line="1642"><f a=""><e path="cocktail.style.PaddingStyleValue"/></f></getPaddingLeft>
		<getPaddingRight set="method" line="1647"><f a=""><e path="cocktail.style.PaddingStyleValue"/></f></getPaddingRight>
		<getPaddingTop set="method" line="1652"><f a=""><e path="cocktail.style.PaddingStyleValue"/></f></getPaddingTop>
		<getPaddingBottom set="method" line="1657"><f a=""><e path="cocktail.style.PaddingStyleValue"/></f></getPaddingBottom>
		<getDisplay set="method" line="1662"><f a=""><e path="cocktail.style.DisplayStyleValue"/></f></getDisplay>
		<getPosition set="method" line="1667"><f a=""><e path="cocktail.style.PositionStyleValue"/></f></getPosition>
		<getWidth set="method" line="1672"><f a=""><e path="cocktail.style.DimensionStyleValue"/></f></getWidth>
		<getHeight set="method" line="1677"><f a=""><e path="cocktail.style.DimensionStyleValue"/></f></getHeight>
		<getMinHeight set="method" line="1682"><f a=""><e path="cocktail.style.ConstrainedDimensionStyleValue"/></f></getMinHeight>
		<getMaxHeight set="method" line="1687"><f a=""><e path="cocktail.style.ConstrainedDimensionStyleValue"/></f></getMaxHeight>
		<getMinWidth set="method" line="1692"><f a=""><e path="cocktail.style.ConstrainedDimensionStyleValue"/></f></getMinWidth>
		<getMaxWidth set="method" line="1697"><f a=""><e path="cocktail.style.ConstrainedDimensionStyleValue"/></f></getMaxWidth>
		<getTop set="method" line="1702"><f a=""><e path="cocktail.style.PositionOffsetStyleValue"/></f></getTop>
		<getLeft set="method" line="1707"><f a=""><e path="cocktail.style.PositionOffsetStyleValue"/></f></getLeft>
		<getBottom set="method" line="1712"><f a=""><e path="cocktail.style.PositionOffsetStyleValue"/></f></getBottom>
		<getRight set="method" line="1717"><f a=""><e path="cocktail.style.PositionOffsetStyleValue"/></f></getRight>
		<getFloat set="method" line="1722"><f a=""><e path="cocktail.style.FloatStyleValue"/></f></getFloat>
		<getClear set="method" line="1727"><f a=""><e path="cocktail.style.ClearStyleValue"/></f></getClear>
		<getFontSize set="method" line="1732"><f a=""><e path="cocktail.style.FontSizeStyleValue"/></f></getFontSize>
		<getFontWeight set="method" line="1737"><f a=""><e path="cocktail.style.FontWeightStyleValue"/></f></getFontWeight>
		<getFontStyle set="method" line="1742"><f a=""><e path="cocktail.style.FontStyleStyleValue"/></f></getFontStyle>
		<getFontFamily set="method" line="1747"><f a=""><c path="Array"><e path="cocktail.style.FontFamilyStyleValue"/></c></f></getFontFamily>
		<getFontVariant set="method" line="1752"><f a=""><e path="cocktail.style.FontVariantStyleValue"/></f></getFontVariant>
		<getTextTransform set="method" line="1757"><f a=""><e path="cocktail.style.TextTransformStyleValue"/></f></getTextTransform>
		<getLetterSpacing set="method" line="1762"><f a=""><e path="cocktail.style.LetterSpacingStyleValue"/></f></getLetterSpacing>
		<getColor set="method" line="1767"><f a=""><e path="cocktail.unit.ColorValue"/></f></getColor>
		<getWordSpacing set="method" line="1772"><f a=""><e path="cocktail.style.WordSpacingStyleValue"/></f></getWordSpacing>
		<getLineHeight set="method" line="1777"><f a=""><e path="cocktail.style.LineHeightStyleValue"/></f></getLineHeight>
		<getVerticalAlign set="method" line="1782"><f a=""><e path="cocktail.style.VerticalAlignStyleValue"/></f></getVerticalAlign>
		<getTextIndent set="method" line="1787"><f a=""><e path="cocktail.style.TextIndentStyleValue"/></f></getTextIndent>
		<getWhiteSpace set="method" line="1792"><f a=""><e path="cocktail.style.WhiteSpaceStyleValue"/></f></getWhiteSpace>
		<getTextAlign set="method" line="1797"><f a=""><e path="cocktail.style.TextAlignStyleValue"/></f></getTextAlign>
		<getTransform set="method" line="1802"><f a=""><e path="cocktail.style.TransformStyleValue"/></f></getTransform>
		<getTransformOrigin set="method" line="1807"><f a=""><t path="cocktail.style.TransformOriginStyleData"/></f></getTransformOrigin>
		<new public="1" set="method" line="267">
			<f a="domElement">
				<t path="cocktail.domElement.DOMElement"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Class constructor. Stores the target DOMElement.
	 * 
	 * The style is invalid by default and will be updated
	 * when the DOMElement is added to the DOM.
	 </haxe_doc>
		</new>
		<haxe_doc>
 * This is the base class for all Style classes. Style classes
 * are in charge of storing the style value for a DOMElement
 * and applying them when neccessary.
 * 
 * This class holds a reference to the styled DOMElement
 * 
 * @author Yannick DOMINGUEZ
 </haxe_doc>
	</class>
	<class path="cocktailCore.style.js.Style" params="" file="/Users/lexa/Documents/repositories/lexoyo_Cocktail/demo/games/libs/cocktailCore/style/js/Style.hx">
		<extends path="cocktailCore.style.abstract.AbstractStyle"/>
		<flow public="1" set="method" line="70" override="1">
			<f a="containingDOMElementData:viewportData:lastPositionedDOMElementData:containingDOMElementFontMetricsData:?formatingContext">
				<t path="cocktailCore.style.ContainingDOMElementData"/>
				<t path="cocktailCore.style.ContainingDOMElementData"/>
				<t path="cocktailCore.style.LastPositionedDOMElementData"/>
				<t path="cocktailCore.style.FontMetricsData"/>
				<c path="cocktailCore.style.formatter.FormattingContext"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Overriden to allow the dimensions and position of the native HTMLElement to be stored
	 </haxe_doc>
		</flow>
		<flowChildren set="method" line="93" override="1">
			<f a="containingDOMElementData:viewportData:lastPositionedDOMElementData:containingDOMElementFontMetricsData:?formatingContext">
				<t path="cocktailCore.style.ContainingDOMElementData"/>
				<t path="cocktailCore.style.ContainingDOMElementData"/>
				<t path="cocktailCore.style.LastPositionedDOMElementData"/>
				<t path="cocktailCore.style.FontMetricsData"/>
				<c path="cocktailCore.style.formatter.FormattingContext"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Overriden to prevent the DOMElement to be inserted into the flow, it is managed by the browser in
	 * JavaScript
	 </haxe_doc>
		</flowChildren>
		<getCSSDisplay set="method" line="105">
			<f a="value">
				<e path="cocktail.style.DisplayStyleValue"/>
				<c path="String"/>
			</f>
			<haxe_doc>
	 * CSS : display
	 </haxe_doc>
		</getCSSDisplay>
		<getCSSFloat set="method" line="130">
			<f a="value">
				<e path="cocktail.style.FloatStyleValue"/>
				<c path="String"/>
			</f>
			<haxe_doc>
	 * CSS : float
	 </haxe_doc>
		</getCSSFloat>
		<getCSSClear set="method" line="152">
			<f a="value">
				<e path="cocktail.style.ClearStyleValue"/>
				<c path="String"/>
			</f>
			<haxe_doc>
	 * CSS : clear
	 </haxe_doc>
		</getCSSClear>
		<getCSSPosition set="method" line="177">
			<f a="value">
				<e path="cocktail.style.PositionStyleValue"/>
				<c path="String"/>
			</f>
			<haxe_doc>
	 * CSS : position
	 </haxe_doc>
		</getCSSPosition>
		<getCSSOpacity set="method" line="202">
			<f a="value">
				<e path="cocktail.style.OpacityStyleValue"/>
				<c path="String"/>
			</f>
			<haxe_doc>
	 * CSS : opacity
	 </haxe_doc>
		</getCSSOpacity>
		<getCSSVisibility set="method" line="218">
			<f a="value">
				<e path="cocktail.style.VisibilityStyleValue"/>
				<c path="String"/>
			</f>
			<haxe_doc>
	 * CSS : visibility
	 </haxe_doc>
		</getCSSVisibility>
		<getCSSTransform set="method" line="237">
			<f a="value">
				<e path="cocktail.style.TransformStyleValue"/>
				<c path="String"/>
			</f>
			<haxe_doc>
	 * CSS : transform
	 </haxe_doc>
		</getCSSTransform>
		<getCSSTransformFunction set="method" line="265">
			<f a="transformFunction">
				<e path="cocktail.style.TransformFunctionValue"/>
				<c path="String"/>
			</f>
			<haxe_doc>
	 * Returns the CSS representation of one transform
	 * function
	 </haxe_doc>
		</getCSSTransformFunction>
		<getCSSTranslation set="method" line="312">
			<f a="translation">
				<e path="cocktail.style.TranslationValue"/>
				<c path="String"/>
			</f>
			<haxe_doc>
	 * Return the CSS representation of a
	 * translation amount
	 </haxe_doc>
		</getCSSTranslation>
		<getCSSTransformOrigin set="method" line="331">
			<f a="value">
				<t path="cocktail.style.TransformOriginStyleData"/>
				<c path="String"/>
			</f>
			<haxe_doc>
	 * CSS : transform-origin
	 </haxe_doc>
		</getCSSTransformOrigin>
		<getCSSMargin set="method" line="386">
			<f a="value">
				<e path="cocktail.style.MarginStyleValue"/>
				<c path="String"/>
			</f>
			<haxe_doc>
	 * CSS : margin-top, margin-left...
	 </haxe_doc>
		</getCSSMargin>
		<getCSSPadding set="method" line="408">
			<f a="value">
				<e path="cocktail.style.PaddingStyleValue"/>
				<c path="String"/>
			</f>
			<haxe_doc>
	 * CSS : padding-top, padding-left...
	 </haxe_doc>
		</getCSSPadding>
		<getCSSDimension set="method" line="427">
			<f a="value">
				<e path="cocktail.style.DimensionStyleValue"/>
				<c path="String"/>
			</f>
			<haxe_doc>
	 * CSS : width, height
	 </haxe_doc>
		</getCSSDimension>
		<getCSSPositionOffset set="method" line="449">
			<f a="value">
				<e path="cocktail.style.PositionOffsetStyleValue"/>
				<c path="String"/>
			</f>
			<haxe_doc>
	 * CSS : top, left, right, bottom
	 </haxe_doc>
		</getCSSPositionOffset>
		<getCSSConstrainedDimension set="method" line="472">
			<f a="value">
				<e path="cocktail.style.ConstrainedDimensionStyleValue"/>
				<c path="String"/>
			</f>
			<haxe_doc>
	 * CSS : min-width, max-width, min-height, max-height
	 </haxe_doc>
		</getCSSConstrainedDimension>
		<getCSSVerticalAlign set="method" line="495">
			<f a="value">
				<e path="cocktail.style.VerticalAlignStyleValue"/>
				<c path="String"/>
			</f>
			<haxe_doc>
	 * CSS : vertical-align
	 </haxe_doc>
		</getCSSVerticalAlign>
		<getCSSLineHeight set="method" line="539">
			<f a="value">
				<e path="cocktail.style.LineHeightStyleValue"/>
				<c path="String"/>
			</f>
			<haxe_doc>
	 * CSS : line-height
	 </haxe_doc>
		</getCSSLineHeight>
		<getCSSFontSize set="method" line="569">
			<f a="value">
				<e path="cocktail.style.FontSizeStyleValue"/>
				<c path="String"/>
			</f>
			<haxe_doc>
	 * CSS : font-size
	 </haxe_doc>
		</getCSSFontSize>
		<getCSSFontWeight set="method" line="623">
			<f a="value">
				<e path="cocktail.style.FontWeightStyleValue"/>
				<c path="String"/>
			</f>
			<haxe_doc>
	 * CSS : font-weight
	 </haxe_doc>
		</getCSSFontWeight>
		<getCSSFontStyle set="method" line="642">
			<f a="value">
				<e path="cocktail.style.FontStyleStyleValue"/>
				<c path="String"/>
			</f>
			<haxe_doc>
	 * CSS : font-style
	 </haxe_doc>
		</getCSSFontStyle>
		<getCSSFontVariant set="method" line="661">
			<f a="value">
				<e path="cocktail.style.FontVariantStyleValue"/>
				<c path="String"/>
			</f>
			<haxe_doc>
	 * CSS : font-variant
	 </haxe_doc>
		</getCSSFontVariant>
		<getCSSFontFamily set="method" line="680">
			<f a="value">
				<c path="Array"><e path="cocktail.style.FontFamilyStyleValue"/></c>
				<c path="String"/>
			</f>
			<haxe_doc>
	 * CSS : font-family
	 </haxe_doc>
		</getCSSFontFamily>
		<getCSSTextAlign set="method" line="731">
			<f a="value">
				<e path="cocktail.style.TextAlignStyleValue"/>
				<c path="String"/>
			</f>
			<haxe_doc>
	 * CSS : text-align
	 </haxe_doc>
		</getCSSTextAlign>
		<getCSSWhiteSpace set="method" line="756">
			<f a="value">
				<e path="cocktail.style.WhiteSpaceStyleValue"/>
				<c path="String"/>
			</f>
			<haxe_doc>
	 * CSS : white-space
	 </haxe_doc>
		</getCSSWhiteSpace>
		<getCSSTextTransform set="method" line="784">
			<f a="value">
				<e path="cocktail.style.TextTransformStyleValue"/>
				<c path="String"/>
			</f>
			<haxe_doc>
	 * CSS : text-transform
	 </haxe_doc>
		</getCSSTextTransform>
		<getCSSTextIndent set="method" line="809">
			<f a="value">
				<e path="cocktail.style.TextIndentStyleValue"/>
				<c path="String"/>
			</f>
			<haxe_doc>
	 * CSS : text-indent
	 </haxe_doc>
		</getCSSTextIndent>
		<getCSSLetterSpacing set="method" line="828">
			<f a="value">
				<e path="cocktail.style.LetterSpacingStyleValue"/>
				<c path="String"/>
			</f>
			<haxe_doc>
	 * CSS : letter-spacing
	 </haxe_doc>
		</getCSSLetterSpacing>
		<getCSSWordSpacing set="method" line="847">
			<f a="value">
				<e path="cocktail.style.WordSpacingStyleValue"/>
				<c path="String"/>
			</f>
			<haxe_doc>
	 * CSS : word-spacing
	 </haxe_doc>
		</getCSSWordSpacing>
		<getCSSColor set="method" line="866">
			<f a="value">
				<e path="cocktail.unit.ColorValue"/>
				<c path="String"/>
			</f>
			<haxe_doc>
	 * CSS : color
	 </haxe_doc>
		</getCSSColor>
		<getCSSLengthValue set="method" line="892"><f a="lengthValue">
	<e path="cocktail.unit.LengthValue"/>
	<c path="String"/>
</f></getCSSLengthValue>
		<getCSSPercentValue set="method" line="926"><f a="value">
	<c path="Int"/>
	<c path="String"/>
</f></getCSSPercentValue>
		<getCSSAngleValue set="method" line="931"><f a="value">
	<e path="cocktail.unit.AngleValue"/>
	<c path="String"/>
</f></getCSSAngleValue>
		<getColorFromKeyword set="method" line="953"><f a="value">
	<e path="cocktail.unit.ColorKeywordValue"/>
	<c path="String"/>
</f></getColorFromKeyword>
		<getVendorSpecificStyleName set="method" line="1023">
			<f a="nativeStyle:styleName">
				<d/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
	 * For CSS styles not yet available across browser, find
	 * the vendor specific style name to use
	 * @param	nativeStyle the JavaScript Style object
	 </haxe_doc>
		</getVendorSpecificStyleName>
		<setVerticalAlign set="method" line="1075" override="1"><f a="value">
	<e path="cocktail.style.VerticalAlignStyleValue"/>
	<e path="cocktail.style.VerticalAlignStyleValue"/>
</f></setVerticalAlign>
		<setColor set="method" line="1082" override="1"><f a="value">
	<e path="cocktail.unit.ColorValue"/>
	<e path="cocktail.unit.ColorValue"/>
</f></setColor>
		<setWordSpacing set="method" line="1089" override="1"><f a="value">
	<e path="cocktail.style.WordSpacingStyleValue"/>
	<e path="cocktail.style.WordSpacingStyleValue"/>
</f></setWordSpacing>
		<setLetterSpacing set="method" line="1096" override="1"><f a="value">
	<e path="cocktail.style.LetterSpacingStyleValue"/>
	<e path="cocktail.style.LetterSpacingStyleValue"/>
</f></setLetterSpacing>
		<setTextTransform set="method" line="1103" override="1"><f a="value">
	<e path="cocktail.style.TextTransformStyleValue"/>
	<e path="cocktail.style.TextTransformStyleValue"/>
</f></setTextTransform>
		<setFontVariant set="method" line="1110" override="1"><f a="value">
	<e path="cocktail.style.FontVariantStyleValue"/>
	<e path="cocktail.style.FontVariantStyleValue"/>
</f></setFontVariant>
		<setFontFamily set="method" line="1117" override="1"><f a="value">
	<c path="Array"><e path="cocktail.style.FontFamilyStyleValue"/></c>
	<c path="Array"><e path="cocktail.style.FontFamilyStyleValue"/></c>
</f></setFontFamily>
		<setFontWeight set="method" line="1124" override="1"><f a="value">
	<e path="cocktail.style.FontWeightStyleValue"/>
	<e path="cocktail.style.FontWeightStyleValue"/>
</f></setFontWeight>
		<setFontStyle set="method" line="1131" override="1"><f a="value">
	<e path="cocktail.style.FontStyleStyleValue"/>
	<e path="cocktail.style.FontStyleStyleValue"/>
</f></setFontStyle>
		<setFontSize set="method" line="1138" override="1"><f a="value">
	<e path="cocktail.style.FontSizeStyleValue"/>
	<e path="cocktail.style.FontSizeStyleValue"/>
</f></setFontSize>
		<setLineHeight set="method" line="1145" override="1"><f a="value">
	<e path="cocktail.style.LineHeightStyleValue"/>
	<e path="cocktail.style.LineHeightStyleValue"/>
</f></setLineHeight>
		<setMarginLeft set="method" line="1152" override="1"><f a="value">
	<e path="cocktail.style.MarginStyleValue"/>
	<e path="cocktail.style.MarginStyleValue"/>
</f></setMarginLeft>
		<setMarginRight set="method" line="1159" override="1"><f a="value">
	<e path="cocktail.style.MarginStyleValue"/>
	<e path="cocktail.style.MarginStyleValue"/>
</f></setMarginRight>
		<setMarginTop set="method" line="1166" override="1"><f a="value">
	<e path="cocktail.style.MarginStyleValue"/>
	<e path="cocktail.style.MarginStyleValue"/>
</f></setMarginTop>
		<setMarginBottom set="method" line="1173" override="1"><f a="value">
	<e path="cocktail.style.MarginStyleValue"/>
	<e path="cocktail.style.MarginStyleValue"/>
</f></setMarginBottom>
		<setPaddingLeft set="method" line="1180" override="1"><f a="value">
	<e path="cocktail.style.PaddingStyleValue"/>
	<e path="cocktail.style.PaddingStyleValue"/>
</f></setPaddingLeft>
		<setPaddingRight set="method" line="1187" override="1"><f a="value">
	<e path="cocktail.style.PaddingStyleValue"/>
	<e path="cocktail.style.PaddingStyleValue"/>
</f></setPaddingRight>
		<setPaddingTop set="method" line="1194" override="1"><f a="value">
	<e path="cocktail.style.PaddingStyleValue"/>
	<e path="cocktail.style.PaddingStyleValue"/>
</f></setPaddingTop>
		<setPaddingBottom set="method" line="1201" override="1"><f a="value">
	<e path="cocktail.style.PaddingStyleValue"/>
	<e path="cocktail.style.PaddingStyleValue"/>
</f></setPaddingBottom>
		<setDisplay set="method" line="1208" override="1"><f a="value">
	<e path="cocktail.style.DisplayStyleValue"/>
	<e path="cocktail.style.DisplayStyleValue"/>
</f></setDisplay>
		<setPosition set="method" line="1215" override="1"><f a="value">
	<e path="cocktail.style.PositionStyleValue"/>
	<e path="cocktail.style.PositionStyleValue"/>
</f></setPosition>
		<setWidth set="method" line="1222" override="1"><f a="value">
	<e path="cocktail.style.DimensionStyleValue"/>
	<e path="cocktail.style.DimensionStyleValue"/>
</f></setWidth>
		<setHeight set="method" line="1229" override="1"><f a="value">
	<e path="cocktail.style.DimensionStyleValue"/>
	<e path="cocktail.style.DimensionStyleValue"/>
</f></setHeight>
		<setMinHeight set="method" line="1236" override="1"><f a="value">
	<e path="cocktail.style.ConstrainedDimensionStyleValue"/>
	<e path="cocktail.style.ConstrainedDimensionStyleValue"/>
</f></setMinHeight>
		<setMaxHeight set="method" line="1243" override="1"><f a="value">
	<e path="cocktail.style.ConstrainedDimensionStyleValue"/>
	<e path="cocktail.style.ConstrainedDimensionStyleValue"/>
</f></setMaxHeight>
		<setMinWidth set="method" line="1250" override="1"><f a="value">
	<e path="cocktail.style.ConstrainedDimensionStyleValue"/>
	<e path="cocktail.style.ConstrainedDimensionStyleValue"/>
</f></setMinWidth>
		<setMaxWidth set="method" line="1257" override="1"><f a="value">
	<e path="cocktail.style.ConstrainedDimensionStyleValue"/>
	<e path="cocktail.style.ConstrainedDimensionStyleValue"/>
</f></setMaxWidth>
		<setTop set="method" line="1264" override="1"><f a="value">
	<e path="cocktail.style.PositionOffsetStyleValue"/>
	<e path="cocktail.style.PositionOffsetStyleValue"/>
</f></setTop>
		<setLeft set="method" line="1271" override="1"><f a="value">
	<e path="cocktail.style.PositionOffsetStyleValue"/>
	<e path="cocktail.style.PositionOffsetStyleValue"/>
</f></setLeft>
		<setBottom set="method" line="1278" override="1"><f a="value">
	<e path="cocktail.style.PositionOffsetStyleValue"/>
	<e path="cocktail.style.PositionOffsetStyleValue"/>
</f></setBottom>
		<setRight set="method" line="1285" override="1"><f a="value">
	<e path="cocktail.style.PositionOffsetStyleValue"/>
	<e path="cocktail.style.PositionOffsetStyleValue"/>
</f></setRight>
		<setTextIndent set="method" line="1292" override="1"><f a="value">
	<e path="cocktail.style.TextIndentStyleValue"/>
	<e path="cocktail.style.TextIndentStyleValue"/>
</f></setTextIndent>
		<setFloat set="method" line="1299" override="1"><f a="value">
	<e path="cocktail.style.FloatStyleValue"/>
	<e path="cocktail.style.FloatStyleValue"/>
</f></setFloat>
		<setClear set="method" line="1306" override="1"><f a="value">
	<e path="cocktail.style.ClearStyleValue"/>
	<e path="cocktail.style.ClearStyleValue"/>
</f></setClear>
		<setWhiteSpace set="method" line="1313" override="1"><f a="value">
	<e path="cocktail.style.WhiteSpaceStyleValue"/>
	<e path="cocktail.style.WhiteSpaceStyleValue"/>
</f></setWhiteSpace>
		<setTextAlign set="method" line="1320" override="1"><f a="value">
	<e path="cocktail.style.TextAlignStyleValue"/>
	<e path="cocktail.style.TextAlignStyleValue"/>
</f></setTextAlign>
		<setOpacity set="method" line="1327" override="1"><f a="value">
	<e path="cocktail.style.OpacityStyleValue"/>
	<e path="cocktail.style.OpacityStyleValue"/>
</f></setOpacity>
		<setVisibility set="method" line="1334" override="1"><f a="value">
	<e path="cocktail.style.VisibilityStyleValue"/>
	<e path="cocktail.style.VisibilityStyleValue"/>
</f></setVisibility>
		<setTransformOrigin set="method" line="1341" override="1"><f a="value">
	<t path="cocktail.style.TransformOriginStyleData"/>
	<t path="cocktail.style.TransformOriginStyleData"/>
</f></setTransformOrigin>
		<setTransform set="method" line="1350" override="1"><f a="value">
	<e path="cocktail.style.TransformStyleValue"/>
	<e path="cocktail.style.TransformStyleValue"/>
</f></setTransform>
		<new public="1" set="method" line="58">
			<f a="domElement">
				<t path="cocktail.domElement.DOMElement"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * class constructor
	 </haxe_doc>
		</new>
		<haxe_doc>
 * In JavaScript, Styles are converted to native CSS styles and thus the browser manages the layout
 * and Styles of the document, not Cocktail. It would have been possible
 * to re-implement styles in JS, for instance processing the layout of the document 
 * entirely in JS, like in the Flash runtime but it would have had the following drawbacks : 
 * 
 * - way worse performance
 * - generate non-standard HTML (e.g : to manage the layout in pure JS, all HTML elements should
 * have been positionned as 'absolute' instead on relying on the standard document's flow
 * - Some limitations would have occured such as floats which would have been very difficult 
 * to reproduce in pure JS
 * 
 * On the other hand, relying on CSS implies a few browser inconsistencies.
 * 
 * For each abstract style applied to a DOMElement, this class converts it to a CSS String
 * which is applied to the style object of the native HTML element
 * 
 * Each time a layout happens (when a style changes, when the viewport is resized...), 
 * The width, height, x and y of the native JavaScript HTMLElement are stored.
 * 
 * They are also stored when the width/height/x/y are set directly on the DOMElement
 * (with DOMElement.x, DOMElement.y ...).
 * Those value are stored immediately because in JavaScript when changing a style on an object,
 * methods to get the actual width of an element (like clientWidth) are set asynchronously,
 * meaning that in the following example, the width var will be equal to 0 instead of 100 : 
 * myHTMLElement.style.width = 100px;
 * var width = myHTMLElement.clientWidth;
 * 
 * A Timer needs to be set to retrieve the value and that is why it is set after a layout
 * which is asynchronous to prevent having multiple timers and also immediately after
 * setting it using the x,y,width or height attributes of the DOMElement
 * 
 * @author Yannick DOMINGUEZ
 </haxe_doc>
	</class>
	<class path="cocktailCore.style.abstract.AbstractContainerStyle" params="" file="/Users/lexa/Documents/repositories/lexoyo_Cocktail/demo/games/libs/cocktailCore/style/abstract/AbstractContainerStyle.hx">
		<extends path="cocktailCore.style.js.Style"/>
		<layout public="1" set="method" line="69" override="1">
			<f a="containingDOMElementData:lastPositionedDOMElementData:viewportData:containingDOMElementFontMetricsData">
				<t path="cocktailCore.style.ContainingDOMElementData"/>
				<t path="cocktailCore.style.LastPositionedDOMElementData"/>
				<t path="cocktailCore.style.ContainingDOMElementData"/>
				<t path="cocktailCore.style.FontMetricsData"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * This method is overriden to start a recursive layout when called on a ContainerDOMElement. The ContainerDOMElement
	 * will be measured and placed as well as all its children
	 </haxe_doc>
		</layout>
		<flowChildren set="method" line="81" override="1">
			<f a="containingDOMElementData:viewportData:lastPositionedDOMElementData:containingDOMElementFontMetricsData:?formatingContext">
				<t path="cocktailCore.style.ContainingDOMElementData"/>
				<t path="cocktailCore.style.ContainingDOMElementData"/>
				<t path="cocktailCore.style.LastPositionedDOMElementData"/>
				<t path="cocktailCore.style.FontMetricsData"/>
				<c path="cocktailCore.style.formatter.FormattingContext"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Lay out all the children of the ContainerDOMElement
	 </haxe_doc>
		</flowChildren>
		<insertInFlowDOMElement set="method" line="210" override="1">
			<f a="formattingContext">
				<c path="cocktailCore.style.formatter.FormattingContext"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Overriden as ContainerDOMElement is only added to the flow if it is not inline.
	 * If it is inline, only its children are added in the flow.
	 </haxe_doc>
		</insertInFlowDOMElement>
		<doFlowChildren set="method" line="225">
			<f a="childrenContainingDOMElementData:viewportData:childLastPositionedDOMElementData:childrenContainingDOMElementFontMetricsData:childrenFormattingContext">
				<t path="cocktailCore.style.ContainingDOMElementData"/>
				<t path="cocktailCore.style.ContainingDOMElementData"/>
				<t path="cocktailCore.style.LastPositionedDOMElementData"/>
				<t path="cocktailCore.style.FontMetricsData"/>
				<c path="cocktailCore.style.formatter.FormattingContext"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Actually flow all the children of the ContainerDOMElement
	 </haxe_doc>
		</doFlowChildren>
		<doPositionAbsolutelyPositionedDOMElements set="method" line="256">
			<f a="isFirstPositionedAncestor:childLastPositionedDOMElementData:viewportData">
				<e path="Bool"/>
				<t path="cocktailCore.style.LastPositionedDOMElementData"/>
				<t path="cocktailCore.style.ContainingDOMElementData"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * When this ContainerDOMElement is positioned, position each of its children using it
	 * as its origin. This method is called once all the dimensions of ContainerDOMElement
	 * are known so that absolutely positioned children can be positioned using the bottom
	 * and right styles
	 </haxe_doc>
		</doPositionAbsolutelyPositionedDOMElements>
		<insertTextElement set="method" line="276">
			<f a="textElement:formattingContext:containingDOMElementData">
				<t path="cocktail.textElement.TextElement"/>
				<c path="cocktailCore.style.formatter.FormattingContext"/>
				<t path="cocktailCore.style.ContainingDOMElementData"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Insert a TextElement ( a string of text without formatting ) by creating as many TextFragmentDOMElement as needed from it
	 * and inserting them into the flow
	 * @param	textElement the string of text used as content for the created text lines
	 </haxe_doc>
		</insertTextElement>
		<shrinkToFitIfNeeded set="method" line="327">
			<f a="containingDOMElementData:minimumWidth">
				<t path="cocktailCore.style.ContainingDOMElementData"/>
				<c path="Int"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
	 * In certain cases, when the width of the ContainerDOMElement is 'auto',
	 * its computed value is 'shrink-to-fit' meaning that it will take either
	 * the width of the widest line form by its children or the width of its
	 * container if the children overflows
	 * 
	 * @param	containingDOMElementData
	 * @param	minimumWidth the width of the widest line of children laid out
	 * by this ContainerDOMElement which will be the minimum width that should
	 * have this DOMElement if it is shrinked to fit
	 </haxe_doc>
		</shrinkToFitIfNeeded>
		<applyContentHeightIfNeeded set="method" line="342">
			<f a="containingDOMElementData:childrenHeight">
				<t path="cocktailCore.style.ContainingDOMElementData"/>
				<c path="Int"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
	 * In most cases, when the height of a ContainerDOMElement
	 * is 'auto', its computed height become the total height
	 * of its in flow children, computed once all its
	 * children have been laid out 
	 * 
	 * @param	containingDOMElementData
	 * @param	childrenHeight the total height of the children once laid out
	 </haxe_doc>
		</applyContentHeightIfNeeded>
		<invalidateText set="method" line="356" override="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * When invalidating text on a ContainerDOMElement, the created TextFragmentDOMElement
	 * must be deleted so that they can be redrawn on next layout
	 </haxe_doc>
		</invalidateText>
		<getTextFragmentDOMElement set="method" line="373">
			<f a="textFragmentData:text">
				<t path="cocktailCore.textElement.TextFragmentData"/>
				<c path="String"/>
				<t path="cocktailCore.domElement.TextFragmentDOMElement"/>
			</f>
			<haxe_doc>
	 * Take a TextFragmentData and a text, and create
	 * a TextFragmentDOMElement from it if it does'nt already
	 * exists. If it does, return it
	 </haxe_doc>
		</getTextFragmentDOMElement>
		<createTextFragment set="method" line="394">
			<f a="text">
				<c path="String"/>
				<t path="cocktailCore.domElement.TextFragmentDOMElement"/>
			</f>
			<haxe_doc>
	 * Create a TextFragmentDOMElement from a string of text and
	 * add it to the ContainerDOMElement
	 </haxe_doc>
		</createTextFragment>
		<doCreateTextFragment set="method" line="408">
			<f a="text">
				<c path="String"/>
				<t path="cocktailCore.domElement.TextFragmentDOMElement"/>
			</f>
			<haxe_doc>
	 * Actually create the TextFragmentDOMElement using runtime
	 * specific API. Overriden by each runtime
	 </haxe_doc>
		</doCreateTextFragment>
		<getContainerDOMElementData public="1" set="method" line="421">
			<f a=""><t path="cocktailCore.style.ContainingDOMElementData"/></f>
			<haxe_doc>
	 * Return the dimensions and position data
	 * of the ContainerDOMElement
	 </haxe_doc>
		</getContainerDOMElementData>
		<getFormatingContext set="method" line="492">
			<f a="?previousFormatingContext">
				<c path="cocktailCore.style.formatter.FormattingContext"/>
				<c path="cocktailCore.style.formatter.FormattingContext"/>
			</f>
			<haxe_doc>
	 * Return the right formatting context to layout this ContainerDOMElement
	 * children.
	 * 
	 * A ContainerDOMElement can either establish a new formatting context
	 * or participate in the current formatting context. If it participates
	 * in the current formatting context, then the previous formatting
	 * is returned else a new block or inline formatting context is
	 * instantiated
	 * 
	 * INLINE FLOW CONTAINER DOMELEMENT
	 * 
	 * If the container DOMElement itself is an inline flow DOMElement
	 * (it flows its children in an inline formatting context), the
	 * container DOMElement participates in the previous formatting context
	 * 
	 * BLOCK FLOW CONTAINER DOMELEMENT
	 * 
	 * If the container DOMElement itself is a block flow DOMElement, (it can
	 * layout its children either in an inline or block formatting context)
	 * ,it establishes a new formatting context for its children. If all its 
	 * children are inline level, an inline formatting context is instantiated,
	 * else if all its children are block level, a block level formatting context
	 * is instantiated. If its children mix inline and block level DOMElement,
	 * inline formatting context is the default.
	 * 
	 * 
	 * @param	previousFormatingContext the formatting context of the parent of this
	 * Container DOMElement, might be returned if the container DOMElement participates
	 * in the same formatting context as its parent
	 * 
	 * @return an inline or block formatting context
	 </haxe_doc>
		</getFormatingContext>
		<childrenInline set="method" line="542">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>
	 * Determine wether the children of this DOMElement
	 * are all block level or if they are all inline level
	 * elements
	 * @return true if all children are inline DOMElements
	 </haxe_doc>
		</childrenInline>
		<isChildInline set="method" line="572">
			<f a="child">
				<t path="cocktailCore.domElement.ContainerDOMElementChildData"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
	 * Determine wether a children is inline or not
	 </haxe_doc>
		</isChildInline>
		<getChildLastPositionedDOMElementData set="method" line="615">
			<f a="lastPositionedDOMElementData">
				<t path="cocktailCore.style.LastPositionedDOMElementData"/>
				<t path="cocktailCore.style.LastPositionedDOMElementData"/>
			</f>
			<haxe_doc>
	 * Return the structure used to layout absolutely positioned
	 * children. If this ContainerDOMElement is positioned, a new
	 * structure is created, else the current one is used
	 </haxe_doc>
		</getChildLastPositionedDOMElementData>
		<startsNewFormattingContext set="method" line="639">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>
	 * Determine wether a block container
	 * starts a new formatting context for
	 * its children
	 </haxe_doc>
		</startsNewFormattingContext>
		<isInlineFlow set="method" line="681">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>
	 * Determine wheter the container DOMElement
	 * is an inline or block flow. For instance,
	 * an inline-block containerDOMElement is both
	 * inline (because it is placed on a line) and
	 * a block flow, because it can layout its
	 * children either into either a block or
	 * inline formatting context
	 </haxe_doc>
		</isInlineFlow>
		<isDOMElement set="method" line="704">
			<f a="containerDOMElementChildData">
				<t path="cocktailCore.domElement.ContainerDOMElementChildData"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
	 * Determine wether the given children is a 
	 * DOMElement or a TextElement
	 </haxe_doc>
		</isDOMElement>
		<new public="1" set="method" line="56">
			<f a="domElement">
				<t path="cocktail.domElement.DOMElement"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * class constructor
	 * @param	domElement
	 </haxe_doc>
		</new>
		<haxe_doc>
 * This is the style implementation for ContainerDOMElement.
 * 
 * ContainerDOMElement can have children, and when laid out,
 * also start the layout on each of its children
 * 
 * @author Yannick DOMINGUEZ
 </haxe_doc>
	</class>
	<class path="cocktailCore.style.js.ContainerStyle" params="" file="/Users/lexa/Documents/repositories/lexoyo_Cocktail/demo/games/libs/cocktailCore/style/js/ContainerStyle.hx">
		<extends path="cocktailCore.style.abstract.AbstractContainerStyle"/>
		<flowChildren set="method" line="43" override="1">
			<f a="containingDOMElementData:viewportData:lastPositionedDOMElementData:containingDOMElementFontMetricsData:?formatingContext">
				<t path="cocktailCore.style.ContainingDOMElementData"/>
				<t path="cocktailCore.style.ContainingDOMElementData"/>
				<t path="cocktailCore.style.LastPositionedDOMElementData"/>
				<t path="cocktailCore.style.FontMetricsData"/>
				<c path="cocktailCore.style.formatter.FormattingContext"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Make all the DOMElement retrieve their native HTMLElement positions
	 * and dimensions
	 </haxe_doc>
		</flowChildren>
		<new public="1" set="method" line="34">
			<f a="domElement">
				<t path="cocktail.domElement.DOMElement"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * class constructor
	 </haxe_doc>
		</new>
		<haxe_doc>
 * This is the JavaScript implementation of the ContainerStyle.
 * 
 * In JS, styles are applied using native CSS, so the browser
 * formats the document instead of Cocktail.
 * 
 * Cocktail only store for each DOMElement the position
 * and dimensions of its native HTMLElement
 * 
 * @author Yannick DOMINGUEZ
 </haxe_doc>
	</class>
	<class path="cocktailCore.style.abstract.AbstractBodyStyle" params="" file="/Users/lexa/Documents/repositories/lexoyo_Cocktail/demo/games/libs/cocktailCore/style/abstract/AbstractBodyStyle.hx">
		<extends path="cocktailCore.style.js.ContainerStyle"/>
		<invalidate public="1" set="method" line="49" override="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * The BodyDOMElement doesn't have a parent, so when invalidated,
	 * it always schedule a layout using the viewport dimensions as
	 * its containing DOMElement dimensions
	 </haxe_doc>
		</invalidate>
		<doPositionAbsolutelyPositionedDOMElements set="method" line="75" override="1">
			<f a="isFirstPositionedAncestor:childLastPositionedDOMElementData:viewportData">
				<e path="Bool"/>
				<t path="cocktailCore.style.LastPositionedDOMElementData"/>
				<t path="cocktailCore.style.ContainingDOMElementData"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Overriden because a BodyDOMElement being at the top of the
	 * DOM tree must always position its absolutely positioned
	 * children
	 </haxe_doc>
		</doPositionAbsolutelyPositionedDOMElements>
		<getFormatingContext set="method" line="88" override="1">
			<f a="?previousFormatingContext">
				<c path="cocktailCore.style.formatter.FormattingContext"/>
				<c path="cocktailCore.style.formatter.FormattingContext"/>
			</f>
			<haxe_doc>
	 * The root of the runtime always starts a block formatting context
	 </haxe_doc>
		</getFormatingContext>
		<setNativeX public="1" set="method" line="98" override="1"><f a="domElement:x">
	<t path="cocktail.domElement.DOMElement"/>
	<c path="Int"/>
	<e path="Void"/>
</f></setNativeX>
		<setNativeY public="1" set="method" line="103" override="1"><f a="domElement:y">
	<t path="cocktail.domElement.DOMElement"/>
	<c path="Int"/>
	<e path="Void"/>
</f></setNativeY>
		<setNativeWidth public="1" set="method" line="108" override="1"><f a="width">
	<c path="Int"/>
	<e path="Void"/>
</f></setNativeWidth>
		<setNativeHeight public="1" set="method" line="113" override="1"><f a="height">
	<c path="Int"/>
	<e path="Void"/>
</f></setNativeHeight>
		<setNativeOpacity public="1" set="method" line="118" override="1"><f a="opacity">
	<c path="Float"/>
	<e path="Void"/>
</f></setNativeOpacity>
		<setNativeVisibility public="1" set="method" line="123" override="1"><f a="visibility">
	<e path="Bool"/>
	<e path="Void"/>
</f></setNativeVisibility>
		<new public="1" set="method" line="30">
			<f a="domElement">
				<t path="cocktail.domElement.DOMElement"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * class constructor
	 * @param	domElement
	 </haxe_doc>
		</new>
		<haxe_doc>
 * This is the style implementation for BodyDOMElement.
 * It inherits from ContainerStyle and implement behaviours
 * specific to the root of the runtime where appropriate
 * 
 * @author Yannick DOMINGUEZ
 </haxe_doc>
	</class>
	<class path="cocktailCore.style.positioner.BoxPositioner" params="" file="/Users/lexa/Documents/repositories/lexoyo_Cocktail/demo/games/libs/cocktailCore/style/positioner/BoxPositioner.hx">
		<position public="1" set="method" line="63">
			<f a="domElement:containingDOMElementData:staticPosition">
				<t path="cocktail.domElement.DOMElement"/>
				<t path="cocktailCore.style.ContainingDOMElementData"/>
				<t path="cocktail.geom.PointData"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Main entry point, place a positioned element in the document based on a containingDOMElement
	 * dimensions and positions and/or apply an offset to it
	 * 
	 * @param	domElement the DOMElement to position
	 * @param	containingDOMElement the dimensions and positions of the DOMElement used to position the 
	 * target DOMElement for absolutely positioned DOMElements (its first positioned ancestor or the viewport)
	 * @param staticPosition the position the DOMElement would have in the flow if it weren't positioned. Used if
	 * the position styles (left, right, top and bottom) are set to 'auto'
	 </haxe_doc>
		</position>
		<applyGlobalX set="method" line="114">
			<f a="domElement:globalX">
				<t path="cocktail.domElement.DOMElement"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * set a global X on the DOMElement
	 </haxe_doc>
		</applyGlobalX>
		<applyGlobalY set="method" line="122">
			<f a="domElement:globalY">
				<t path="cocktail.domElement.DOMElement"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * set a global Y on the DOMElement
	 </haxe_doc>
		</applyGlobalY>
		<getLeftOffset set="method" line="130">
			<f a="domElement">
				<t path="cocktail.domElement.DOMElement"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
	 * get the left offset to apply the DOMElement
	 </haxe_doc>
		</getLeftOffset>
		<getRightOffset set="method" line="138">
			<f a="domElement:containingDOMElementWidth">
				<t path="cocktail.domElement.DOMElement"/>
				<c path="Int"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
	 * get the right offset to apply the DOMElement
	 </haxe_doc>
		</getRightOffset>
		<getTopOffset set="method" line="146">
			<f a="domElement">
				<t path="cocktail.domElement.DOMElement"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
	 * get the top offset to apply the DOMElement
	 </haxe_doc>
		</getTopOffset>
		<getBottomOffset set="method" line="154">
			<f a="domElement:containingDOMElementHeight">
				<t path="cocktail.domElement.DOMElement"/>
				<c path="Int"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
	 * get the bottom offset to apply the DOMElement
	 </haxe_doc>
		</getBottomOffset>
		<new public="1" set="method" line="44">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * Class constructor
	 </haxe_doc>
		</new>
		<haxe_doc>
 * This is the base classes for class in charge
 * in charge of laying out 'positioned' DOMElements.
 * 
 * A positioned DOMElement is one with a 'position' style value
 * of 'relative', 'absolute' or 'fixed'.
 * 
 * There are 2 kinds of positioned DOMElements : absolutely positioned
 * ('absolute' or 'fixed') and relatively positioned ('relative').
 * 
 * Absolutely positioned DOMElements are taken out of the flow
 * and positioned by taking either their first positioned ancestor
 * as origin ('absolute') or the viewport('fixed').
 * 
 * Relatively positioned DOMElement are first placed into the normal
 * flow, then an offset is applied to them.
 * 
 * This base class implements the behaviour of the 'absolute' 
 * position value
 * 
 * @author Yannick DOMINGUEZ
 </haxe_doc>
	</class>
	<class path="cocktailCore.style.positioner.AbsolutePositioner" params="" file="/Users/lexa/Documents/repositories/lexoyo_Cocktail/demo/games/libs/cocktailCore/style/positioner/AbsolutePositioner.hx">
		<extends path="cocktailCore.style.positioner.BoxPositioner"/>
		<new public="1" set="method" line="23">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * class constructor
	 </haxe_doc>
		</new>
		<haxe_doc>
 * This is the implementation of the box positioner
 * for 'absolute' DOMElement, doesn't add anything
 * as this is the default behaviour
 * 
 * @author Yannick DOMINGUEZ
 </haxe_doc>
	</class>
	<class path="cocktailCore.textElement.abstract.AbstractTextElement" params="" file="/Users/lexa/Documents/repositories/lexoyo_Cocktail/demo/games/libs/cocktailCore/textElement/abstract/AbstractTextElement.hx">
		<applyWhiteSpace public="1" set="method" line="103" static="1">
			<f a="text:whiteSpace">
				<c path="String"/>
				<e path="cocktail.style.WhiteSpaceStyleValue"/>
				<c path="String"/>
			</f>
			<haxe_doc>
	 * Apply the whiteSpace style rule to a text
	 </haxe_doc>
		</applyWhiteSpace>
		<applyTextTransform public="1" set="method" line="135" static="1">
			<f a="text:textTransform">
				<c path="String"/>
				<e path="cocktail.style.TextTransformStyleValue"/>
				<c path="String"/>
			</f>
			<haxe_doc>
	 * Transform a text letters into uppercase, lowercase
	 * or capitalise them (only the first letter of each word
	 * is transformed to uppercase), based on the textTransform
	 * style of this container DOMElement
	 </haxe_doc>
		</applyTextTransform>
		<capitalizeText public="1" set="method" line="158" static="1">
			<f a="text">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
	 * Capitalise a text (turn each first letter
	 * of a word to uppercase)
	 </haxe_doc>
		</capitalizeText>
		<collapseSpaceSequences public="1" set="method" line="184" static="1">
			<f a="text">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
	 * Convert sequences of spaces in a text
	 * into a single space
	 </haxe_doc>
		</collapseSpaceSequences>
		<removeLineFeeds public="1" set="method" line="213" static="1">
			<f a="text">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
	 * Removes the new line control character
	 * from a text
	 </haxe_doc>
		</removeLineFeeds>
		<convertTabToSpace public="1" set="method" line="223" static="1">
			<f a="text">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
	 * Removes the tabulation control character
	 * from a text by converting them to space
	 * character
	 </haxe_doc>
		</convertTabToSpace>
		<doGetTextFragments set="method" line="239" static="1">
			<f a="text">
				<c path="String"/>
				<c path="Array"><t path="cocktailCore.textElement.TextFragmentData"/></c>
			</f>
			<haxe_doc>
	 * Actually convert a text into an array
	 * of text token. Each item of the array
	 * also has a null TextFragmentDOMElement,
	 * as it is only created once the text is laid
	 * out
	 </haxe_doc>
		</doGetTextFragments>
		<insertTextToken set="method" line="330" static="1">
			<f a="textToken">
				<e path="cocktailCore.textElement.TextTokenValue"/>
				<t path="cocktailCore.textElement.TextFragmentData"/>
			</f>
			<haxe_doc>
	 * Utils method wrapping a textToken into a textFragmentData
	 * with a null textFragmentDOMElement
	 </haxe_doc>
		</insertTextToken>
		<_text>
			<t path="cocktailCore.textElement.NativeTextElement"/>
			<haxe_doc>
	 * The native text element, for instance
	 * in Flash it is just a String whereas in
	 * Js it is an HTML text node object
	 </haxe_doc>
		</_text>
		<text public="1" get="getText" set="null"><t path="cocktailCore.textElement.NativeTextElement"/></text>
		<_textFragments>
			<c path="Array"><t path="cocktailCore.textElement.TextFragmentData"/></c>
			<haxe_doc>
	 * An array where each item contains a text token,
	 * representing the kind of text contained (a word,
	 * a space, a tab...) and the corresponding TextFragmentDOMElement,
	 * created when the text is rendered
	 </haxe_doc>
		</_textFragments>
		<reset public="1" set="method" line="61">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * Remove a reference to every generated
	 * textFragmentDOMElement. Used when the content
	 * of the TextElement changes or when the style
	 * of its ContainerDOMElement changes
	 </haxe_doc>
		</reset>
		<getTextFragments public="1" set="method" line="73">
			<f a="text">
				<c path="String"/>
				<c path="Array"><t path="cocktailCore.textElement.TextFragmentData"/></c>
			</f>
			<haxe_doc>
	 * Takes a string of plain text and create an array of text
	 * token from it
	 </haxe_doc>
		</getTextFragments>
		<getNativeText public="1" set="method" line="90">
			<f a=""><c path="String"/></f>
			<haxe_doc>
	 * Return the String of text wrapped
	 * in the NativeTextElement. Overriden
	 * by each runtime
	 </haxe_doc>
		</getNativeText>
		<getText set="method" line="339"><f a=""><t path="cocktailCore.textElement.NativeTextElement"/></f></getText>
		<new public="1" set="method" line="46">
			<f a="text">
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * class constructor
	 * @param	text the wrapped by this TextElement
	 </haxe_doc>
		</new>
		<haxe_doc>
 * A TextElement is an abstraction of an unformatted string of
 * plain text. A TextElement is attached to the DOM when it is
 * added to a ContainerDOMElement. The string of text is then
 * rendered using the styles of the ContainerDOMElement
 * 
 * @author Yannick DOMINGUEZ
 </haxe_doc>
	</class>
	<class path="cocktailCore.domElement.abstract.AbstractDOMElement" params="" file="/Users/lexa/Documents/repositories/lexoyo_Cocktail/demo/games/libs/cocktailCore/domElement/abstract/AbstractDOMElement.hx">
		<_mouse>
			<t path="cocktailCore.mouse.Mouse"/>
			<haxe_doc>
	 * An instance of the cross-platform mouse class, used to listen
	 * to native mouse events
	 </haxe_doc>
		</_mouse>
		<onMouseDown public="1" get="getOnMouseDown" set="setOnMouseDown">
			<f a="">
				<t path="cocktail.mouse.MouseEventData"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * The callback called on mouse down through the mouse instance
	 </haxe_doc>
		</onMouseDown>
		<onMouseUp public="1" get="getOnMouseUp" set="setOnMouseUp">
			<f a="">
				<t path="cocktail.mouse.MouseEventData"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * The callback called on mouse up through the mouse instance
	 </haxe_doc>
		</onMouseUp>
		<onMouseOver public="1" get="getOnMouseOver" set="setOnMouseOver">
			<f a="">
				<t path="cocktail.mouse.MouseEventData"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * The callback called when the mouse pointer hovers this dom element
	 </haxe_doc>
		</onMouseOver>
		<onMouseOut public="1" get="getOnMouseOut" set="setOnMouseOut">
			<f a="">
				<t path="cocktail.mouse.MouseEventData"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * The callback called on mouse out of this dom element
	 </haxe_doc>
		</onMouseOut>
		<onMouseMove public="1" get="getOnMouseMove" set="setOnMouseMove">
			<f a="">
				<t path="cocktail.mouse.MouseEventData"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * The callback called when the mouse pointer moves over this dom element
	 </haxe_doc>
		</onMouseMove>
		<onMouseDoubleClick public="1" get="getOnMouseDoubleClick" set="setOnMouseDoubleClick">
			<f a="">
				<t path="cocktail.mouse.MouseEventData"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * The callback called when this dom element is double-clicked
	 </haxe_doc>
		</onMouseDoubleClick>
		<_keyboard>
			<t path="cocktailCore.keyboard.Keyboard"/>
			<haxe_doc>
	 * An instance of the cross-platform keyboard class, used to listen
	 * to key down and up event
	 </haxe_doc>
		</_keyboard>
		<onKeyDown public="1" get="getOnKeyDown" set="setOnKeyDown">
			<f a="">
				<t path="cocktail.keyboard.KeyEventData"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * The callback called on key down through the keyboard instance
	 </haxe_doc>
		</onKeyDown>
		<onKeyUp public="1" get="getOnKeyUp" set="setOnKeyUp">
			<f a="">
				<t path="cocktail.keyboard.KeyEventData"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * The callback called on key up through the keyboard instance
	 </haxe_doc>
		</onKeyUp>
		<_nativeElement>
			<t path="cocktail.nativeElement.NativeElement"/>
			<haxe_doc>
	 * An abstract reference to the native element wrapped by this DOMElement.
	 * Varies for each runtime : in JS it is an HTML element, in Flash a Sprite,
	 * in PHP a resource...
	 </haxe_doc>
		</_nativeElement>
		<nativeElement public="1" get="getNativeElement" set="setNativeElement"><t path="cocktail.nativeElement.NativeElement"/></nativeElement>
		<_parent>
			<t path="cocktail.domElement.ContainerDOMElement"/>
			<haxe_doc>
	 * a reference to the parent of this DOMElement, of type container, the
	 * only kind of DOMElement which can have children
	 </haxe_doc>
		</_parent>
		<parent public="1" get="getParent" set="setParent"><t path="cocktail.domElement.ContainerDOMElement"/></parent>
		<x public="1" get="getX" set="setX">
			<c path="Int"/>
			<haxe_doc>
	 * get/set the x position of this DOMElement's nativeElement
	 </haxe_doc>
		</x>
		<globalX public="1" get="getGlobalX" set="setGlobalX">
			<c path="Int"/>
			<haxe_doc>
	 * get/set the global x. It is relative to the root 
	 * DOMElement.
	 </haxe_doc>
		</globalX>
		<y public="1" get="getY" set="setY">
			<c path="Int"/>
			<haxe_doc>
	 * get/set the y position of this DOMElement's nativeElement
	 </haxe_doc>
		</y>
		<globalY public="1" get="getGlobalY" set="setGlobalY">
			<c path="Int"/>
			<haxe_doc>
	 * get/set the global y. It is relative to the root 
	 * DOMElement.
	 </haxe_doc>
		</globalY>
		<width public="1" get="getWidth" set="setWidth">
			<c path="Int"/>
			<haxe_doc>
	 * get/set the width position of this DOMElement's nativeElement
	 </haxe_doc>
		</width>
		<height public="1" get="getHeight" set="setHeight">
			<c path="Int"/>
			<haxe_doc>
	 * get/set the height position of this DOMElement's nativeElement
	 </haxe_doc>
		</height>
		<offsetWidth public="1" get="getOffsetWidth" set="null">
			<c path="Int"/>
			<haxe_doc>
	 * Read-only, returns the width of the domElement
	 * + horizontal paddings + horizontal margins
	 </haxe_doc>
		</offsetWidth>
		<offsetHeight public="1" get="getOffsetHeight" set="null">
			<c path="Int"/>
			<haxe_doc>
	 * Read-only, returns the height of the domElement
	 * + vertical paddings + vertical margins
	 </haxe_doc>
		</offsetHeight>
		<_style>
			<t path="cocktailCore.style.Style"/>
			<haxe_doc>
	 * This Style object stores the styles of
	 * a DOMElement and manages how they are applied
	 </haxe_doc>
		</_style>
		<style public="1" get="getStyle" set="null"><t path="cocktailCore.style.Style"/></style>
		<matrix public="1" get="getMatrix" set="setMatrix">
			<c path="cocktail.geom.Matrix"/>
			<haxe_doc>
	 * get/set this domElement 2d transformation matrix
	 </haxe_doc>
		</matrix>
		<scaleX public="1" get="getScaleX" set="setScaleX">
			<c path="Float"/>
			<haxe_doc>
	 * get/set x scale
	 </haxe_doc>
		</scaleX>
		<scaleY public="1" get="getScaleY" set="setScaleY">
			<c path="Float"/>
			<haxe_doc>
	 * get/set y scale
	 </haxe_doc>
		</scaleY>
		<rotation public="1" get="getRotation" set="setRotation">
			<c path="Int"/>
			<haxe_doc>
	 * get/set the rotation in deg (0 to 360)
	 </haxe_doc>
		</rotation>
		<alpha public="1" get="getAlpha" set="setAlpha">
			<c path="Float"/>
			<haxe_doc>
	 * The opacity of the DOM Object, from 0 to 1
	 </haxe_doc>
		</alpha>
		<isVisible public="1" get="getIsVisible" set="setIsVisible">
			<e path="Bool"/>
			<haxe_doc>
	 * Wheter the DOMElement is visible
	 </haxe_doc>
		</isVisible>
		<zIndex public="1" get="getZIndex" set="setZIndex">
			<c path="Int"/>
			<haxe_doc>
	 * The z-index of this DOM Object, relative to
	 * its parent (the first child of a ContainerDOMElement always has
	 * a 0 z-index)
	 </haxe_doc>
		</zIndex>
		<init set="method" line="247">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * Init the DOMElement properties. Called each time
	 * the NativeElement is set
	 </haxe_doc>
		</init>
		<initStyle set="method" line="265">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * Instantiate the right style object for this
	 * DOMElement. Overriden by DOMElements with
	 * specific style objects, such as ContainerDOMElement
	 </haxe_doc>
		</initStyle>
		<getParent set="method" line="278">
			<f a=""><t path="cocktail.domElement.ContainerDOMElement"/></f>
			<haxe_doc>
	 * Returns the parent of this DOMElement
	 </haxe_doc>
		</getParent>
		<setParent set="method" line="286">
			<f a="domElement">
				<t path="cocktail.domElement.ContainerDOMElement"/>
				<t path="cocktail.domElement.ContainerDOMElement"/>
			</f>
			<haxe_doc>
	 * set the parent of this DOMElement
	 </haxe_doc>
		</setParent>
		<setNativeElement set="method" line="296">
			<f a="value">
				<t path="cocktail.nativeElement.NativeElement"/>
				<t path="cocktail.nativeElement.NativeElement"/>
			</f>
			<haxe_doc>
	 * set the reference to this DOMElement NativeElement
	 * @return a DisplayObject in AS, an HTML element in JS, a resource in PHP
	 </haxe_doc>
		</setNativeElement>
		<getNativeElement set="method" line="308">
			<f a=""><t path="cocktail.nativeElement.NativeElement"/></f>
			<haxe_doc>
	 * Returns the reference to this DOMElement native DOM element
	 * @return a DisplayObject in AS, an HTML element in JS, a resource in PHP
	 </haxe_doc>
		</getNativeElement>
		<setIsVisible set="method" line="322">
			<f a="value">
				<e path="Bool"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
	 * Show or hide the native DOMElement.
	 * @param	value true if the DOM object must be visible
	 </haxe_doc>
		</setIsVisible>
		<getIsVisible set="method" line="340">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>
	 * Return wether the DOMElement is visible.
	 </haxe_doc>
		</getIsVisible>
		<setAlpha set="method" line="349">
			<f a="value">
				<c path="Float"/>
				<c path="Float"/>
			</f>
			<haxe_doc>
	 * Set the opacity of the DOMElement
	 * @param	value from 0 (transparent) to 1 (opaque)
	 </haxe_doc>
		</setAlpha>
		<getAlpha set="method" line="359">
			<f a=""><c path="Float"/></f>
			<haxe_doc>
	 * returns the opacity of the DOMElement, 
	 * from 0 to 1
	 </haxe_doc>
		</getAlpha>
		<setMatrix set="method" line="372">
			<f a="matrix">
				<c path="cocktail.geom.Matrix"/>
				<c path="cocktail.geom.Matrix"/>
			</f>
			<haxe_doc>
	 * Set the transformation matrix of this DOMElement.
	 </haxe_doc>
		</setMatrix>
		<getMatrix set="method" line="381">
			<f a=""><c path="cocktail.geom.Matrix"/></f>
			<haxe_doc>
	 * Return this DOMElement matrix
	 </haxe_doc>
		</getMatrix>
		<setScaleX set="method" line="390">
			<f a="scaleX">
				<c path="Float"/>
				<c path="Float"/>
			</f>
			<haxe_doc>
	 * set the absolute x scale of the domElement
	 * @param	scaleX the target x scale
	 </haxe_doc>
		</setScaleX>
		<getScaleX set="method" line="402">
			<f a=""><c path="Float"/></f>
			<haxe_doc>
	 * Return the current x scale
	 * @return a float, 1 corresponds to no x scale
	 </haxe_doc>
		</getScaleX>
		<setScaleY set="method" line="410">
			<f a="scaleY">
				<c path="Float"/>
				<c path="Float"/>
			</f>
			<haxe_doc>
	 * set the absolute y scale of the domElement
	 * @param	scaleX the target y scale
	 </haxe_doc>
		</setScaleY>
		<getScaleY set="method" line="422">
			<f a=""><c path="Float"/></f>
			<haxe_doc>
	 * Return the current y scale
	 * @return a float, 1 corresponds to no y scale
	 </haxe_doc>
		</getScaleY>
		<setRotation set="method" line="431">
			<f a="angle">
				<c path="Int"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
	 * Set the rotation to an absolute angle instead of adding a rotation to the existing 
	 * rotation
	 * @param	angle the target angle
	 </haxe_doc>
		</setRotation>
		<getRotation set="method" line="443">
			<f a=""><c path="Int"/></f>
			<haxe_doc>
	 * Return the current rotation angle in deg
	 * @return an Int from 0 to 360
	 </haxe_doc>
		</getRotation>
		<updateTransforms set="method" line="452">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * Utils method updating the set of transforms
	 * to apply when the rotation, scaleX or scaleY changes
	 </haxe_doc>
		</updateTransforms>
		<setOnMouseDown set="method" line="475"><f a="value">
	<f a="">
		<t path="cocktail.mouse.MouseEventData"/>
		<e path="Void"/>
	</f>
	<f a="">
		<t path="cocktail.mouse.MouseEventData"/>
		<e path="Void"/>
	</f>
</f></setOnMouseDown>
		<getOnMouseDown set="method" line="481"><f a=""><f a="">
	<t path="cocktail.mouse.MouseEventData"/>
	<e path="Void"/>
</f></f></getOnMouseDown>
		<setOnMouseUp set="method" line="486"><f a="value">
	<f a="">
		<t path="cocktail.mouse.MouseEventData"/>
		<e path="Void"/>
	</f>
	<f a="">
		<t path="cocktail.mouse.MouseEventData"/>
		<e path="Void"/>
	</f>
</f></setOnMouseUp>
		<getOnMouseUp set="method" line="492"><f a=""><f a="">
	<t path="cocktail.mouse.MouseEventData"/>
	<e path="Void"/>
</f></f></getOnMouseUp>
		<setOnMouseOver set="method" line="497"><f a="value">
	<f a="">
		<t path="cocktail.mouse.MouseEventData"/>
		<e path="Void"/>
	</f>
	<f a="">
		<t path="cocktail.mouse.MouseEventData"/>
		<e path="Void"/>
	</f>
</f></setOnMouseOver>
		<getOnMouseOver set="method" line="503"><f a=""><f a="">
	<t path="cocktail.mouse.MouseEventData"/>
	<e path="Void"/>
</f></f></getOnMouseOver>
		<setOnMouseOut set="method" line="508"><f a="value">
	<f a="">
		<t path="cocktail.mouse.MouseEventData"/>
		<e path="Void"/>
	</f>
	<f a="">
		<t path="cocktail.mouse.MouseEventData"/>
		<e path="Void"/>
	</f>
</f></setOnMouseOut>
		<getOnMouseOut set="method" line="514"><f a=""><f a="">
	<t path="cocktail.mouse.MouseEventData"/>
	<e path="Void"/>
</f></f></getOnMouseOut>
		<setOnMouseMove set="method" line="519"><f a="value">
	<f a="">
		<t path="cocktail.mouse.MouseEventData"/>
		<e path="Void"/>
	</f>
	<f a="">
		<t path="cocktail.mouse.MouseEventData"/>
		<e path="Void"/>
	</f>
</f></setOnMouseMove>
		<getOnMouseMove set="method" line="525"><f a=""><f a="">
	<t path="cocktail.mouse.MouseEventData"/>
	<e path="Void"/>
</f></f></getOnMouseMove>
		<setOnMouseDoubleClick set="method" line="530"><f a="value">
	<f a="">
		<t path="cocktail.mouse.MouseEventData"/>
		<e path="Void"/>
	</f>
	<f a="">
		<t path="cocktail.mouse.MouseEventData"/>
		<e path="Void"/>
	</f>
</f></setOnMouseDoubleClick>
		<getOnMouseDoubleClick set="method" line="536"><f a=""><f a="">
	<t path="cocktail.mouse.MouseEventData"/>
	<e path="Void"/>
</f></f></getOnMouseDoubleClick>
		<setOnKeyDown set="method" line="546"><f a="value">
	<f a="">
		<t path="cocktail.keyboard.KeyEventData"/>
		<e path="Void"/>
	</f>
	<f a="">
		<t path="cocktail.keyboard.KeyEventData"/>
		<e path="Void"/>
	</f>
</f></setOnKeyDown>
		<getOnKeyDown set="method" line="552"><f a=""><f a="">
	<t path="cocktail.keyboard.KeyEventData"/>
	<e path="Void"/>
</f></f></getOnKeyDown>
		<setOnKeyUp set="method" line="557"><f a="value">
	<f a="">
		<t path="cocktail.keyboard.KeyEventData"/>
		<e path="Void"/>
	</f>
	<f a="">
		<t path="cocktail.keyboard.KeyEventData"/>
		<e path="Void"/>
	</f>
</f></setOnKeyUp>
		<getOnKeyUp set="method" line="563"><f a=""><f a="">
	<t path="cocktail.keyboard.KeyEventData"/>
	<e path="Void"/>
</f></f></getOnKeyUp>
		<setField set="method" line="578">
			<f a="propertyName:propertyValue">
				<c path="String"/>
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Set a field value on the nativeElement
	 * @param	propertyName the name of the field
	 * @param	propertyValue the new value of the field
	 </haxe_doc>
		</setField>
		<getField set="method" line="588">
			<f a="propertyName">
				<c path="String"/>
				<d/>
			</f>
			<haxe_doc>
	 * Return the value of a field of the nativeElement
	 * @param	propertyName the name of the field value to return
	 * @return might be any type
	 </haxe_doc>
		</getField>
		<setX set="method" line="601">
			<f a="value">
				<c path="Int"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
	 * update the left style, triggering a layout of the document
	 </haxe_doc>
		</setX>
		<getX set="method" line="611">
			<f a=""><c path="Int"/></f>
			<haxe_doc>
	 * return the x of the nativeElement, relative to its parent
	 </haxe_doc>
		</getX>
		<setY set="method" line="619">
			<f a="value">
				<c path="Int"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
	 * update the top style, triggering a layout of the document
	 </haxe_doc>
		</setY>
		<getY set="method" line="629">
			<f a=""><c path="Int"/></f>
			<haxe_doc>
	 * return the y of the nativeElement, relative to its parent
	 </haxe_doc>
		</getY>
		<setWidth set="method" line="637">
			<f a="value">
				<c path="Int"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
	 * update the width style, triggering a layout of the document
	 </haxe_doc>
		</setWidth>
		<getWidth set="method" line="647">
			<f a=""><c path="Int"/></f>
			<haxe_doc>
	 * return the width of the nativeElement
	 </haxe_doc>
		</getWidth>
		<setHeight set="method" line="655">
			<f a="value">
				<c path="Int"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
	 * update the height style, triggering a layout of the document
	 </haxe_doc>
		</setHeight>
		<getHeight set="method" line="665">
			<f a=""><c path="Int"/></f>
			<haxe_doc>
	 * return the height of the nativeElement
	 </haxe_doc>
		</getHeight>
		<getOffsetWidth set="method" line="674">
			<f a=""><c path="Int"/></f>
			<haxe_doc>
	 * constructs the offset width from the computed
	 * box of this domElement
	 </haxe_doc>
		</getOffsetWidth>
		<getOffsetHeight set="method" line="684">
			<f a=""><c path="Int"/></f>
			<haxe_doc>
	 * constructs the offset height from the computed
	 * box of this domElement
	 </haxe_doc>
		</getOffsetHeight>
		<setGlobalX set="method" line="701">
			<f a="value">
				<c path="Int"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
	 * Get a global x position (relative to the root DOMElement)
	 * and convert to an x position relative to the parent DOMElement
	 * @param	value the new x position of the DOMElement
	 </haxe_doc>
		</setGlobalX>
		<getGlobalX set="method" line="735">
			<f a=""><c path="Int"/></f>
			<haxe_doc>
	 * Return the x position of this DOMElement relative
	 * to the root DOMElement x position
	 </haxe_doc>
		</getGlobalX>
		<setGlobalY set="method" line="770">
			<f a="value">
				<c path="Int"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
	 * Set the DOMElement y position relative to the root DOMElement
	 * y position
	 * @param	value the new y position of the DOMElement
	 </haxe_doc>
		</setGlobalY>
		<getGlobalY set="method" line="794">
			<f a=""><c path="Int"/></f>
			<haxe_doc>
	 * Return the y position of this DOMElement relative
	 * to the root DOMElement y position
	 </haxe_doc>
		</getGlobalY>
		<setZIndex set="method" line="821"><f a="value">
	<c path="Int"/>
	<c path="Int"/>
</f></setZIndex>
		<getZIndex set="method" line="826"><f a=""><c path="Int"/></f></getZIndex>
		<getStyle set="method" line="835"><f a=""><t path="cocktailCore.style.Style"/></f></getStyle>
		<new public="1" set="method" line="233">
			<f a="?nativeElement">
				<t path="cocktail.nativeElement.NativeElement"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * class constructor. Stores the reference to the
	 * native element triggering the initialisation
	 * of the DOMElement
	 </haxe_doc>
		</new>
		<haxe_doc><![CDATA[
 * This is the base class for all DOMElements. A DOMElement is an abstraction of the visual base element of a runtime.
 * For instance in JS, a DOMElement is an HTML element, like a <div> or <img> element. In Flash AS3, a domElement is a DisplayObject.
 * This class abstracts manipulating DOM elements, each runtime implemented in a sub-class.
 * 
 * @author Yannick DOMINGUEZ
 ]]></haxe_doc>
	</class>
	<class path="cocktailCore.domElement.js.DOMElement" params="" file="/Users/lexa/Documents/repositories/lexoyo_Cocktail/demo/games/libs/cocktailCore/domElement/js/DOMElement.hx">
		<extends path="cocktailCore.domElement.abstract.AbstractDOMElement"/>
		<setZIndex set="method" line="49" override="1">
			<f a="value">
				<c path="Int"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
	 * When setting the z-index on an HTML element,
	 * all the siblings z-indexes must be updated. If they
	 * are superior or equal to the z-index set on the current element,
	 * they are incremented
	 * @param	value the z index to set
	 </haxe_doc>
		</setZIndex>
		<getZIndex set="method" line="109" override="1"><f a=""><c path="Int"/></f></getZIndex>
		<new public="1" set="method" line="32">
			<f a="?nativeElement">
				<t path="cocktail.nativeElement.NativeElement"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Class constructor
	 </haxe_doc>
		</new>
		<haxe_doc>
 * This is the DOMElement implementation for JavaScript. 
 * It manipulates the native HTML DOM
 * @author Yannick DOMINGUEZ
 </haxe_doc>
	</class>
	<class path="cocktailCore.domElement.abstract.AbstractEmbeddedDOMElement" params="" file="/Users/lexa/Documents/repositories/lexoyo_Cocktail/demo/games/libs/cocktailCore/domElement/abstract/AbstractEmbeddedDOMElement.hx">
		<extends path="cocktailCore.domElement.js.DOMElement"/>
		<_intrinsicWidth>
			<t path="Null"><c path="Int"/></t>
			<haxe_doc>
	 * The instrinsic width of an embedded content. For example, for a video, the width
	 * in pixel of the video
	 </haxe_doc>
		</_intrinsicWidth>
		<intrinsicWidth public="1" get="getIntrinsicWidth" set="null"><t path="Null"><c path="Int"/></t></intrinsicWidth>
		<_intrinsicHeight>
			<t path="Null"><c path="Int"/></t>
			<haxe_doc>
	 * The instrinsic height of an embedded content. For example, for a video, the height
	 * in pixel of the video
	 </haxe_doc>
		</_intrinsicHeight>
		<intrinsicHeight public="1" get="getIntrinsicHeight" set="null"><t path="Null"><c path="Int"/></t></intrinsicHeight>
		<_intrinsicRatio>
			<t path="Null"><c path="Float"/></t>
			<haxe_doc>
	 * The instrinsic ratio of an embedded content. For example, for a video, the height/width
	 * ratio of the video
	 </haxe_doc>
		</_intrinsicRatio>
		<intrinsicRatio public="1" get="getIntrinsicRatio" set="null"><t path="Null"><c path="Float"/></t></intrinsicRatio>
		<initStyle set="method" line="63" override="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * Override to instantiate an embedded DOMElement specific 
	 * style manager
	 </haxe_doc>
		</initStyle>
		<getIntrinsicWidth set="method" line="72"><f a=""><t path="Null"><c path="Int"/></t></f></getIntrinsicWidth>
		<getIntrinsicHeight set="method" line="77"><f a=""><t path="Null"><c path="Int"/></t></f></getIntrinsicHeight>
		<getIntrinsicRatio set="method" line="82"><f a=""><t path="Null"><c path="Float"/></t></f></getIntrinsicRatio>
		<new public="1" set="method" line="54">
			<f a="?nativeElement">
				<t path="cocktail.nativeElement.NativeElement"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Constructor. Init the default intrinsic dimensions of the DOMElement
	 </haxe_doc>
		</new>
		<haxe_doc>
 * A base DOMElement class for embedded content such as picture or video. An embedded element, also called a
 * replaced element in HTML, typically has an intrinsic width, height and ratio. 
 * For example, for a picture it corresponds to the displayed picture's dimensions in pixel.
 * 
 * @author Yannick DOMINGUEZ
 </haxe_doc>
	</class>
	<class path="cocktailCore.domElement.js.EmbeddedDOMElement" params="" file="/Users/lexa/Documents/repositories/lexoyo_Cocktail/demo/games/libs/cocktailCore/domElement/js/EmbeddedDOMElement.hx">
		<extends path="cocktailCore.domElement.abstract.AbstractEmbeddedDOMElement"/>
		<new public="1" set="method" line="21"><f a="?nativeElement">
	<t path="cocktail.nativeElement.NativeElement"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>
 * This is theJavaScript implementation of the Embedded DOMElement
 * 
 * @author Yannick DOMINGUEZ
 </haxe_doc>
	</class>
	<class path="cocktailCore.domElement.abstract.AbstractGraphicDOMElement" params="" file="/Users/lexa/Documents/repositories/lexoyo_Cocktail/demo/games/libs/cocktailCore/domElement/abstract/AbstractGraphicDOMElement.hx">
		<extends path="cocktailCore.domElement.js.EmbeddedDOMElement"/>
		<beginFill public="1" set="method" line="75">
			<f a="?fillStyle:?lineStyle">
				<e path="cocktail.domElement.FillStyleValue"/>
				<e path="cocktail.domElement.LineStyleValue"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Starts a  fill used when drawing a shape with subsequent calls to lineTo,
	 * moveTo or curveTo. The fill remain in effect until endFill  
	 * is called. 
	 * @param	fillStyle the data used to draw the fill. Default to none
	 * @param	lineStyle the data used to draw the fill stroke/line. Default to none
	 </haxe_doc>
		</beginFill>
		<endFill public="1" set="method" line="99">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * Ends a fill started with beginFill and draw the shape and line defined by the path formed by the 
	 * linetTo, moveTo and curveTo methods onto the graphical container.
	 </haxe_doc>
		</endFill>
		<clear public="1" set="method" line="107">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * Clears the current shape and line of the graphic DOMElement.
	 </haxe_doc>
		</clear>
		<setLineStyle set="method" line="120">
			<f a="lineStyle">
				<e path="cocktail.domElement.LineStyleValue"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Do set the line style on the DOMElement
	 * @param	lineStyle
	 </haxe_doc>
		</setLineStyle>
		<setFillStyle set="method" line="129">
			<f a="fillStyle">
				<e path="cocktail.domElement.FillStyleValue"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Do set the fill style on the DOMElement
	 * @param	fillStyle
	 </haxe_doc>
		</setFillStyle>
		<drawRect public="1" set="method" line="148">
			<f a="x:y:width:height:?cornerRadiuses">
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<t path="cocktail.domElement.CornerRadiusData"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * High level method to draw a rectangle which may have rounded corners. 
	 * Needs to be called after beginFill or beginGradientFill was called.
	 * @param	x the left point of the rectangle
	 * @param	y the top point of the rectangle
	 * @param	width the width of the rectangle
	 * @param	height the height of the rectangle
	 * @param	cornerRadiuses the corner radiuses values of the rectangle
	 </haxe_doc>
		</drawRect>
		<drawEllipse public="1" set="method" line="188">
			<f a="x:y:width:height">
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * High level method to draw an ellipse or circle. 
	 * Needs to be called after beginFill or beginGradientFill was called.
	 * width and height must be equal to draw a circle.
	 * @param	x the left point of the ellipse
	 * @param	y the top point of the ellipse
	 * @param	width the width of the ellipse
	 * @param	height the height of ellipse
	 </haxe_doc>
		</drawEllipse>
		<drawImage public="1" set="method" line="230">
			<f a="source:?destinationPoint:?sourceRect">
				<t path="cocktail.domElement.ImageDOMElement"/>
				<t path="cocktail.geom.PointData"/>
				<t path="cocktail.geom.RectangleData"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Draw a bitmap extracted from an image dom element into the native graphic dom element. Alpha is preserved 
	 * for transparent bitmap
	 * @param	source the source image dom element containing the bitmap data
	 * @param	destinationPoint represent the top left point of the drawn image on the native graphic
	 * dom element. for instance a 0,0 point will draw the image in the top left corner of the graphic
	 * dom element. Takes 0,0 by default
	 * @param	sourceRect defines the zone from the source dom element that must be copied onto the 
	 * native graphic dom element. Takes the whole image by default
	 </haxe_doc>
		</drawImage>
		<lineTo public="1" set="method" line="246">
			<f a="x:y">
				<c path="Float"/>
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Draws a line from current drawing point to point x,y. 
	 * If a linestyle is defined for this Graphic DOMElement, draw a line with the current 
	 * linestyle from current point to point x,y. The current position becomes point x,y.
	 * @param	x target point x
	 * @param	y target point y
	 </haxe_doc>
		</lineTo>
		<moveTo public="1" set="method" line="256">
			<f a="x:y">
				<c path="Float"/>
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Moves the current drawing point to position x,y without drawing a line.
	 * @param	x target point x
	 * @param	y target point y
	 </haxe_doc>
		</moveTo>
		<curveTo public="1" set="method" line="270">
			<f a="controlX:controlY:x:y">
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Draws a curve from current drawing point to point x,y using the 
	 * controlX,controlY as control point. The curve drawn is a quadratic
	 * bezier curve
	 * @param	controlX
	 * @param	controlY
	 * @param	x
	 * @param	y
	 </haxe_doc>
		</curveTo>
		<toNativeAlpha set="method" line="285">
			<f a="genericAlpa">
				<c path="Int"/>
				<d/>
			</f>
			<haxe_doc>
	 * Converts the generic alpha value to a runtime 
	 * specific one
	 * @return returns a dynamic as it may be a float
	 </haxe_doc>
		</toNativeAlpha>
		<toNativeColor set="method" line="295">
			<f a="genericColor">
				<c path="Int"/>
				<d/>
			</f>
			<haxe_doc>
	 * Converts the generic color value to a runtime specifc
	 * one
	 * @return return a dynamic as color can be represented as a String
	 </haxe_doc>
		</toNativeColor>
		<toNativeRatio set="method" line="305">
			<f a="genericRatio">
				<c path="Int"/>
				<d/>
			</f>
			<haxe_doc>
	 * Converts the generic gradient ratio value to a runtime 
	 * specific one
	 * @return a dynamic, as it may be a float
	 </haxe_doc>
		</toNativeRatio>
		<toNativeCapStyle set="method" line="315">
			<f a="genericCapStyle">
				<e path="cocktail.domElement.CapsStyleValue"/>
				<d/>
			</f>
			<haxe_doc>
	 * Converts the generic cap style value to a runtime
	 * specific one
	 * @return a dynamic, as it may be an enum or string
	 </haxe_doc>
		</toNativeCapStyle>
		<toNativeJointStyle set="method" line="325">
			<f a="genericJointStyle">
				<e path="cocktail.domElement.JointStyleValue"/>
				<d/>
			</f>
			<haxe_doc>
	 * Converts a generic joint style value to a runtime 
	 * specific one
	 * @return a dynamic, as it may be an enum or string
	 </haxe_doc>
		</toNativeJointStyle>
		<new public="1" set="method" line="44">
			<f a="?nativeElement">
				<t path="cocktail.nativeElement.NativeElement"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * class constructor
	 * 
	 * Init the default intrinsic width, height and ratio.
	 * 
	 * By convention a GraphicDOMElement dimensions is
	 * 300 * 150 by default, according to the HTML5 Canvas
	 * element specifications
	 </haxe_doc>
		</new>
		<haxe_doc>
 * The graphic DOMElement is used as a canvas to draw bitmap graphics programmatically. 
 * 
 * It is an abstraction of Flash and JavaScript respective drawing APIs. 
 * It was at first considered to only have a drawing API in a separate
 * package which could have been leveraged by each of the DOMElements,
 * but unlike Flash where every Sprite can be used to draw graphics,
 * in HTML graphics can only be drawn on a canvas element. As a result, 
 * drawing is only available on the graphics DOMElement as in HTML
 * we need to make sure that the native DOM element is a canvas.
 * 
 * @author Yannick DOMINGUEZ
 </haxe_doc>
	</class>
	<class path="cocktail.geom.Matrix" params="" file="/Users/lexa/Documents/repositories/lexoyo_Cocktail/demo/games/libs/cocktail/geom/Matrix.hx">
		<_data>
			<t path="cocktail.geom.MatrixData"/>
			<haxe_doc>
	 * Stores each value of this 3x3 matrix
	 </haxe_doc>
		</_data>
		<data public="1" get="getData" set="setData"><t path="cocktail.geom.MatrixData"/></data>
		<identity public="1" set="method" line="47">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * Reset the matrix to an identity matrix (no transformations)
	 </haxe_doc>
		</identity>
		<setData set="method" line="65">
			<f a="data">
				<t path="cocktail.geom.MatrixData"/>
				<t path="cocktail.geom.MatrixData"/>
			</f>
			<haxe_doc>
	 * Set the values of this 3x3 matrix, fall back to an
	 * identity matrix if null
	 * 
	 * @param contains 6 values
	 </haxe_doc>
		</setData>
		<getData set="method" line="82">
			<f a=""><t path="cocktail.geom.MatrixData"/></f>
			<haxe_doc>
	 * Return this matrix data
	 * @return the 6 values of this 3x3 matrix
	 </haxe_doc>
		</getData>
		<concatenate public="1" set="method" line="98">
			<f a="matrix">
				<c path="cocktail.geom.Matrix"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Concatenate the matrix values by multiplying them.
	 * 
	 * @example If matrix1 rotate an object by 45
	 * degrees and matrix2 scale an object by a factor of 2,
	 * then the resulting concatenated matrix
	 * will both rotate and scale the object with the same values.
	 * 
	 * @param	matrix the matrix to concatenate with the current
	 * matrix
	 </haxe_doc>
		</concatenate>
		<translate public="1" set="method" line="136">
			<f a="x:y">
				<c path="Float"/>
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Apply a transformation translating the matrix with the given x and y offsets.
	 * 
	 * @param	x the translation along the x axis
	 * @param	y the translation along the y axis
	 </haxe_doc>
		</translate>
		<rotate public="1" set="method" line="164">
			<f a="angle:registrationPoint">
				<c path="Float"/>
				<t path="cocktail.geom.PointData"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Apply a transformation rotating the matrix using the specified angle (in rad), using 
	 * registrationPoint as rotation center.
	 * 
	 * @param angle the rotation angle in rad
	 * @param registrationPoint the pivot point
	 </haxe_doc>
		</rotate>
		<scale public="1" set="method" line="236">
			<f a="scaleX:scaleY:registrationPoint">
				<c path="Float"/>
				<c path="Float"/>
				<t path="cocktail.geom.PointData"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Apply a transformation scaling the matrix by the "scaleX" and "scaleY" factor, using 
	 * "registrationPoint" as scaling center.
	 * 
	 * @param scaleX horizontal scale factor
	 * @param scaleY vertical scale factor
	 * @param transformOrigin the scale center
	 </haxe_doc>
		</scale>
		<skew public="1" set="method" line="279">
			<f a="skewX:skewY:registrationPoint">
				<c path="Float"/>
				<c path="Float"/>
				<t path="cocktail.geom.PointData"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Apply a transformation skewing the matrix by the "skewX" and "skewY"
	 * factor, using "registrationPoint" as skewing center.
	 * 
	 * @param skewX the horizontal skew factor
	 * @param skewY the vertical skew factor
	 * @param transformOrigin the skew center
	 </haxe_doc>
		</skew>
		<setRotation public="1" set="method" line="324">
			<f a="angle:registrationPoint">
				<c path="Float"/>
				<t path="cocktail.geom.PointData"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Set the rotation of the matrix to an absolute value instead of adding a rotation
	 * to an existing rotation. Preserve the existing transformations
	 * @param	angle the angle that must be applied (in rad)
	 * @param	registrationPoint the rotation center
	 </haxe_doc>
		</setRotation>
		<getRotation public="1" set="method" line="343">
			<f a=""><c path="Float"/></f>
			<haxe_doc>
	 * return an estimation of the current matrix rotation in rad. 
	 * This method assumes that the matrix has not been skewed
	 </haxe_doc>
		</getRotation>
		<getFlip set="method" line="380">
			<f a=""><c path="Int"/></f>
			<haxe_doc>
	 * Returns wether an axis has
	 * been flipped
	 * @return -1 if it has else 1 
	 </haxe_doc>
		</getFlip>
		<setScaleX public="1" set="method" line="429">
			<f a="scaleXFactor:registrationPoint">
				<c path="Float"/>
				<t path="cocktail.geom.PointData"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Set the absolut scale x value instead of adding it to the
	 * current scale x value
	 * @param	scaleXFactor the target scale x
	 * @param	registrationPoint the scale center
	 </haxe_doc>
		</setScaleX>
		<getScaleX public="1" set="method" line="446">
			<f a=""><c path="Float"/></f>
			<haxe_doc>
	 * Return the current X scale of the matrix
	 </haxe_doc>
		</getScaleX>
		<setScaleY public="1" set="method" line="457">
			<f a="scaleYFactor:registrationPoint">
				<c path="Float"/>
				<t path="cocktail.geom.PointData"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Set the absolut scale y value instead of adding it to the
	 * current scale y value
	 * @param	scaleXFactor the target scale y
	 * @param	registrationPoint the scale center
	 </haxe_doc>
		</setScaleY>
		<getScaleY public="1" set="method" line="474">
			<f a=""><c path="Float"/></f>
			<haxe_doc>
	 * Return the current Y scale of the matrix
	 </haxe_doc>
		</getScaleY>
		<setTranslationX public="1" set="method" line="484">
			<f a="translationX">
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Set the absolute x translation instead of adding it to the 
	 * current x translation
	 * @param	translationX the target x translation
	 </haxe_doc>
		</setTranslationX>
		<getTranslationX public="1" set="method" line="500">
			<f a=""><c path="Float"/></f>
			<haxe_doc>
	 * Return the current X translation of the matrix
	 </haxe_doc>
		</getTranslationX>
		<setTranslationY public="1" set="method" line="510">
			<f a="translationY">
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Set the absolute y translation instead of adding it to the 
	 * current y translation
	 * @param	translationY the target y translation
	 </haxe_doc>
		</setTranslationY>
		<getTranslationY public="1" set="method" line="526">
			<f a=""><c path="Float"/></f>
			<haxe_doc>
	 * Return the current Y translation of the matrix
	 </haxe_doc>
		</getTranslationY>
		<getSkewX public="1" set="method" line="534">
			<f a=""><c path="Float"/></f>
			<haxe_doc>
	 * Return the current x skew of the matrix
	 </haxe_doc>
		</getSkewX>
		<getSkewY public="1" set="method" line="542">
			<f a=""><c path="Float"/></f>
			<haxe_doc>
	 * Return the current y skew of the matrix
	 </haxe_doc>
		</getSkewY>
		<new public="1" set="method" line="35">
			<f a="?data">
				<t path="cocktail.geom.MatrixData"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Class constructor. Creates a 3x3 matrix with the given parameters.
	 * It defaults to an identity matrix (no transformations), if the given
	 * matrix data are null.
	 </haxe_doc>
		</new>
		<haxe_doc>
 * This class is an implementation of a 3x3 matrix. It is meant to be
 * cross-platform and as such doesn't rely on any runtime specific API.
 * 
 * It exposes method to create and manipulate a matrix which can then be 
 * used to apply 2d transformations to a DOMElement.
 * 
 * @author Yannick DOMINGUEZ
 </haxe_doc>
	</class>
	<class path="cocktailCore.style.js.BodyStyle" params="" file="/Users/lexa/Documents/repositories/lexoyo_Cocktail/demo/games/libs/cocktailCore/style/js/BodyStyle.hx">
		<extends path="cocktailCore.style.abstract.AbstractBodyStyle"/>
		<new public="1" set="method" line="24">
			<f a="domElement">
				<t path="cocktail.domElement.DOMElement"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * class constructor
	 * @param	domElement
	 </haxe_doc>
		</new>
		<haxe_doc>
 * This is the JavaScript implementation of the BodyStyle
 * 
 * @author Yannick DOMINGUEZ
 </haxe_doc>
	</class>
	<class path="cocktailCore.domElement.abstract.AbstractContainerDOMElement" params="" file="/Users/lexa/Documents/repositories/lexoyo_Cocktail/demo/games/libs/cocktailCore/domElement/abstract/AbstractContainerDOMElement.hx">
		<extends path="cocktailCore.domElement.js.DOMElement"/>
		<_semantic>
			<c path="String"/>
			<haxe_doc>
	 * Store the node name (div, nav, header...) of the
	 * first node of the reference to the native DOM.
	 </haxe_doc>
		</_semantic>
		<semantic public="1" get="getSemantic" set="setSemantic"><c path="String"/></semantic>
		<_children>
			<c path="Array"><t path="cocktailCore.domElement.ContainerDOMElementChildData"/></c>
			<haxe_doc>
	 * a reference to each of the ContainerDOMElement children which
	 * can be either of type DOMElement or TextElement.
	 * Their order is significant to the layout of the document
	 </haxe_doc>
		</_children>
		<children public="1" get="getChildren" set="null"><c path="Array"><t path="cocktailCore.domElement.ContainerDOMElementChildData"/></c></children>
		<_textFragmentDOMElements>
			<c path="Array"><t path="cocktailCore.domElement.TextFragmentDOMElement"/></c>
			<haxe_doc>
	 * Stores each of the text fragments generated at layout so they 
	 * can easily be removed when the text content changes or when a
	 * text style of the ContainerDOMElement changes
	 </haxe_doc>
		</_textFragmentDOMElements>
		<initStyle set="method" line="82" override="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * Override to instantiate a Container specific 
	 * style manager
	 </haxe_doc>
		</initStyle>
		<addChild public="1" set="method" line="98">
			<f a="domElement">
				<c path="cocktailCore.domElement.js.DOMElement"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Set the current ContainerDOMElement as the parent of the added domElement, and 
	 * store it in the children array. Overriden by each runtime, to add the
	 * child to native DOM.
	 * @param	domElement the DOMElement to attach to this ContainerDOMElement
	 </haxe_doc>
		</addChild>
		<removeChild public="1" set="method" line="111">
			<f a="domElement">
				<c path="cocktailCore.domElement.js.DOMElement"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Reset the parent of the removed child object as it no longer is attached
	 * to the DOM, remove it also from the children array. Overriden by each
	 * runtime to remove also from the native DOM
	 * @param	domElement the DOMElement to remove from this ContainerDOMElement
	 </haxe_doc>
		</removeChild>
		<addText public="1" set="method" line="134">
			<f a="textElement">
				<t path="cocktail.textElement.TextElement"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Add a TextElement as a children of the ContainerDOMElement.
	 * The TextElement will be rendered as textFragmentDOMElements, at
	 * layout time, as many as necessary to render the full TextElement's
	 * text
	 * @param	textElementData
	 </haxe_doc>
		</addText>
		<removeText public="1" set="method" line="143">
			<f a="textElement">
				<t path="cocktail.textElement.TextElement"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Removes a TextElement from the ContainerDOMElement.
	 * @param	textElementData
	 </haxe_doc>
		</removeText>
		<getChildren set="method" line="161">
			<f a=""><c path="Array"><t path="cocktailCore.domElement.ContainerDOMElementChildData"/></c></f>
			<haxe_doc>
	 * returns the children of this ContainerDOMElement
	 * @return an array containing any number of TextElement
	 * and DOMElements
	 </haxe_doc>
		</getChildren>
		<resetTextFragments public="1" set="method" line="178">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * Removes all the previously added text fragments. Occurs
	 * when the content of a textElement changes or a text style
	 * of the ContainerDOMElement changes, thus changing
	 * the textElement display
	 </haxe_doc>
		</resetTextFragments>
		<addTextFragment public="1" set="method" line="203">
			<f a="textFragmentDOMElement">
				<t path="cocktailCore.domElement.TextFragmentDOMElement"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Stores a reference to a generated TextFragmentDOMElement. Overriden by each runtime
	 * to attach the native text line to the native element of the container
	 </haxe_doc>
		</addTextFragment>
		<removeTextFragment set="method" line="212">
			<f a="textFragmentDOMElement">
				<t path="cocktailCore.domElement.TextFragmentDOMElement"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Removes a stored reference to a generated TextFragmentDOMElement. Overriden by each runtime
	 * to remove the native text line from the native element of the container
	 </haxe_doc>
		</removeTextFragment>
		<setSemantic set="method" line="225">
			<f a="semantic">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
	 * Set the semantic name of the first native node
	 * @param	semantic an HTML tag name (div, nav, header...)
	 </haxe_doc>
		</setSemantic>
		<getSemantic set="method" line="235">
			<f a=""><c path="String"/></f>
			<haxe_doc>
	 * Return the semantic name of the first native node
	 * @return	semantic an HTML tag name (div, nav, header...)
	 </haxe_doc>
		</getSemantic>
		<new public="1" set="method" line="62">
			<f a="?nativeElement">
				<t path="cocktail.nativeElement.NativeElement"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * class constructor. Create a container NativeElement
	 * if none is provided
	 </haxe_doc>
		</new>
		<haxe_doc>
 * This is a DOMElement which can contain both DOMElement and TextElement, it is in charge of building the DOMElement tree.
 * A ContainerDOMElement can receive any other type of DOMElement as children.
 * A TextElement is a reference to a simple string of text which takes the visual style of its ContainerDOMElement. A TextElement can't have children.
 * Each ContainerDOMElement represents a semantic element in the DOMElement tree.
 * 
 * @author Yannick DOMINGUEZ
 </haxe_doc>
	</class>
	<class path="cocktailCore.domElement.js.ContainerDOMElement" params="" file="/Users/lexa/Documents/repositories/lexoyo_Cocktail/demo/games/libs/cocktailCore/domElement/js/ContainerDOMElement.hx">
		<extends path="cocktailCore.domElement.abstract.AbstractContainerDOMElement"/>
		<addChild public="1" set="method" line="47" override="1">
			<f a="domElement">
				<c path="cocktailCore.domElement.js.DOMElement"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Overriden to attach the native HTML element to the HTML DOM and
	 * to set the CSS z-index of the newly attached children
	 * @param	domElement the html element to add to this container
	 </haxe_doc>
		</addChild>
		<removeChild public="1" set="method" line="60" override="1">
			<f a="domElement">
				<c path="cocktailCore.domElement.js.DOMElement"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Overriden to remove the native HTML element from
	 * the HTML DOM
	 * @param domElement the html element to remove from this container
	 </haxe_doc>
		</removeChild>
		<addText public="1" set="method" line="71" override="1">
			<f a="textElement">
				<t path="cocktail.textElement.TextElement"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Overriden to append the textElement's NativeTextElement (an 
	 * HTML textNode) to the HTML element of this container
	 * @param	text the text node to append
	 </haxe_doc>
		</addText>
		<removeText public="1" set="method" line="82" override="1">
			<f a="textElement">
				<t path="cocktail.textElement.TextElement"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Overriden to remove the native HTML text node from the HTML element of this
	 * container
	 * @param	text the text node to remove
	 </haxe_doc>
		</removeText>
		<setSemantic set="method" line="97" override="1">
			<f a="semantic">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
	 * Set the semantic of this DOMElement and set it as the node name
	 * of the root tag of the nativeElement (which is an HTML tag)
	 * @param	semantic the new node name
	 </haxe_doc>
		</setSemantic>
		<new public="1" set="method" line="32">
			<f a="?nativeElement">
				<t path="cocktail.nativeElement.NativeElement"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * class constructor
	 </haxe_doc>
		</new>
		<haxe_doc>
 * This is the JavaScript implementation of the container DOMElement.
 * 
 * When it's semantic is set, it adds the JavaScript specific behaviour
 * of changing the root node type of the reference to the nativeElement
 * by setting it's node name
 * 
 * @author Yannick DOMINGUEZ
 </haxe_doc>
	</class>
	<class path="cocktailCore.domElement.abstract.AbstractBodyDOMElement" params="" file="/Users/lexa/Documents/repositories/lexoyo_Cocktail/demo/games/libs/cocktailCore/domElement/abstract/AbstractBodyDOMElement.hx">
		<extends path="cocktailCore.domElement.js.ContainerDOMElement"/>
		<_viewPort>
			<t path="cocktail.viewport.Viewport"/>
			<haxe_doc>
	 * A reference to the view port used to listen for
	 * resize events
	 </haxe_doc>
		</_viewPort>
		<initStyle set="method" line="50" override="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * Instantiate a Style specific to this
	 * DOMElement
	 </haxe_doc>
		</initStyle>
		<onViewPortResize set="method" line="65">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * When the view port is resized, insvalidate
	 * this BodyDOMElement to lay it out with
	 * the new view port dimensions
	 </haxe_doc>
		</onViewPortResize>
		<setX set="method" line="77" override="1">
			<f a="value">
				<c path="Int"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
	 * X can't be set
	 </haxe_doc>
		</setX>
		<setY set="method" line="85" override="1">
			<f a="value">
				<c path="Int"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
	 * Y can't be set
	 </haxe_doc>
		</setY>
		<setWidth set="method" line="93" override="1">
			<f a="value">
				<c path="Int"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
	 * Width can't be set
	 </haxe_doc>
		</setWidth>
		<setHeight set="method" line="101" override="1">
			<f a="value">
				<c path="Int"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
	 * height can't be set
	 </haxe_doc>
		</setHeight>
		<setIsVisible set="method" line="109" override="1">
			<f a="value">
				<e path="Bool"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
	 * visibility can't be set
	 </haxe_doc>
		</setIsVisible>
		<new public="1" set="method" line="41">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * class constructor. Retrieve the root of the
	 * runtime and set it as this DOMElement's
	 * NativeElement
	 </haxe_doc>
		</new>
		<haxe_doc>
 * This DOMElement is a secial ContainerDOMElement whose
 * NativeElement is always the root of the runtime (
 * for instance the Stage in Flash or the Body tag in
 * HTML.)
 * 
 * Some DOMElement behavior are not supported, like the
 * ability to set its width and height
 * 
 * @author Yannick DOMINGUEZ
 </haxe_doc>
	</class>
	<class path="cocktailCore.domElement.js.BodyDOMElement" params="" file="/Users/lexa/Documents/repositories/lexoyo_Cocktail/demo/games/libs/cocktailCore/domElement/js/BodyDOMElement.hx">
		<extends path="cocktailCore.domElement.abstract.AbstractBodyDOMElement"/>
		<new public="1" set="method" line="22">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * class constructor
	 </haxe_doc>
		</new>
		<haxe_doc>
 * This is the JavaScript implementation of the BodyDOMElement
 * 
 * @author Yannick DOMINGUEZ
 </haxe_doc>
	</class>
	<class path="cocktailCore.style.formatter.FormattingContext" params="" file="/Users/lexa/Documents/repositories/lexoyo_Cocktail/demo/games/libs/cocktailCore/style/formatter/FormattingContext.hx">
		<_containingDOMElement>
			<t path="cocktail.domElement.DOMElement"/>
			<haxe_doc>
	 * A reference to the DOMElement which started the
	 * formatting context.
	 </haxe_doc>
		</_containingDOMElement>
		<containingDOMElement public="1" get="getContainingDOMElement" set="null"><t path="cocktail.domElement.DOMElement"/></containingDOMElement>
		<_containingDOMElementWidth>
			<c path="Int"/>
			<haxe_doc>
	 * The width of the DOMElement starting the formatting context,
	 * represeting the maximum width of a line
	 </haxe_doc>
		</_containingDOMElementWidth>
		<_floatsManager>
			<c path="cocktailCore.style.floats.FloatsManager"/>
			<haxe_doc>
	 * An instance of the class managing the floated DOMElements.
	 </haxe_doc>
		</_floatsManager>
		<floatsManager public="1" get="getFloatsManager" set="null"><c path="cocktailCore.style.floats.FloatsManager"/></floatsManager>
		<_flowData>
			<t path="cocktailCore.style.FlowData"/>
			<haxe_doc>
	 * Contains the data necessary to place the DOMElements in flow, 
	 * such as the coordinates where to insert the next DOMElement
	 </haxe_doc>
		</_flowData>
		<flowData public="1" get="getFlowData" set="null"><t path="cocktailCore.style.FlowData"/></flowData>
		<initFlowData set="method" line="96">
			<f a="domElement">
				<t path="cocktail.domElement.DOMElement"/>
				<t path="cocktailCore.style.FlowData"/>
			</f>
			<haxe_doc>
	 * Init the flow data using the containing DOMElement's
	 * properties
	 </haxe_doc>
		</initFlowData>
		<insert public="1" set="method" line="129">
			<f a="domElement">
				<t path="cocktail.domElement.DOMElement"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Insert a DOMElement in the formatting context's
	 * flow
	 </haxe_doc>
		</insert>
		<insertSpace public="1" set="method" line="138">
			<f a="domElement">
				<t path="cocktail.domElement.DOMElement"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Insert a space character, wrapped in a DOMElement
	 * in the formatting context
	 </haxe_doc>
		</insertSpace>
		<insertTab public="1" set="method" line="147">
			<f a="domElement">
				<t path="cocktail.domElement.DOMElement"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Insert a tab character, wrapped in a DOMElement
	 * in the formatting context
	 </haxe_doc>
		</insertTab>
		<insertLineFeed public="1" set="method" line="156">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * Start a new line by inserting a new line
	 * control character
	 </haxe_doc>
		</insertLineFeed>
		<insertFloat public="1" set="method" line="165">
			<f a="domElement">
				<t path="cocktail.domElement.DOMElement"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Insert a floated DOMElement in the formatting
	 * context's flow
	 </haxe_doc>
		</insertFloat>
		<clearFloat public="1" set="method" line="179">
			<f a="clear:isFloat">
				<e path="cocktail.style.ClearStyleValue"/>
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Clear all the current left, or right or both floats.
	 * When floats are cleared, the flow y attribute is placed
	 * at the bottom of the last cleared float
	 </haxe_doc>
		</clearFloat>
		<retrieveFloats public="1" set="method" line="188">
			<f a="formattingContext">
				<c path="cocktailCore.style.formatter.FormattingContext"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Retrieve the floats from another formatting context
	 * which applies to this formatting context
	 </haxe_doc>
		</retrieveFloats>
		<destroy public="1" set="method" line="198">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * Called by a new formatting context
	 * to perform clean up before this
	 * formatting context gets destroyed
	 </haxe_doc>
		</destroy>
		<startNewLine set="method" line="217">
			<f a="domElementWidth:?isLastLine">
				<c path="Int"/>
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Start a new line in the formatting context. Lay out
	 * the current line before starting a new
	 * @param	domElementWidth the width of the DOMElement that triggered the new line,
	 * it is used to find the first y position in the flow with enough space to fit and
	 * thus start a new line
	 * @param	isLastLine wether the current line is the last line. If it is, the
	 * current line is laid out but no new line is actually started
	 </haxe_doc>
		</startNewLine>
		<doInsert set="method" line="226">
			<f a="domElement">
				<t path="cocktail.domElement.DOMElement"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Actually insert a DOMElement in the
	 * formatting context
	 </haxe_doc>
		</doInsert>
		<getRemainingLineWidth set="method" line="242">
			<f a=""><c path="Int"/></f>
			<haxe_doc>
	 * Return the width remaining in the current line
	 * of the formatting context
	 </haxe_doc>
		</getRemainingLineWidth>
		<place set="method" line="251">
			<f a="domElement">
				<t path="cocktail.domElement.DOMElement"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Place a DOMElement is the flow according to 
	 * a block or inline formatting scheme
	 </haxe_doc>
		</place>
		<placeFloat set="method" line="262">
			<f a="domElement:floatData">
				<t path="cocktail.domElement.DOMElement"/>
				<t path="cocktailCore.style.FloatData"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Place a floated DOMElement in the containing
	 * DOMElement. The position of the floated DOMElement
	 * change based on tht type of formatting context
	 * (block or inline)
	 </haxe_doc>
		</placeFloat>
		<removeFloats set="method" line="273">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * Removed the floats which don't influence the 
	 * flow anymore. A float don't influence the flow
	 * anymore once the flow place DOMElement's below it
	 </haxe_doc>
		</removeFloats>
		<getFloatsManager set="method" line="283"><f a=""><c path="cocktailCore.style.floats.FloatsManager"/></f></getFloatsManager>
		<getFlowData set="method" line="288"><f a=""><t path="cocktailCore.style.FlowData"/></f></getFlowData>
		<getContainingDOMElement set="method" line="293"><f a=""><t path="cocktail.domElement.DOMElement"/></f></getContainingDOMElement>
		<new public="1" set="method" line="69">
			<f a="domElement:?previousFormatingContext">
				<t path="cocktail.domElement.DOMElement"/>
				<c path="cocktailCore.style.formatter.FormattingContext"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Class constructor
	 * @param	domElement the containing DOMElement which starts the formatting context
	 * @param	previousFormatingContext the previous formatting context, used to retrieve
	 * floated DOMElement which still applies to the new formatting context
	 </haxe_doc>
		</new>
		<haxe_doc>
 * This is the base class for formatting context. The formatting context
 * classes are in charge of placing in-flow DOMElements in the document.
 * 
 * They can be placed following a block or inline formatting context.
 * In a block formatting, the DOMElements are placed on top of each
 * other, in an inline, they are placed next to each other.
 * 
 * Those classes also are in charge of placing floated DOMElement
 * in the document and keeping a reference to each of the floated
 * DOMElement's position.
 * 
 * @author Yannick DOMINGUEZ
 </haxe_doc>
	</class>
	<typedef path="cocktail.domElement.CornerRadiusData" params="" file="/Users/lexa/Documents/repositories/lexoyo_Cocktail/demo/games/libs/cocktail/domElement/DOMElementData.hx" module="cocktail.domElement.DOMElementData">
		<a>
			<trCornerRadius><c path="Int"/></trCornerRadius>
			<tlCornerRadius><c path="Int"/></tlCornerRadius>
			<brCornerRadius><c path="Int"/></brCornerRadius>
			<blCornerRadius><c path="Int"/></blCornerRadius>
		</a>
		<haxe_doc>
	 * Stores the corner radius values of a rounded rectangle
	 </haxe_doc>
	</typedef>
	<typedef path="cocktail.domElement.ColorStopData" params="" file="/Users/lexa/Documents/repositories/lexoyo_Cocktail/demo/games/libs/cocktail/domElement/DOMElementData.hx" module="cocktail.domElement.DOMElementData">
		<a>
			<color><c path="Int"/></color>
			<alpha><c path="Int"/></alpha>
		</a>
		<haxe_doc>
	 * Contains the data for a color, which can be
	 * used in a monochrome or gradient fill.
	 </haxe_doc>
	</typedef>
	<typedef path="cocktail.domElement.GradientStopData" params="" file="/Users/lexa/Documents/repositories/lexoyo_Cocktail/demo/games/libs/cocktail/domElement/DOMElementData.hx" module="cocktail.domElement.DOMElementData">
		<a>
			<ratio><c path="Int"/></ratio>
			<colorStop><t path="cocktail.domElement.ColorStopData"/></colorStop>
		</a>
		<haxe_doc>
	 * a unit element of a gradient. A gradient, is formed
	 * of multiple GradientStop
	 </haxe_doc>
	</typedef>
	<typedef path="cocktail.domElement.LineStyleData" params="" file="/Users/lexa/Documents/repositories/lexoyo_Cocktail/demo/games/libs/cocktail/domElement/DOMElementData.hx" module="cocktail.domElement.DOMElementData">
		<a>
			<thickness><c path="Int"/></thickness>
			<miterLimit><c path="Int"/></miterLimit>
			<jointStyle><e path="cocktail.domElement.JointStyleValue"/></jointStyle>
			<capStyle><e path="cocktail.domElement.CapsStyleValue"/></capStyle>
		</a>
		<haxe_doc>
	 * the style of a line other than it's color/fill
	 </haxe_doc>
	</typedef>
	<typedef path="cocktail.domElement.GradientStyleData" params="" file="/Users/lexa/Documents/repositories/lexoyo_Cocktail/demo/games/libs/cocktail/domElement/DOMElementData.hx" module="cocktail.domElement.DOMElementData">
		<a>
			<rotation><c path="Int"/></rotation>
			<gradientType><e path="cocktail.domElement.GradientTypeValue"/></gradientType>
			<gradientStops><c path="Array"><t path="cocktail.domElement.GradientStopData"/></c></gradientStops>
		</a>
		<haxe_doc>
	 * The data of a gradient fill
	 </haxe_doc>
	</typedef>
	<typedef path="cocktail.domElement.RGBData" params="" file="/Users/lexa/Documents/repositories/lexoyo_Cocktail/demo/games/libs/cocktail/domElement/DOMElementData.hx" module="cocktail.domElement.DOMElementData">
		<a>
			<red><c path="Int"/></red>
			<green><c path="Int"/></green>
			<blue><c path="Int"/></blue>
		</a>
		<haxe_doc>
	 * defines an RGB color
	 </haxe_doc>
	</typedef>
	<enum path="cocktail.domElement.FillStyleValue" params="" file="/Users/lexa/Documents/repositories/lexoyo_Cocktail/demo/games/libs/cocktail/domElement/DOMElementData.hx" module="cocktail.domElement.DOMElementData">
		<none/>
		<monochrome a="colorStop"><t path="cocktail.domElement.ColorStopData"/></monochrome>
		<gradient a="gradientStyle"><t path="cocktail.domElement.GradientStyleData"/></gradient>
		<bitmap a="imageDOMElement:repeat">
			<t path="cocktail.domElement.DOMElement"/>
			<e path="Bool"/>
		</bitmap>
		<haxe_doc>
	 * The different styles which can be applied to a fill
	 </haxe_doc>
	</enum>
	<enum path="cocktail.domElement.LineStyleValue" params="" file="/Users/lexa/Documents/repositories/lexoyo_Cocktail/demo/games/libs/cocktail/domElement/DOMElementData.hx" module="cocktail.domElement.DOMElementData">
		<none/>
		<monochrome a="colorStop:lineStyle">
			<t path="cocktail.domElement.ColorStopData"/>
			<t path="cocktail.domElement.LineStyleData"/>
		</monochrome>
		<gradient a="gradientStyle:lineStyle">
			<t path="cocktail.domElement.GradientStyleData"/>
			<t path="cocktail.domElement.LineStyleData"/>
		</gradient>
		<bitmap a="imageDOMElement:lineStyle:repeat">
			<t path="cocktail.domElement.DOMElement"/>
			<t path="cocktail.domElement.LineStyleData"/>
			<e path="Bool"/>
		</bitmap>
		<haxe_doc>
	 * The different style which can be applied to a line/stroke
	 </haxe_doc>
	</enum>
	<enum path="cocktail.domElement.GradientTypeValue" params="" file="/Users/lexa/Documents/repositories/lexoyo_Cocktail/demo/games/libs/cocktail/domElement/DOMElementData.hx" module="cocktail.domElement.DOMElementData">
		<radial/>
		<linear/>
		<haxe_doc>
	 * The available types of gradient for a gradient fill.
	 </haxe_doc>
	</enum>
	<enum path="cocktail.domElement.CapsStyleValue" params="" file="/Users/lexa/Documents/repositories/lexoyo_Cocktail/demo/games/libs/cocktail/domElement/DOMElementData.hx" module="cocktail.domElement.DOMElementData">
		<square/>
		<round/>
		<none/>
		<haxe_doc>
	 * The available types of caps at the end of a drawn line.
	 </haxe_doc>
	</enum>
	<enum path="cocktail.domElement.JointStyleValue" params="" file="/Users/lexa/Documents/repositories/lexoyo_Cocktail/demo/games/libs/cocktail/domElement/DOMElementData.hx" module="cocktail.domElement.DOMElementData">
		<round/>
		<miter/>
		<bevel/>
		<haxe_doc>
	 * The available type of joint apparence, used at line angles.
	 </haxe_doc>
	</enum>
	<enum path="cocktail.viewport.OrientationValue" params="" file="/Users/lexa/Documents/repositories/lexoyo_Cocktail/demo/games/libs/cocktail/viewport/ViewportData.hx" module="cocktail.viewport.ViewportData">
		<vertical><haxe_doc>
	 * the device is vertical
	 </haxe_doc></vertical>
		<horizontal><haxe_doc>
	 * the device is horizontal
	 </haxe_doc></horizontal>
		<haxe_doc>
 * Values for the device orientation
 </haxe_doc>
	</enum>
	<class path="js.XMLHttpRequest" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/js/XMLHttpRequest.hx" extern="1">
		<onreadystatechange public="1"><f a=""><e path="Void"/></f></onreadystatechange>
		<readyState public="1"><c path="Int"/></readyState>
		<responseText public="1"><c path="String"/></responseText>
		<status public="1"><c path="Int"/></status>
		<statusText public="1"><c path="String"/></statusText>
		<abort public="1" set="method"><f a=""><e path="Void"/></f></abort>
		<getAllResponseHeaders public="1" set="method"><f a=""><c path="String"/></f></getAllResponseHeaders>
		<getResponseHeader public="1" set="method"><f a="name">
	<c path="String"/>
	<c path="String"/>
</f></getResponseHeader>
		<setRequestHeader public="1" set="method"><f a="name:value">
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></setRequestHeader>
		<open public="1" set="method"><f a="method:url:async">
	<c path="String"/>
	<c path="String"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></open>
		<send public="1" set="method"><f a="content">
	<c path="String"/>
	<e path="Void"/>
</f></send>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<typedef path="cocktail.domElement.BodyDOMElement" params="" file="/Users/lexa/Documents/repositories/lexoyo_Cocktail/demo/games/libs/cocktail/domElement/BodyDOMElement.hx">
		<c path="cocktailCore.domElement.js.BodyDOMElement"/>
		<haxe_doc>
 * Set the right runtime specific BodyDOMElement at compile-time
 </haxe_doc>
	</typedef>
	<class path="cocktailCore.style.positioner.FixedPositioner" params="" file="/Users/lexa/Documents/repositories/lexoyo_Cocktail/demo/games/libs/cocktailCore/style/positioner/FixedPositioner.hx">
		<extends path="cocktailCore.style.positioner.BoxPositioner"/>
		<applyGlobalX set="method" line="36" override="1">
			<f a="domElement:globalX">
				<t path="cocktail.domElement.DOMElement"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Overriden because the global x applied to a fixed DOMElement
	 * is always 0 as its origin is the viewport
	 </haxe_doc>
		</applyGlobalX>
		<applyGlobalY set="method" line="45" override="1">
			<f a="domElement:globalY">
				<t path="cocktail.domElement.DOMElement"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Overriden because the global y applied to a fixed DOMElement
	 * is always 0 as its origin is the viewport
	 </haxe_doc>
		</applyGlobalY>
		<new public="1" set="method" line="23">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * class constructor
	 </haxe_doc>
		</new>
		<haxe_doc>
 * This is the box positioner class for
 * 'fixed' DOMElements. There are positioned
 * by using the viewport as origin
 * 
 * @author Yannick DOMINGUEZ
 </haxe_doc>
	</class>
	<class path="cocktailCore.domElement.abstract.AbstractImageDOMElement" params="" file="/Users/lexa/Documents/repositories/lexoyo_Cocktail/demo/games/libs/cocktailCore/domElement/abstract/AbstractImageDOMElement.hx">
		<extends path="cocktailCore.domElement.js.EmbeddedDOMElement"/>
		<onLoad public="1">
			<f a="">
				<t path="cocktail.domElement.ImageDOMElement"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * The callback called once a picture has been successfully
	 * loaded
	 </haxe_doc>
		</onLoad>
		<onError public="1">
			<f a="">
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * The callback called when there was an error during loading
	 </haxe_doc>
		</onError>
		<_src>
			<c path="String"/>
			<haxe_doc>
	 * The URL of the loaded picture.
	 * Read-only
	 </haxe_doc>
		</_src>
		<src public="1" get="getSrc" set="null"><c path="String"/></src>
		<_imageLoader>
			<t path="cocktailCore.resource.ImageLoader"/>
			<haxe_doc>
	 * Reponsible for loading pictures into a NativeElement. 
	 * Its NativeElement is used by this ImageDOMElement
	 </haxe_doc>
		</_imageLoader>
		<_smooth>
			<e path="Bool"/>
			<haxe_doc>
	 * Determine wether the bitmap should be smoothed
	 </haxe_doc>
		</_smooth>
		<smooth public="1" get="getSmooth" set="setSmooth"><e path="Bool"/></smooth>
		<init set="method" line="86" override="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * Init the smoothing of the picture
	 </haxe_doc>
		</init>
		<load public="1" set="method" line="103">
			<f a="url:?allowCache">
				<c path="String"/>
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Starts a loading with the image loader
	 * @param	url the url of the picture to load
	 * @param	allowCache wheter the picture is allowed to be cached by the browser
	 </haxe_doc>
		</load>
		<onLoadComplete set="method" line="118">
			<f a="image">
				<t path="cocktail.nativeElement.NativeElement"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Called when the picture was successfuly loaded.
	 * Invalidate the DOMElement and call the
	 * onLoad callback if provided
	 * @param	image the loaded picture stored as a nativeElement
	 </haxe_doc>
		</onLoadComplete>
		<onLoadError set="method" line="138">
			<f a="message">
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Called when there was an error during loading.
	 * Call the error callback if provided
	 * @param	message the error message
	 </haxe_doc>
		</onLoadError>
		<getSrc set="method" line="150"><f a=""><c path="String"/></f></getSrc>
		<setSmooth set="method" line="155"><f a="value">
	<e path="Bool"/>
	<e path="Bool"/>
</f></setSmooth>
		<getSmooth set="method" line="161"><f a=""><e path="Bool"/></f></getSmooth>
		<new public="1" set="method" line="76">
			<f a="?nativeElement">
				<t path="cocktail.nativeElement.NativeElement"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * class constructor. Instantiate the image loader
	 * and set its NativeElement as this ImageDOMElement's
	 * NativeElement
	 </haxe_doc>
		</new>
		<haxe_doc>
 * This DOMElement is in charge of displaying a picture of 
 * type .jpg, .png or .gif
 * 
 * @author Yannick DOMINGUEZ
 </haxe_doc>
	</class>
	<class path="cocktailCore.domElement.js.ImageDOMElement" params="" file="/Users/lexa/Documents/repositories/lexoyo_Cocktail/demo/games/libs/cocktailCore/domElement/js/ImageDOMElement.hx">
		<extends path="cocktailCore.domElement.abstract.AbstractImageDOMElement"/>
		<IMAGE_RENDERING_OPTIMIZE_QUALITY get="inline" set="null" line="25" static="1">
			<c path="String"/>
			<haxe_doc>
	 * This value smooth the bitmap
	 </haxe_doc>
		</IMAGE_RENDERING_OPTIMIZE_QUALITY>
		<IMAGE_RENDERING_OPTIMIZE_SPEED get="inline" set="null" line="30" static="1">
			<c path="String"/>
			<haxe_doc>
	 * This value doesn't smooth the bitmap
	 </haxe_doc>
		</IMAGE_RENDERING_OPTIMIZE_SPEED>
		<onLoadComplete set="method" line="49" override="1">
			<f a="image">
				<t path="cocktail.nativeElement.NativeElement"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Retrive the source url, width and
	 * height from the loaded picture
	 * @param	image
	 </haxe_doc>
		</onLoadComplete>
		<setSmooth set="method" line="68" override="1">
			<f a="value">
				<e path="Bool"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
	 * Override to use the CSS to smooth/unsmooth the bitmap
	 * @param	value
	 * @return
	 </haxe_doc>
		</setSmooth>
		<new public="1" set="method" line="35">
			<f a="?nativeElement">
				<t path="cocktail.nativeElement.NativeElement"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * class constructor
	 </haxe_doc>
		</new>
		<haxe_doc>
 * This is the JavaScript implementation of the Image DOMElement.
 * 
 * @author Yannick DOMINUGEZ
 </haxe_doc>
	</class>
	<typedef path="cocktailCore.keyboard.Keyboard" params="" file="/Users/lexa/Documents/repositories/lexoyo_Cocktail/demo/games/libs/cocktailCore/keyboard/Keyboard.hx">
		<c path="cocktailCore.keyboard.js.Keyboard"/>
		<haxe_doc>
 * Set the right runtime specific keyboard manager at compile-time
 </haxe_doc>
	</typedef>
	<class path="Class" params="T" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/Class.hx" extern="1"><haxe_doc>
	An abstract type that represents a Class.
	See [Type] for the haXe Reflection API.
</haxe_doc></class>
	<class path="Reflect" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/js/_std/Reflect.hx">
		<hasField public="1" set="method" line="28" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if an object has a field set. This doesn't take into account the object prototype (class methods).
	</haxe_doc>
		</hasField>
		<field public="1" get="inline" set="null" line="37" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<d/>
			</f>
			<haxe_doc>
		Returns the field of an object, or null if [o] is not an object or doesn't have this field.
	</haxe_doc>
		</field>
		<setField public="1" get="inline" set="null" line="46" static="1">
			<f a="o:field:value">
				<d/>
				<c path="String"/>
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Set an object field value.
	</haxe_doc>
		</setField>
		<callMethod public="1" get="inline" set="null" line="50" static="1">
			<f a="o:func:args">
				<d/>
				<d/>
				<c path="Array"><d/></c>
				<d/>
			</f>
			<haxe_doc>
		Call a method with the given object and arguments.
	</haxe_doc>
		</callMethod>
		<fields public="1" set="method" line="54" static="1">
			<f a="o">
				<d/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>
		Returns the list of fields of an object, excluding its prototype (class methods).
	</haxe_doc>
		</fields>
		<isFunction public="1" set="method" line="71" static="1">
			<f a="f">
				<d/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if a value is a function or not.
	</haxe_doc>
		</isFunction>
		<compare public="1" params="T" set="method" line="75" static="1">
			<f a="a:b">
				<c path="compare.T"/>
				<c path="compare.T"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
		Generic comparison function, does not work for methods, see [compareMethods]
	</haxe_doc>
		</compare>
		<compareMethods public="1" set="method" line="79" static="1">
			<f a="f1:f2">
				<d/>
				<d/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Compare two methods closures. Returns true if it's the same method of the same instance.
	</haxe_doc>
		</compareMethods>
		<isObject public="1" set="method" line="87" static="1">
			<f a="v">
				<d/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if a value is an object or not.

	</haxe_doc>
		</isObject>
		<deleteField public="1" set="method" line="94" static="1">
			<f a="o:f">
				<d/>
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Delete an object field.
	</haxe_doc>
		</deleteField>
		<copy public="1" params="T" set="method" line="100" static="1">
			<f a="o">
				<c path="copy.T"/>
				<c path="copy.T"/>
			</f>
			<haxe_doc>
		Make a copy of the fields of an object.
	</haxe_doc>
		</copy>
		<makeVarArgs public="1" set="method" line="107" static="1">
			<f a="f">
				<f a="">
					<c path="Array"><d/></c>
					<d/>
				</f>
				<d/>
			</f>
			<haxe_doc>
		Transform a function taking an array of arguments into a function that can
		be called with any number of arguments.
	</haxe_doc>
		</makeVarArgs>
		<haxe_doc>
	The Reflect API is a way to manipulate values dynamicly through an
	abstract interface in an untyped manner. Use with care.
</haxe_doc>
	</class>
	<class path="cocktailCore.unit.UnitManager" params="" file="/Users/lexa/Documents/repositories/lexoyo_Cocktail/demo/games/libs/cocktailCore/unit/UnitManager.hx">
		<getPixelFromLengthValue public="1" set="method" line="50" static="1">
			<f a="length:emReference:exReference">
				<e path="cocktail.unit.LengthValue"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
	 * Get a value in pixel 
	 * from a length value
	 * (px, em, cm...)
	 * @param	length contains the unit type and the value
	 * @param	emReference the computed value used as reference
	 * when computing an em relative length value. It can be either the
	 * DOMElement's computed font size or its parent's if the computed em
	 * value is the font size of the DOMElement
	 * @param exReference he computed value used as reference
	 * when computing an ex relative length value. It can be either the
	 * DOMElement's x-height or its parent's x-height if the computed ex value
	 * is the font size of the DOMElement
	 * @return returns the computed value as pixel with rounded
	 * values
	 </haxe_doc>
		</getPixelFromLengthValue>
		<getFontSizeFromAbsoluteSizeValue public="1" set="method" line="88" static="1">
			<f a="absoluteSize">
				<e path="cocktail.unit.FontSizeAbsoluteSizeValue"/>
				<c path="Float"/>
			</f>
			<haxe_doc>
	 * Takes an absolute size value for a font size and return
	 * a pixel value
	 </haxe_doc>
		</getFontSizeFromAbsoluteSizeValue>
		<getFontSizeFromRelativeSizeValue public="1" set="method" line="125" static="1">
			<f a="relativeSize:parentFontSize">
				<e path="cocktail.unit.FontSizeRelativeSizeValue"/>
				<c path="Float"/>
				<c path="Float"/>
			</f>
			<haxe_doc>
	 * Take a relative value for a font size and return
	 * a pixel value using the parent's computed font
	 </haxe_doc>
		</getFontSizeFromRelativeSizeValue>
		<getPixelFromPercent public="1" set="method" line="147" static="1">
			<f a="percent:reference">
				<c path="Int"/>
				<c path="Int"/>
				<c path="Float"/>
			</f>
			<haxe_doc>
	 * Get a percentage of a reference value
	 * @param	percent form 0 to 100
	 * @param	reference the reference value
	 * @return a percentage of the reference value
	 </haxe_doc>
		</getPixelFromPercent>
		<getColorFromColorValue public="1" set="method" line="155" static="1">
			<f a="value">
				<e path="cocktail.unit.ColorValue"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
	 * Get an integer color value from a serialised color value
	 </haxe_doc>
		</getColorFromColorValue>
		<getRadFromAngleValue public="1" set="method" line="180" static="1">
			<f a="value">
				<e path="cocktail.unit.AngleValue"/>
				<c path="Float"/>
			</f>
			<haxe_doc>
	 * Get a radian angle from any other angle value
	 </haxe_doc>
		</getRadFromAngleValue>
		<getDegreeFromAngleValue public="1" set="method" line="205" static="1">
			<f a="value">
				<e path="cocktail.unit.AngleValue"/>
				<c path="Float"/>
			</f>
			<haxe_doc>
	 * Get a degree angle from any other angle value
	 </haxe_doc>
		</getDegreeFromAngleValue>
		<getColorFromColorValueKeyword set="method" line="234" static="1">
			<f a="value">
				<e path="cocktail.unit.ColorKeywordValue"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
	 * Get an integer color value from a keyword color value
	 </haxe_doc>
		</getColorFromColorValueKeyword>
		<getLargerFontSize set="method" line="300" static="1">
			<f a="parentFontSize">
				<c path="Float"/>
				<c path="Float"/>
			</f>
			<haxe_doc>
	 * Get the next largest font size in the font size size array, taking
	 * the parent's font size as starting value
	 </haxe_doc>
		</getLargerFontSize>
		<getSmallerFontSize set="method" line="321" static="1">
			<f a="parentFontSize">
				<c path="Float"/>
				<c path="Float"/>
			</f>
			<haxe_doc>
	 * Get the next smallest font size in the font size size array, taking
	 * the parent's font size as starting value
	 </haxe_doc>
		</getSmallerFontSize>
		<new set="method" line="25">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * class constructor. Private as this class 
	 * is meant to be manipulated through static
	 * methods
	 </haxe_doc>
		</new>
		<haxe_doc>
 * This class exposes static unit conversion
 * methods
 * 
 * @author Yannick DOMINGUEZ
 </haxe_doc>
	</class>
	<typedef path="cocktail.domElement.ImageDOMElement" params="" file="/Users/lexa/Documents/repositories/lexoyo_Cocktail/demo/games/libs/cocktail/domElement/ImageDOMElement.hx">
		<c path="cocktailCore.domElement.js.ImageDOMElement"/>
		<haxe_doc>
 * Set the right runtime specific ImageDOMElement at compile-time
 </haxe_doc>
	</typedef>
	<class path="cocktailCore.domElement.abstract.AbstractTextFragmentDOMElement" params="" file="/Users/lexa/Documents/repositories/lexoyo_Cocktail/demo/games/libs/cocktailCore/domElement/abstract/AbstractTextFragmentDOMElement.hx">
		<extends path="cocktailCore.domElement.js.DOMElement"/>
		<initStyle set="method" line="57" override="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * Overriden to prevent instantiating a Style object.
	 * This DOMElement instead use a Style object
	 * provided by its ContainerDOMElement.
	 </haxe_doc>
		</initStyle>
		<new public="1" set="method" line="46">
			<f a="nativeElement:style">
				<t path="cocktail.nativeElement.NativeElement"/>
				<t path="cocktailCore.style.Style"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Class constructor. Unlike other DOMElements, this
	 * DOMElement doesn't instantiate its own style, it 
	 * takes the style of the ContainerDOMElement to 
	 * which it belongs.
	 * 
	 * Its nativeElement is also always provided
	 * 
	 * @param nativeElement
	 * @param style a reference to the Style Object of the
	 * ContainerDOMElement owning this DOMElement (the one
	 * which has the TextElement which was used as a model
	 * to create this DOMElement)
	 </haxe_doc>
		</new>
		<haxe_doc>
 * This DOMElement represents a native text element,
 * which might be a word or a space.
 * 
 * It is not meant to be instantiated but instead it
 * is created during layout to render TextElements
 * that were added to a ContainerDOMElement
 * 
 * @author Yannick DOMINGUEZ
 </haxe_doc>
	</class>
	<class path="cocktailCore.domElement.js.TextFragmentDOMElement" params="" file="/Users/lexa/Documents/repositories/lexoyo_Cocktail/demo/games/libs/cocktailCore/domElement/js/TextFragmentDOMElement.hx">
		<extends path="cocktailCore.domElement.abstract.AbstractTextFragmentDOMElement"/>
		<new public="1" set="method" line="26">
			<f a="nativeElement:style">
				<t path="cocktail.nativeElement.NativeElement"/>
				<t path="cocktailCore.style.Style"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * class constructor
	 </haxe_doc>
		</new>
		<haxe_doc>
 * This is the JavaScript implementation of the TextFragmentDOMElement.
 * It isn't used in this runtime, text display is handled by the browser
 * 
 * @author Yannick DOMINGUEZ
 </haxe_doc>
	</class>
	<typedef path="cocktailCore.resource.ResourceLoader" params="" file="/Users/lexa/Documents/repositories/lexoyo_Cocktail/demo/games/libs/cocktailCore/resource/ResourceLoader.hx">
		<c path="cocktailCore.resource.js.ResourceLoader"/>
		<haxe_doc>
 * Set the right runtime specific ResourceLoader at compile-time
 </haxe_doc>
	</typedef>
	<typedef path="cocktail.mouse.MouseEventData" params="" file="/Users/lexa/Documents/repositories/lexoyo_Cocktail/demo/games/libs/cocktail/mouse/MouseData.hx" module="cocktail.mouse.MouseData">
		<a>
			<shiftKey><e path="Bool"/></shiftKey>
			<mousePosition><t path="cocktail.mouse.MousePositionData"/></mousePosition>
			<ctrlKey>
				<e path="Bool"/>
				<haxe_doc>
	 * represents the keyboard state
	 * when the mouse event occurs
	 </haxe_doc>
			</ctrlKey>
			<altKey><e path="Bool"/></altKey>
		</a>
		<haxe_doc>
 * Stored the data raised by a mouse event
 </haxe_doc>
	</typedef>
	<typedef path="cocktail.mouse.MousePositionData" params="" file="/Users/lexa/Documents/repositories/lexoyo_Cocktail/demo/games/libs/cocktail/mouse/MouseData.hx" module="cocktail.mouse.MouseData">
		<a>
			<localY><c path="Float"/></localY>
			<localX><c path="Float"/></localX>
			<globalY><c path="Float"/></globalY>
			<globalX><c path="Float"/></globalX>
		</a>
		<haxe_doc>
 * Represents the position of the mouse, both
 * global (relative to the browser window top left
 * corner) and local (relative to the dom element
 * which triggered the mouse event top left corner)
 </haxe_doc>
	</typedef>
	<enum path="cocktail.mouse.MouseCursorValue" params="" file="/Users/lexa/Documents/repositories/lexoyo_Cocktail/demo/games/libs/cocktail/mouse/MouseData.hx" module="cocktail.mouse.MouseData">
		<none><haxe_doc>
	 * Hides the mouse cursor
	 </haxe_doc></none>
		<native a="nativeOSMouseCursorValue">
			<e path="cocktail.mouse.NativeOSMouseCursorValue"/>
			<haxe_doc>
	 * Use a native OS mouse cursor
	 </haxe_doc>
		</native>
		<custom a="imageDOMElement:hotSpot">
			<t path="cocktail.domElement.DOMElement"/>
			<t path="cocktail.geom.PointData"/>
			<haxe_doc>
	 * uses a custom bitmap cursor set with
	 * an image dom element. The hotSpot is the registration
	 * point of the cursor.
	 </haxe_doc>
		</custom>
		<auto><haxe_doc>
	 * Let the browser manage the mouse cursor
	 </haxe_doc></auto>
		<haxe_doc>
 * Lists the different cursors which can
 * be set for the mouse pointer
 </haxe_doc>
	</enum>
	<enum path="cocktail.mouse.NativeOSMouseCursorValue" params="" file="/Users/lexa/Documents/repositories/lexoyo_Cocktail/demo/games/libs/cocktail/mouse/MouseData.hx" module="cocktail.mouse.MouseData">
		<text><haxe_doc>
	 * represents an i-beam
	 </haxe_doc></text>
		<pointer><haxe_doc>
	 * represents a pointed hand
	 </haxe_doc></pointer>
		<haxe_doc>
 * Lists all the available native
 * OS mouse cursor
 </haxe_doc>
	</enum>
	<class path="IntIter" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/IntIter.hx">
		<min><c path="Int"/></min>
		<max><c path="Int"/></max>
		<hasNext public="1" set="method" line="46">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>
		Returns true if the iterator has other items, false otherwise.
	</haxe_doc>
		</hasNext>
		<next public="1" set="method" line="53">
			<f a=""><c path="Int"/></f>
			<haxe_doc>
		Moves to the next item of the iterator.
	</haxe_doc>
		</next>
		<new public="1" set="method" line="38">
			<f a="min:max">
				<c path="Int"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[
		Iterate from [min] (inclusive) to [max] (exclusive).
		If [max <= min], the iterator will not act as a countdown.
	]]></haxe_doc>
		</new>
		<haxe_doc>
	Integer iterator. Used for interval implementation.
</haxe_doc>
	</class>
	<class path="cocktailCore.viewport.abstract.AbstractViewport" params="" file="/Users/lexa/Documents/repositories/lexoyo_Cocktail/demo/games/libs/cocktailCore/viewport/abstract/AbstractViewport.hx">
		<onResize public="1" get="_getOnResize" set="_setOnResize">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * Resize callback
	 </haxe_doc>
		</onResize>
		<onOrientationChange public="1" get="_getOnOrientationChange" set="_setOnOrientationChange">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * Rotate callback
	 </haxe_doc>
		</onOrientationChange>
		<width public="1" get="_getWidth" set="null">
			<c path="Int"/>
			<haxe_doc>
	 * width of the viewport
	 </haxe_doc>
		</width>
		<height public="1" get="_getHeight" set="null">
			<c path="Int"/>
			<haxe_doc>
	 * height of the viewport
	 </haxe_doc>
		</height>
		<orientation public="1" get="_getOrientation" set="null">
			<e path="cocktail.viewport.OrientationValue"/>
			<haxe_doc>
	 * orientation of the viewport
	 </haxe_doc>
		</orientation>
		<_lastOrientationObserved>
			<e path="cocktail.viewport.OrientationValue"/>
			<haxe_doc>
	 * last data we have had for the orientation of the viewport
	 * used to determine if orientation has changed, and then call the orientationChange callback
	 * set by _onOrientationChangeCallback and onOrientationChange setter
	 </haxe_doc>
		</_lastOrientationObserved>
		<_addResizeEvent set="method" line="70">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * start listening to the viewport event
	 </haxe_doc>
		</_addResizeEvent>
		<_removeResizeEvent set="method" line="77">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * stop listening to the viewport event
	 </haxe_doc>
		</_removeResizeEvent>
		<_addOrientationChangeEvent set="method" line="85">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * start listening to the viewport event
	 </haxe_doc>
		</_addOrientationChangeEvent>
		<_removeOrientationChangeEvent set="method" line="92">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * stop listening to the viewport event
	 </haxe_doc>
		</_removeOrientationChangeEvent>
		<_getWidth set="method" line="99">
			<f a=""><c path="Int"/></f>
			<haxe_doc>
	 * getter for the value
	 </haxe_doc>
		</_getWidth>
		<_getHeight set="method" line="108">
			<f a=""><c path="Int"/></f>
			<haxe_doc>
	 * getter for the value
	 </haxe_doc>
		</_getHeight>
		<_getOrientation public="1" set="method" line="120">
			<f a=""><e path="cocktail.viewport.OrientationValue"/></f>
			<haxe_doc>
	 * getter for the value
	 </haxe_doc>
		</_getOrientation>
		<_onResizeCallback set="method" line="140">
			<f a="e">
				<unknown/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * event dispatched, call the callback
	 </haxe_doc>
		</_onResizeCallback>
		<_onOrientationChangeCallback set="method" line="149">
			<f a="e">
				<unknown/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * resize event dispatched, 
	 * if the orientation has changed, call the callback
	 </haxe_doc>
		</_onOrientationChangeCallback>
		<_onResize>
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * private variable used to store the callback
	 </haxe_doc>
		</_onResize>
		<_getOnResize set="method" line="171">
			<f a=""><f a=""><e path="Void"/></f></f>
			<haxe_doc>
	 * getter for the callback
	 </haxe_doc>
		</_getOnResize>
		<_setOnResize set="method" line="178">
			<f a="callbackFunction">
				<f a=""><e path="Void"/></f>
				<f a=""><e path="Void"/></f>
			</f>
			<haxe_doc>
	 * setter for the callback
	 </haxe_doc>
		</_setOnResize>
		<_onOrientationChange>
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * private variable used to store the callback
	 </haxe_doc>
		</_onOrientationChange>
		<_getOnOrientationChange set="method" line="200">
			<f a=""><f a=""><e path="Void"/></f></f>
			<haxe_doc>
	 * getter for the callback
	 </haxe_doc>
		</_getOnOrientationChange>
		<_setOnOrientationChange set="method" line="207">
			<f a="callbackFunction">
				<f a=""><e path="Void"/></f>
				<f a=""><e path="Void"/></f>
			</f>
			<haxe_doc>
	 * setter for the callback
	 </haxe_doc>
		</_setOnOrientationChange>
		<new public="1" set="method" line="26">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * Constructor
	 </haxe_doc>
		</new>
		<haxe_doc>
 * This class handles the interaction with the view port of the application.
 * The viewport is the visible portion of a 2D area which is larger than the visualization device.
 * Viewport width and height are read only and define the size of the visible area of our application.
 * The Viewport class is to be instanciated and the instances gives access to the viewport callbacks (events) and attributes.
 * This is the implementation for the JavaScript runtime. 
 * @author lexa
 * @date	12-2011
 </haxe_doc>
	</class>
	<class path="cocktailCore.viewport.js.Viewport" params="" file="/Users/lexa/Documents/repositories/lexoyo_Cocktail/demo/games/libs/cocktailCore/viewport/js/Viewport.hx">
		<extends path="cocktailCore.viewport.abstract.AbstractViewport"/>
		<_addResizeEvent set="method" line="40" override="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * start listening to the viewport event
	 </haxe_doc>
		</_addResizeEvent>
		<_removeResizeEvent set="method" line="47" override="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * stop listening to the viewport event
	 </haxe_doc>
		</_removeResizeEvent>
		<_addOrientationChangeEvent set="method" line="55" override="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * start listening to the viewport event
	 </haxe_doc>
		</_addOrientationChangeEvent>
		<_removeOrientationChangeEvent set="method" line="62" override="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * stop listening to the viewport event
	 </haxe_doc>
		</_removeOrientationChangeEvent>
		<_getWidth set="method" line="70" override="1">
			<f a=""><c path="Int"/></f>
			<haxe_doc>
	 * getter for the value
	 </haxe_doc>
		</_getWidth>
		<_getHeight set="method" line="78" override="1">
			<f a=""><c path="Int"/></f>
			<haxe_doc>
	 * getter for the value
	 </haxe_doc>
		</_getHeight>
		<new public="1" set="method" line="30">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * Constructor
	 </haxe_doc>
		</new>
		<haxe_doc>
 * This class handles the interaction with the view port of the application.
 * The viewport is the visible portion of a 2D area which is larger than the visualization device.
 * Viewport width and height are read only and define the size of the visible area of our application.
 * The Viewport class is to be instanciated and the instances gives access to the viewport callbacks (events) and attributes.
 * This is the implementation for the JavaScript runtime. 
 * @author lexa
 * @date	12-2011
 </haxe_doc>
	</class>
	<class path="Math" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/Math.hx" extern="1">
		<PI public="1" set="null" static="1"><c path="Float"/></PI>
		<NaN public="1" set="null" static="1"><c path="Float"/></NaN>
		<NEGATIVE_INFINITY public="1" set="null" static="1"><c path="Float"/></NEGATIVE_INFINITY>
		<POSITIVE_INFINITY public="1" set="null" static="1"><c path="Float"/></POSITIVE_INFINITY>
		<abs public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></abs>
		<min public="1" set="method" static="1"><f a="a:b">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></min>
		<max public="1" set="method" static="1"><f a="a:b">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></max>
		<sin public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></sin>
		<cos public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></cos>
		<atan2 public="1" set="method" static="1"><f a="y:x">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></atan2>
		<tan public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></tan>
		<exp public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></exp>
		<log public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></log>
		<sqrt public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></sqrt>
		<round public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Int"/>
</f></round>
		<floor public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Int"/>
</f></floor>
		<ceil public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Int"/>
</f></ceil>
		<atan public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></atan>
		<asin public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></asin>
		<acos public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></acos>
		<pow public="1" set="method" static="1"><f a="v:exp">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></pow>
		<random public="1" set="method" static="1"><f a=""><c path="Float"/></f></random>
		<isFinite public="1" set="method" static="1"><f a="f">
	<c path="Float"/>
	<e path="Bool"/>
</f></isFinite>
		<isNaN public="1" set="method" static="1"><f a="f">
	<c path="Float"/>
	<e path="Bool"/>
</f></isNaN>
		<haxe_doc>
	This class defines mathematical functions and constants.
</haxe_doc>
	</class>
	<class path="cocktailCore.textElement.js.TextElement" params="" file="/Users/lexa/Documents/repositories/lexoyo_Cocktail/demo/games/libs/cocktailCore/textElement/js/TextElement.hx">
		<extends path="cocktailCore.textElement.abstract.AbstractTextElement"/>
		<new public="1" set="method" line="32">
			<f a="text">
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * class contructor
	 </haxe_doc>
		</new>
		<haxe_doc>
 * This is the JavaScript implementation of the TextElement.
 * 
 * In JavaScript, a text element is represented by an 
 * HTML text node object. 
 * 
 * This HTML text node object is created from
 * the text provided in the constructor.
 * It is wrapped in a NativeTextElement
 * 
 * @author Yannick DOMINGUEZ
 </haxe_doc>
	</class>
	<class path="cocktailCore.keyboard.js.Keyboard" params="" file="/Users/lexa/Documents/repositories/lexoyo_Cocktail/demo/games/libs/cocktailCore/keyboard/js/Keyboard.hx">
		<extends path="cocktailCore.keyboard.abstract.AbstractKeyboard"/>
		<setOnKeyDown set="method" line="36" override="1"><f a="value">
	<f a="">
		<t path="cocktail.keyboard.KeyEventData"/>
		<e path="Void"/>
	</f>
	<f a="">
		<t path="cocktail.keyboard.KeyEventData"/>
		<e path="Void"/>
	</f>
</f></setOnKeyDown>
		<setOnKeyUp set="method" line="52" override="1"><f a="value">
	<f a="">
		<t path="cocktail.keyboard.KeyEventData"/>
		<e path="Void"/>
	</f>
	<f a="">
		<t path="cocktail.keyboard.KeyEventData"/>
		<e path="Void"/>
	</f>
</f></setOnKeyUp>
		<getKeyData set="method" line="74" override="1">
			<f a="event">
				<d/>
				<t path="cocktail.keyboard.KeyEventData"/>
			</f>
			<haxe_doc>
	 * Returns the key that triggered the keyboard event
	 * @param	event the native key up or down event
	 * @return a sruct containing the key code and ascii value
	 </haxe_doc>
		</getKeyData>
		<new public="1" set="method" line="27">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * class constructor
	 </haxe_doc>
		</new>
		<haxe_doc>
 * This is the JavaScript implementation of the keyboard abstraction.
 * Set listeners on native javascript keyboard event and call the
 * corresponding callbacks
 * 
 * @author Yannick DOMINGUEZ
 </haxe_doc>
	</class>
	<typedef path="cocktail.geom.RectangleData" params="" file="/Users/lexa/Documents/repositories/lexoyo_Cocktail/demo/games/libs/cocktail/geom/GeomData.hx" module="cocktail.geom.GeomData">
		<a>
			<y><c path="Float"/></y>
			<x><c path="Float"/></x>
			<width><c path="Float"/></width>
			<height><c path="Float"/></height>
		</a>
		<haxe_doc>
	 * represent a rectangle
	 </haxe_doc>
	</typedef>
	<typedef path="cocktail.geom.PointData" params="" file="/Users/lexa/Documents/repositories/lexoyo_Cocktail/demo/games/libs/cocktail/geom/GeomData.hx" module="cocktail.geom.GeomData">
		<a>
			<y><c path="Float"/></y>
			<x><c path="Float"/></x>
		</a>
		<haxe_doc>
	 * Represents a point in 2d space
	 </haxe_doc>
	</typedef>
	<typedef path="cocktail.geom.MatrixData" params="" file="/Users/lexa/Documents/repositories/lexoyo_Cocktail/demo/games/libs/cocktail/geom/GeomData.hx" module="cocktail.geom.GeomData">
		<a>
			<f><c path="Float"/></f>
			<e><c path="Float"/></e>
			<d><c path="Float"/></d>
			<c><c path="Float"/></c>
			<b><c path="Float"/></b>
			<a><c path="Float"/></a>
		</a>
		<haxe_doc>
	 * Represents the values of a 3x3 Matrix
	 </haxe_doc>
	</typedef>
	<class path="cocktailCore.style.computer.boxComputers.EmbeddedBlockBoxStylesComputer" params="" file="/Users/lexa/Documents/repositories/lexoyo_Cocktail/demo/games/libs/cocktailCore/style/computer/boxComputers/EmbeddedBlockBoxStylesComputer.hx">
		<extends path="cocktailCore.style.computer.BoxStylesComputer"/>
		<getComputedAutoWidth set="method" line="43" override="1">
			<f a="style:containingDOMElementData">
				<c path="cocktailCore.style.abstract.AbstractStyle"/>
				<t path="cocktailCore.style.ContainingDOMElementData"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
	 * Override the way a value of 'auto' for the width style
	 * is computed, as an embedded DOMElement may have an intrinsic width
	 * and/or intrinsic ratio
	 </haxe_doc>
		</getComputedAutoWidth>
		<getComputedAutoHeight set="method" line="118" override="1">
			<f a="style:containingDOMElementData">
				<c path="cocktailCore.style.abstract.AbstractStyle"/>
				<t path="cocktailCore.style.ContainingDOMElementData"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
	 * Override the way a value of 'auto' for the height style
	 * is computed, as an embedded DOMElement may have an intrinsic height
	 * and/or intrinsic ratio
	 </haxe_doc>
		</getComputedAutoHeight>
		<getComputedAutoMargin set="method" line="159" override="1">
			<f a="marginStyleValue:opositeMarginStyleValue:containingDOMElementDimension:computedDimension:isDimensionAuto:computedPaddingsDimension:fontSize:xHeight:?isHorizontalMargin">
				<e path="cocktail.style.MarginStyleValue"/>
				<e path="cocktail.style.MarginStyleValue"/>
				<c path="Int"/>
				<c path="Int"/>
				<e path="Bool"/>
				<c path="Int"/>
				<c path="Float"/>
				<c path="Float"/>
				<e path="Bool"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
	 * for block embedded DOMElement, an 'auto' for vertical margin compute to 0, 
	 * horizontal margin are computed like for non-embedded block DOMElements
	 </haxe_doc>
		</getComputedAutoMargin>
		<new public="1" set="method" line="33">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * class constructor
	 </haxe_doc>
		</new>
		<haxe_doc>
 * This is the box computer implementation for an
 * embedded block DOMElement.
 * 
 * It add special treatement for dimensions
 * computation, as an embedded DOMElement has intrinsic
 * dimensions
 * 
 * @author Yannick DOMINGUEZ
 </haxe_doc>
	</class>
	<class path="cocktailCore.style.computer.boxComputers.EmbeddedInlineBoxStylesComputer" params="" file="/Users/lexa/Documents/repositories/lexoyo_Cocktail/demo/games/libs/cocktailCore/style/computer/boxComputers/EmbeddedInlineBoxStylesComputer.hx">
		<extends path="cocktailCore.style.computer.boxComputers.EmbeddedBlockBoxStylesComputer"/>
		<getComputedAutoMargin set="method" line="37" override="1">
			<f a="marginStyleValue:opositeMarginStyleValue:containingDOMElementDimension:computedDimension:isDimensionAuto:computedPaddingsDimension:fontSize:xHeight:?isHorizontalMargin">
				<e path="cocktail.style.MarginStyleValue"/>
				<e path="cocktail.style.MarginStyleValue"/>
				<c path="Int"/>
				<c path="Int"/>
				<e path="Bool"/>
				<c path="Int"/>
				<c path="Float"/>
				<c path="Float"/>
				<e path="Bool"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
	 * for inline embedded DOMElement, auto margins compute to 0
	 </haxe_doc>
		</getComputedAutoMargin>
		<new public="1" set="method" line="29">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * class constructor
	 </haxe_doc>
		</new>
		<haxe_doc>
 * This is the box computer for inline embedded DOMElement,
 * such as for instance an ImageDOMElement inserted in a
 * text
 * 
 * @author Yannick DOMINGUEZ
 </haxe_doc>
	</class>
	<class path="cocktailCore.style.computer.boxComputers.EmbeddedFloatBoxStylesComputer" params="" file="/Users/lexa/Documents/repositories/lexoyo_Cocktail/demo/games/libs/cocktailCore/style/computer/boxComputers/EmbeddedFloatBoxStylesComputer.hx">
		<extends path="cocktailCore.style.computer.boxComputers.EmbeddedInlineBoxStylesComputer"/>
		<new public="1" set="method" line="22">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * class constructor
	 </haxe_doc>
		</new>
		<haxe_doc>
 * This is the box computer for floated embedded DOMElement,
 * such as a floated ImagdDOMElement. It behaves the same
 * as the box computer for inline embedded DOMElement
 * 
 * @author Yannick DOMINGUEZ
 </haxe_doc>
	</class>
	<class path="js.Boot" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/js/Boot.hx">
		<__unhtml set="method" line="29" static="1"><f a="s">
	<c path="String"/>
	<c path="String"/>
</f></__unhtml>
		<__trace set="method" line="33" static="1"><f a="v:i">
	<a>
		<toString set="null"><f a=""><c path="String"/></f></toString>
		<length set="null"><c path="Int"/></length>
		<hasOwnProperty set="null"><f a="">
	<c path="String"/>
	<e path="Bool"/>
</f></hasOwnProperty>
		<__name__ set="null"><unknown/></__name__>
		<__enum__ set="null"><unknown/></__enum__>
		<__ename__ set="null"><unknown/></__ename__>
	</a>
	<t path="haxe.PosInfos"/>
	<e path="Void"/>
</f></__trace>
		<__clear_trace set="method" line="50" static="1"><f a=""><e path="Void"/></f></__clear_trace>
		<__closure set="method" line="62" static="1"><f a="o:f">
	<c path="Array"><a><apply set="null"><unknown/></apply></a></c>
	<c path="Int"/>
	<f a=""><unknown/></f>
</f></__closure>
		<__string_rec set="method" line="74" static="1"><f a="o:s">
	<a>
		<toString set="null"><f a=""><c path="String"/></f></toString>
		<length set="null"><c path="Int"/></length>
		<hasOwnProperty set="null"><f a="">
	<c path="String"/>
	<e path="Bool"/>
</f></hasOwnProperty>
		<__name__ set="null"><unknown/></__name__>
		<__enum__ set="null"><unknown/></__enum__>
		<__ename__ set="null"><unknown/></__ename__>
	</a>
	<a><length set="null"><c path="Int"/></length></a>
	<c path="String"/>
</f></__string_rec>
		<__interfLoop set="method" line="146" static="1"><f a="cc:cl">
	<d/>
	<d/>
	<e path="Bool"/>
</f></__interfLoop>
		<__instanceof set="method" line="161" static="1"><f a="o:cl">
	<d/>
	<t path="#Array"/>
	<e path="Bool"/>
</f></__instanceof>
		<__init set="method" line="194" static="1"><f a=""><e path="Void"/></f></__init>
	</class>
	<typedef path="cocktailCore.textElement.NativeTextElement" params="" file="/Users/lexa/Documents/repositories/lexoyo_Cocktail/demo/games/libs/cocktailCore/textElement/NativeTextElement.hx">
		<t path="js.HtmlDom"/>
		<haxe_doc>
 * Set the right runtime specific NativeTextElement at compile-time
 * 
 * A NativeTextElement is an abstraction of a text element, variying
 * based on runtime
 </haxe_doc>
	</typedef>
	<typedef path="cocktailCore.style.EmbeddedStyle" params="" file="/Users/lexa/Documents/repositories/lexoyo_Cocktail/demo/games/libs/cocktailCore/style/EmbeddedStyle.hx">
		<c path="cocktailCore.style.js.EmbeddedStyle"/>
		<haxe_doc>
 * Set the right runtime specific EmbeddedStyle at compile-time
 </haxe_doc>
	</typedef>
	<class path="haxe.Timer" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/haxe/Timer.hx">
		<delay public="1" set="method" line="77" static="1"><f a="f:time_ms">
	<f a=""><e path="Void"/></f>
	<c path="Int"/>
	<c path="haxe.Timer"/>
</f></delay>
		<measure public="1" params="T" set="method" line="88" static="1"><f a="f:?pos">
	<f a=""><c path="measure.T"/></f>
	<t path="haxe.PosInfos"/>
	<c path="measure.T"/>
</f></measure>
		<stamp public="1" set="method" line="98" static="1">
			<f a=""><c path="Float"/></f>
			<haxe_doc>
		Returns a timestamp, in seconds
	</haxe_doc>
		</stamp>
		<id><t path="Null"><c path="Int"/></t></id>
		<timerId><c path="Int"/></timerId>
		<stop public="1" set="method" line="52"><f a=""><e path="Void"/></f></stop>
		<run public="1" set="dynamic" line="74"><f a=""><e path="Void"/></f></run>
		<new public="1" set="method" line="37"><f a="time_ms">
	<c path="Int"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="cocktailCore.nativeElement.abstract.AbstractNativeElementCreator" params="" file="/Users/lexa/Documents/repositories/lexoyo_Cocktail/demo/games/libs/cocktailCore/nativeElement/abstract/AbstractNativeElementCreator.hx">
		<createNativeElement public="1" set="method" line="35">
			<f a="nativeElementType">
				<e path="cocktail.nativeElement.NativeElementTypeValue"/>
				<t path="cocktail.nativeElement.NativeElement"/>
			</f>
			<haxe_doc>
	 * Instantiate a native element and returns a reference to it. Implemented in inheriting classes
	 * @param	nativeElementType the type of element to create (graphic, text...)
	 </haxe_doc>
		</createNativeElement>
		<new public="1" set="method" line="26">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * class constructor
	 </haxe_doc>
		</new>
		<haxe_doc>
 * This is a base class for the native element
 * creator implementation. It creates a native element
 * and returns a reference to it
 * 
 * @author Yannick DOMINGUEZ
 </haxe_doc>
	</class>
	<class path="cocktailCore.nativeElement.js.NativeElementCreator" params="" file="/Users/lexa/Documents/repositories/lexoyo_Cocktail/demo/games/libs/cocktailCore/nativeElement/js/NativeElementCreator.hx">
		<extends path="cocktailCore.nativeElement.abstract.AbstractNativeElementCreator"/>
		<createNativeElement public="1" set="method" line="37" override="1">
			<f a="nativeElementType">
				<e path="cocktail.nativeElement.NativeElementTypeValue"/>
				<t path="cocktail.nativeElement.NativeElement"/>
			</f>
			<haxe_doc>
	 * Instantiate a native HTML Element based on the requested type and returns a reference to it.
	 * @param	nativeElementType the type of element to create (graphic, text...)
	 </haxe_doc>
		</createNativeElement>
		<new public="1" set="method" line="28">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * class constructor
	 </haxe_doc>
		</new>
		<haxe_doc>
 * This is the Javascript implementation of the native element
 * creator. It instantiate a native HTML element 
 * and returns it as a NativeElement
 * 
 * @author Yannick DOMINGUEZ
 </haxe_doc>
	</class>
	<typedef path="cocktailCore.style.BodyStyle" params="" file="/Users/lexa/Documents/repositories/lexoyo_Cocktail/demo/games/libs/cocktailCore/style/BodyStyle.hx">
		<c path="cocktailCore.style.js.BodyStyle"/>
		<haxe_doc>
 * Set the right runtime specific BodyStyle at compile-time
 </haxe_doc>
	</typedef>
	<class path="cocktailCore.style.computer.boxComputers.EmbeddedInlineBlockBoxStylesComputer" params="" file="/Users/lexa/Documents/repositories/lexoyo_Cocktail/demo/games/libs/cocktailCore/style/computer/boxComputers/EmbeddedInlineBlockBoxStylesComputer.hx">
		<extends path="cocktailCore.style.computer.boxComputers.EmbeddedInlineBoxStylesComputer"/>
		<new public="1" set="method" line="23">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * class constructor
	 </haxe_doc>
		</new>
		<haxe_doc>
 * This is the box computer for inlineBlock embedded DOMElement
 * It has the same behaviour as the computer for inline embedded
 * DOMElements
 * 
 * @author Yannick DOMINGUEZ
 </haxe_doc>
	</class>
	<typedef path="cocktail.domElement.GraphicDOMElement" params="" file="/Users/lexa/Documents/repositories/lexoyo_Cocktail/demo/games/libs/cocktail/domElement/GraphicDOMElement.hx">
		<c path="cocktailCore.domElement.js.GraphicDOMElement"/>
		<haxe_doc>
 * Set the right runtime specific GraphicDOMElement at compile-time
 </haxe_doc>
	</typedef>
	<class path="engine.MovingObject" params="" file="/Users/lexa/Documents/repositories/lexoyo_Cocktail/demo/games/src/engine/MovingObject.hx">
		<_timeline><t path="cocktail.domElement.ContainerDOMElement"/></_timeline>
		<x public="1"><c path="Float"/></x>
		<y public="1"><c path="Float"/></y>
		<speedX public="1"><c path="Float"/></speedX>
		<speedY public="1"><c path="Float"/></speedY>
		<accelX public="1"><c path="Float"/></accelX>
		<accelY public="1"><c path="Float"/></accelY>
		<imageDOMElement public="1"><t path="cocktail.domElement.ImageDOMElement"/></imageDOMElement>
		<update public="1" set="method" line="25"><f a=""><e path="Void"/></f></update>
		<updateHorizontal public="1" set="method" line="30"><f a=""><e path="Void"/></f></updateHorizontal>
		<updateVertical public="1" set="method" line="48"><f a=""><e path="Void"/></f></updateVertical>
		<new public="1" set="method" line="18"><f a="timeline">
	<t path="cocktail.domElement.ContainerDOMElement"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="cocktailCore.style.computer.boxComputers.FloatBoxStylesComputer" params="" file="/Users/lexa/Documents/repositories/lexoyo_Cocktail/demo/games/libs/cocktailCore/style/computer/boxComputers/FloatBoxStylesComputer.hx">
		<extends path="cocktailCore.style.computer.boxComputers.InlineBlockBoxStylesComputer"/>
		<getComputedAutoWidth set="method" line="36" override="1">
			<f a="style:containingDOMElementData">
				<c path="cocktailCore.style.abstract.AbstractStyle"/>
				<t path="cocktailCore.style.ContainingDOMElementData"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
	 * for floated non-embedded DOMElements, an auto width is computed as 'shrink-to-fit' once all the children
	 * have been laid out
	 </haxe_doc>
		</getComputedAutoWidth>
		<new public="1" set="method" line="27">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * class constructor
	 </haxe_doc>
		</new>
		<haxe_doc>
 * this is the box computer for floated non-embedded DOMElement
 * such as a floated ContainerDOMElement.
 * 
 * @author Yannick DOMINGUEZ
 </haxe_doc>
	</class>
	<class path="StringBuf" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/StringBuf.hx">
		<add public="1" get="inline" set="null" line="46">
			<f a="x">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Adds the representation of any value to the string buffer.
	</haxe_doc>
		</add>
		<addSub public="1" get="inline" set="null" line="59">
			<f a="s:pos:?len">
				<c path="String"/>
				<c path="Int"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Adds a part of a string to the string buffer.
	</haxe_doc>
		</addSub>
		<addChar public="1" get="inline" set="null" line="75">
			<f a="c">
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Adds a character to the string buffer.
	</haxe_doc>
		</addChar>
		<toString public="1" get="inline" set="null" line="89">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns the content of the string buffer.
		The buffer is not emptied by this operation.
	</haxe_doc>
		</toString>
		<b><c path="Array"><d/></c></b>
		<new public="1" set="method" line="35">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
		Creates a new string buffer.
	</haxe_doc>
		</new>
		<haxe_doc>
	A String buffer is an efficient way to build a big string by
	appending small elements together.
</haxe_doc>
	</class>
	<class path="cocktailCore.style.abstract.AbstractEmbeddedStyle" params="" file="/Users/lexa/Documents/repositories/lexoyo_Cocktail/demo/games/libs/cocktailCore/style/abstract/AbstractEmbeddedStyle.hx">
		<extends path="cocktailCore.style.js.Style"/>
		<getBoxStylesComputer set="method" line="55" override="1">
			<f a=""><c path="cocktailCore.style.computer.BoxStylesComputer"/></f>
			<haxe_doc>
	 * overriden to use box computer specific to 
	 * embedded DOMElement instead of the default one
	 </haxe_doc>
		</getBoxStylesComputer>
		<isEmbedded public="1" set="method" line="95" override="1">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>
	 * Overriden as all inherithing classes of the
	 * Embedded DOMElement are embedded
	 </haxe_doc>
		</isEmbedded>
		<new public="1" set="method" line="41">
			<f a="domElement">
				<t path="cocktail.domElement.DOMElement"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * class constructor
	 </haxe_doc>
		</new>
		<haxe_doc>
 * This is the style implementation for embedded
 * DOMElement. Embedded DOMElement include external
 * content in the document, such as picture or video
 * 
 * @author Yannick DOMINGUEZ
 </haxe_doc>
	</class>
	<class path="cocktailCore.style.js.EmbeddedStyle" params="" file="/Users/lexa/Documents/repositories/lexoyo_Cocktail/demo/games/libs/cocktailCore/style/js/EmbeddedStyle.hx">
		<extends path="cocktailCore.style.abstract.AbstractEmbeddedStyle"/>
		<new public="1" set="method" line="20"><f a="domElement">
	<t path="cocktail.domElement.DOMElement"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>
 * This is the JavaScript implementation of the EmbeddedStyle.
 * 
 * @author Yannick DOMINGUEZ
 </haxe_doc>
	</class>
	<class path="cocktailCore.resource.abstract.AbstractResourceLoader" params="" file="/Users/lexa/Documents/repositories/lexoyo_Cocktail/demo/games/libs/cocktailCore/resource/abstract/AbstractResourceLoader.hx">
		<_onLoadCompleteCallback>
			<f a="">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Stores the callback to call once the file is successfully loaded
	 </haxe_doc>
		</_onLoadCompleteCallback>
		<_onLoadErrorCallback>
			<f a="">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Stores the callback to call if there is an error during loading
	 </haxe_doc>
		</_onLoadErrorCallback>
		<_nativeElement>
			<t path="cocktail.nativeElement.NativeElement"/>
			<haxe_doc>
	 * A reference to the native element actually loading
	 * the asset. For instance, for an image in Flash, a Loader, in JS,
	 * an img tag. When multiple loads occurs, this NativeElement is
	 * reused instead of a new one being created.
	 </haxe_doc>
		</_nativeElement>
		<nativeElement public="1" get="getNativeElement" set="null"><t path="cocktail.nativeElement.NativeElement"/></nativeElement>
		<load public="1" set="method" line="67">
			<f a="url:onLoadComplete:onLoadError:?allowCache">
				<c path="String"/>
				<f a="">
					<d/>
					<e path="Void"/>
				</f>
				<f a="">
					<d/>
					<e path="Void"/>
				</f>
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Start the loading of a file. Stores the success and error callbacks. Prevent file caching if requested
	 * then actually start the file loading
	 * @param	url the url of the file to load
	 * @param	onLoadComplete called when the file is done loading
	 * @param	onLoadError called when there is an error during loading
	 * @param	allowCache wether to allow the browser to cache the loaded file
	 </haxe_doc>
		</load>
		<doLoad set="method" line="91">
			<f a="url">
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Actually start the file loading. Meant to be overriden.
	 * @param	url the url to load
	 </haxe_doc>
		</doLoad>
		<onLoadComplete set="method" line="105">
			<f a="data">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * When the file is done loading, calls the success callback
	 * @param	data the loaded file data, passed to the success callback
	 </haxe_doc>
		</onLoadComplete>
		<onLoadError set="method" line="115">
			<f a="msg">
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * When there is an error while loading a file, calls the error
	 * callback
	 * @param	msg the error message, passed to the error callback
	 </haxe_doc>
		</onLoadError>
		<disableUrlCaching set="method" line="129">
			<f a="url">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
	 * Append a random number to the url to make it unique
	 * @param	url the url to transform
	 * @return the randomised url
	 </haxe_doc>
		</disableUrlCaching>
		<getNativeElement set="method" line="155"><f a=""><t path="cocktail.nativeElement.NativeElement"/></f></getNativeElement>
		<new public="1" set="method" line="44">
			<f a="?nativeElement">
				<t path="cocktail.nativeElement.NativeElement"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * class constructor
	 </haxe_doc>
		</new>
		<haxe_doc>
 * This class is in charge of loading one file and calling the right callback after the load succedeed/failed. This is a base
 * class implemented for each media/data types.
 * 
 * @author Yannick DOMINGUEZ
 </haxe_doc>
	</class>
	<class path="cocktailCore.resource.js.ResourceLoader" params="" file="/Users/lexa/Documents/repositories/lexoyo_Cocktail/demo/games/libs/cocktailCore/resource/js/ResourceLoader.hx">
		<extends path="cocktailCore.resource.abstract.AbstractResourceLoader"/>
		<doLoad set="method" line="40" override="1">
			<f a="url">
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * To load a resource, the source of the HTML element is
	 * set to the url to load
	 * @param	url the url of the picture
	 </haxe_doc>
		</doLoad>
		<new public="1" set="method" line="26">
			<f a="?nativeElement">
				<t path="cocktail.nativeElement.NativeElement"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * class constructor.
	 </haxe_doc>
		</new>
		<haxe_doc>
 * This is the JavaScript implementation of the ResourceLoader.
 * Load a resource by setting the src attribute on the right
 * HTML tag
 * 
 * @author Yannick DOMINGUEZ
 </haxe_doc>
	</class>
	<class path="cocktailCore.style.computer.VisualEffectStylesComputer" params="" file="/Users/lexa/Documents/repositories/lexoyo_Cocktail/demo/games/libs/cocktailCore/style/computer/VisualEffectStylesComputer.hx">
		<compute public="1" set="method" line="46" static="1">
			<f a="style">
				<c path="cocktailCore.style.abstract.AbstractStyle"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Compute all the visual effect styles
	 * 
	 * @param	style contain the styles definition of the 
	 * target DOMElement
	 </haxe_doc>
		</compute>
		<getComputedOpacity set="method" line="72" static="1">
			<f a="style">
				<c path="cocktailCore.style.abstract.AbstractStyle"/>
				<c path="Float"/>
			</f>
			<haxe_doc>
	 * Compute the 'opacity' style.
	 </haxe_doc>
		</getComputedOpacity>
		<getComputedVisibility set="method" line="88" static="1">
			<f a="style">
				<c path="cocktailCore.style.abstract.AbstractStyle"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
	 * Compute the 'visibility' style
	 </haxe_doc>
		</getComputedVisibility>
		<getComputedTransformOrigin set="method" line="108" static="1">
			<f a="style">
				<c path="cocktailCore.style.abstract.AbstractStyle"/>
				<t path="cocktail.geom.PointData"/>
			</f>
			<haxe_doc>
	 * Compute the transformation origin and returns it as a 2d point
	 * in pixel
	 </haxe_doc>
		</getComputedTransformOrigin>
		<getComputedTransform set="method" line="164" static="1">
			<f a="style">
				<c path="cocktailCore.style.abstract.AbstractStyle"/>
				<c path="cocktail.geom.Matrix"/>
			</f>
			<haxe_doc>
	 * Compute a transformation matrix to apply to the DOMElement
	 * from the array of transform functions concatenated in order
	 </haxe_doc>
		</getComputedTransform>
		<getComputedTranslation set="method" line="250" static="1">
			<f a="style:translation:percentReference">
				<c path="cocktailCore.style.abstract.AbstractStyle"/>
				<e path="cocktail.style.TranslationValue"/>
				<c path="Int"/>
				<c path="Float"/>
			</f>
			<haxe_doc>
	 * Utils method to compute a TransformValue into a float
	 </haxe_doc>
		</getComputedTranslation>
		<new set="method" line="31">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * Class contructor. Private, as
	 * this class is meant to be accessed
	 * through its public static methods
	 </haxe_doc>
		</new>
		<haxe_doc>
 * This is a static class in charge of
 * computing the visual effect styles
 * 
 * @author Yannick DOMINGUEZ
 </haxe_doc>
	</class>
	<class path="cocktail.nativeElement.NativeElementManager" params="" file="/Users/lexa/Documents/repositories/lexoyo_Cocktail/demo/games/libs/cocktail/nativeElement/NativeElementManager.hx">
		<_nativeElementCreator static="1">
			<c path="cocktailCore.nativeElement.js.NativeElementCreator"/>
			<haxe_doc>
	 * A reference to the runtime specific implementation of the class
	 * instantiating the new native elements
	 </haxe_doc>
		</_nativeElementCreator>
		<_nativeElementPathManager static="1">
			<c path="cocktailCore.nativeElement.js.NativeElementPathManager"/>
			<haxe_doc>
	 * A reference to the runtime specific implementation of the class
	 * managing the native element paths
	 </haxe_doc>
		</_nativeElementPathManager>
		<getRoot public="1" set="method" line="67" static="1">
			<f a=""><t path="cocktail.nativeElement.NativeElement"/></f>
			<haxe_doc>
	 * Returns the native DOM root of the current runtime, for instance
	 * the Body element in HTML, the Stage in Flash
	 </haxe_doc>
		</getRoot>
		<createNativeElement public="1" set="method" line="81" static="1">
			<f a="nativeElementType">
				<e path="cocktail.nativeElement.NativeElementTypeValue"/>
				<t path="cocktail.nativeElement.NativeElement"/>
			</f>
			<haxe_doc>
	 * Instantiate a native element and returns a reference to it
	 * @param	nativeElementType the type of element to create (graphic, text...)
	 </haxe_doc>
		</createNativeElement>
		<new set="method" line="58">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * Class constructor. Private as this class is meant to be used
	 * through its static methods
	 </haxe_doc>
		</new>
		<haxe_doc>
 * this class abstract and manages the interaction with a
 * native DOM element (e.g a DisplayObject in flash, an HTML element in JS...). Native elements are wrapped in 
 * NativeElement class instance.
 * 
 * It abstracts the creation of new native element by mimicking
 * the HTML way of creating new element.
 * 
 * This class proxies method call to runtime specific implementations
 * 
 * @author Yannick DOMINGUEZ
 </haxe_doc>
	</class>
	<class path="cocktailCore.style.floats.FloatsManager" params="" file="/Users/lexa/Documents/repositories/lexoyo_Cocktail/demo/games/libs/cocktailCore/style/floats/FloatsManager.hx">
		<_floats>
			<t path="cocktailCore.style.FloatsData"/>
			<haxe_doc>
	 * Holds a reference to each of the current left and right
	 * floats coordinates
	 </haxe_doc>
		</_floats>
		<floats public="1" get="getFloats" set="null"><t path="cocktailCore.style.FloatsData"/></floats>
		<addFloats public="1" set="method" line="62">
			<f a="parentFormattingContext">
				<c path="cocktailCore.style.formatter.FormattingContext"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Retrieve all the floats from the previous formatting context as until a float is removed,
	 * it applies to each of the formatting contexts following the one where it is added.
	 * 
	 * The float coordinates are converted from global (the parent formatting context space) to
	 * local (the current formatting context space)
	 </haxe_doc>
		</addFloats>
		<retrieveFloats public="1" set="method" line="85">
			<f a="childrenFormattingContext">
				<c path="cocktailCore.style.formatter.FormattingContext"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * When a formatting context is done laying out its children, it retrieves the
	 * floats from its children that are not yet removed.
	 * 
	 * The retrieved floats will be used during the layout of the containing DOMElemenet
	 * of the formatting context itself.
	 * 
	 </haxe_doc>
		</retrieveFloats>
		<globalTolocal set="method" line="111">
			<f a="floatData:flowData">
				<t path="cocktailCore.style.FloatData"/>
				<t path="cocktailCore.style.FlowData"/>
				<t path="cocktailCore.style.FloatData"/>
			</f>
			<haxe_doc>
	 * Takes a float in a global space (the one of the parent formatting context) and
	 * converting to the space of the current formatting context
	 * 
	 * @param floatData the global coord of the float
	 * @param flowData the flow data of the parent formatting context
	 </haxe_doc>
		</globalTolocal>
		<clearFloat public="1" set="method" line="145">
			<f a="clear:flowData">
				<e path="cocktail.style.ClearStyleValue"/>
				<t path="cocktailCore.style.FlowData"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
	 * Clears the left, right or both floats and return the new y position of
	 * the flow, the one below the cleared floats.
	 * 
	 * Empties the cleared floats array(s)
	 * 
	 * @param	clear the type of clearance (left, right or both)
	 * @param	flowData used to compute the new flowData y position
	 * @return  the new flowData y position
	 </haxe_doc>
		</clearFloat>
		<clearLeft set="method" line="174">
			<f a="flowData">
				<t path="cocktailCore.style.FlowData"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
	 * Clear left floats
	 </haxe_doc>
		</clearLeft>
		<clearRight set="method" line="182">
			<f a="flowData">
				<t path="cocktailCore.style.FlowData"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
	 * Clear right floats
	 </haxe_doc>
		</clearRight>
		<clearBoth set="method" line="190">
			<f a="flowData">
				<t path="cocktailCore.style.FlowData"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
	 * Clear right and left floats
	 </haxe_doc>
		</clearBoth>
		<doClearFloat set="method" line="214">
			<f a="flowData:floats">
				<t path="cocktailCore.style.FlowData"/>
				<c path="Array"><t path="cocktailCore.style.FloatData"/></c>
				<c path="Int"/>
			</f>
			<haxe_doc>
	 * Actually clears a set of float (right or left). Finds the highest
	 * float among the cleared float and return its height + y as the new
	 * flowData y position
	 * 
	 * @param flowData the current flowData, its y value is returned if there are no 
	 * floats to clear
	 * @param floats an array of floats to clear (right or left)
	 </haxe_doc>
		</doClearFloat>
		<computeFloatData public="1" set="method" line="253">
			<f a="domElement:flowData:containingBlockWidth">
				<t path="cocktail.domElement.DOMElement"/>
				<t path="cocktailCore.style.FlowData"/>
				<c path="Int"/>
				<t path="cocktailCore.style.FloatData"/>
			</f>
			<haxe_doc>
	 * Create and store a float data structure from a floated DOMElement
	 * @param	domElement the floated DOMElement
	 * @param	flowData the flow data of the formatting context placing the floated
	 * DOMElement
	 </haxe_doc>
		</computeFloatData>
		<getLeftFloatData set="method" line="277">
			<f a="domElement:flowData:containingBlockWidth">
				<t path="cocktail.domElement.DOMElement"/>
				<t path="cocktailCore.style.FlowData"/>
				<c path="Int"/>
				<t path="cocktailCore.style.FloatData"/>
			</f>
			<haxe_doc>
	 * Create a float data structure for a left float
	 </haxe_doc>
		</getLeftFloatData>
		<getRightFloatData set="method" line="292">
			<f a="domElement:flowData:containingBlockWidth">
				<t path="cocktail.domElement.DOMElement"/>
				<t path="cocktailCore.style.FlowData"/>
				<c path="Int"/>
				<t path="cocktailCore.style.FloatData"/>
			</f>
			<haxe_doc>
	 * Create a float data structure for a right float
	 </haxe_doc>
		</getRightFloatData>
		<getFloatData set="method" line="308">
			<f a="domElement:flowData:containingBlockWidth">
				<t path="cocktail.domElement.DOMElement"/>
				<t path="cocktailCore.style.FlowData"/>
				<c path="Int"/>
				<t path="cocktailCore.style.FloatData"/>
			</f>
			<haxe_doc>
	 * Create a generic float data structure which can be applied to both
	 * left and right float
	 </haxe_doc>
		</getFloatData>
		<getFirstAvailableY public="1" set="method" line="338">
			<f a="flowData:elementWidth:containingBlockWidth">
				<t path="cocktailCore.style.FlowData"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
	 * Get the first y position in the current flow where an element
	 * (float or DOMElement) with a width equal to elementWidth can be inserted
	 * without overlapping floats or other DOMElements
	 * @param	flowData the current flowData
	 * @param	elementWidth the width of the element that must be inserted
	 * @param	containingBlockWidth the maximum available width in a line
	 * @return  the y position where the element can be inserted
	 </haxe_doc>
		</getFirstAvailableY>
		<removeFloats public="1" set="method" line="421">
			<f a="flowY">
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Removes the float that are above the current flow
	 * @param	flowY the y position of the current flow
	 </haxe_doc>
		</removeFloats>
		<doRemoveFloat set="method" line="431">
			<f a="floats:flowY">
				<c path="Array"><t path="cocktailCore.style.FloatData"/></c>
				<c path="Int"/>
				<c path="Array"><t path="cocktailCore.style.FloatData"/></c>
			</f>
			<haxe_doc>
	 * Do removes the floats among an array of floats (left or right)
	 * which are above the current y flow
	 </haxe_doc>
		</doRemoveFloat>
		<getRightFloatOffset public="1" set="method" line="458">
			<f a="y:containingWidth">
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
	 * Return the right float offset at a y position. The right float offset is
	 * the added width of all the right floats which would be intersected if an horizontal
	 * line was drawn at the y position.
	 * 
	 </haxe_doc>
		</getRightFloatOffset>
		<getLeftFloatOffset public="1" set="method" line="488">
			<f a="y">
				<c path="Int"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
	 * Return the left float offset at a y position. The left float offset is
	 * the added width of all the left floats which would be intersected if an horizontal
	 * line was drawn at the y position.
	 * 
	 </haxe_doc>
		</getLeftFloatOffset>
		<getFloats set="method" line="516"><f a=""><t path="cocktailCore.style.FloatsData"/></f></getFloats>
		<new public="1" set="method" line="38">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * Class constructor, init the structure holding
	 * the floats data
	 </haxe_doc>
		</new>
		<haxe_doc>
 * This class is in charge of keeping track of the 
 * floats currently affecting layout and exposes
 * method to help the formatting context to apply
 * floats to the layout.
 * 
 * @author Yannick DOMINGUEZ
 </haxe_doc>
	</class>
	<typedef path="haxe.PosInfos" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/haxe/PosInfos.hx"><a>
	<methodName><c path="String"/></methodName>
	<lineNumber><c path="Int"/></lineNumber>
	<fileName><c path="String"/></fileName>
	<customParams><c path="Array"><d/></c></customParams>
	<className><c path="String"/></className>
</a></typedef>
	<class path="cocktailCore.domElement.js.GraphicDOMElement" params="" file="/Users/lexa/Documents/repositories/lexoyo_Cocktail/demo/games/libs/cocktailCore/domElement/js/GraphicDOMElement.hx">
		<extends path="cocktailCore.domElement.abstract.AbstractGraphicDOMElement"/>
		<CAPS_STYLE_VALUE_NONE get="inline" set="null" line="31" static="1"><c path="String"/></CAPS_STYLE_VALUE_NONE>
		<CAPS_STYLE_VALUE_ROUND get="inline" set="null" line="33" static="1"><c path="String"/></CAPS_STYLE_VALUE_ROUND>
		<CAPS_STYLE_VALUE_SQUARE get="inline" set="null" line="35" static="1"><c path="String"/></CAPS_STYLE_VALUE_SQUARE>
		<JOINT_STYLE_VALUE_ROUND get="inline" set="null" line="41" static="1"><c path="String"/></JOINT_STYLE_VALUE_ROUND>
		<JOINT_STYLE_VALUE_MITER get="inline" set="null" line="43" static="1"><c path="String"/></JOINT_STYLE_VALUE_MITER>
		<JOINT_STYLE_VALUE_BEVEL get="inline" set="null" line="45" static="1"><c path="String"/></JOINT_STYLE_VALUE_BEVEL>
		<CANVAS_PATTERN_REPEAT get="inline" set="null" line="51" static="1"><c path="String"/></CANVAS_PATTERN_REPEAT>
		<CANVAS_PATTERN_NO_REPEAT get="inline" set="null" line="53" static="1"><c path="String"/></CANVAS_PATTERN_NO_REPEAT>
		<beginFill public="1" set="method" line="74" override="1">
			<f a="?fillStyle:?lineStyle">
				<e path="cocktail.domElement.FillStyleValue"/>
				<e path="cocktail.domElement.LineStyleValue"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Set the native Canvas fill style and line style
	 * @param	fillStyle
	 * @param	lineStyle
	 </haxe_doc>
		</beginFill>
		<endFill public="1" set="method" line="88" override="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * Ends a fill on the Canvas graphic object, filling and stroking
	 * the drawn path
	 </haxe_doc>
		</endFill>
		<clear public="1" set="method" line="102" override="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * Clears the Canvas
	 </haxe_doc>
		</clear>
		<setFillStyle set="method" line="117" override="1">
			<f a="fillStyle">
				<e path="cocktail.domElement.FillStyleValue"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Do set the fill style on the canvas
	 </haxe_doc>
		</setFillStyle>
		<setLineStyle set="method" line="145" override="1">
			<f a="lineStyle">
				<e path="cocktail.domElement.LineStyleValue"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Do set the line style on the canvas
	 </haxe_doc>
		</setLineStyle>
		<drawImage public="1" set="method" line="180" override="1">
			<f a="source:?destinationPoint:?sourceRect">
				<c path="cocktailCore.domElement.js.ImageDOMElement"/>
				<t path="cocktail.geom.PointData"/>
				<t path="cocktail.geom.RectangleData"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Draw a bitmap extracted from an ImageDOMElement onto the canvas.
	 </haxe_doc>
		</drawImage>
		<lineTo public="1" set="method" line="230" override="1">
			<f a="x:y">
				<c path="Float"/>
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Use the native JavaScript lineTo method
	 </haxe_doc>
		</lineTo>
		<moveTo public="1" set="method" line="239" override="1">
			<f a="x:y">
				<c path="Float"/>
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Use the native JavaScript moveTo method
	 </haxe_doc>
		</moveTo>
		<curveTo public="1" set="method" line="248" override="1">
			<f a="controlX:controlY:x:y">
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Use the native JavaScript quadraticCurveTo method
	 </haxe_doc>
		</curveTo>
		<toNativeAlpha set="method" line="261" override="1">
			<f a="genericAlpha">
				<c path="Int"/>
				<d/>
			</f>
			<haxe_doc>
	 * in JavaScript rgba color space, alpha range from 0 to 1
	 </haxe_doc>
		</toNativeAlpha>
		<toNativeRatio set="method" line="269" override="1">
			<f a="genericRatio">
				<c path="Int"/>
				<d/>
			</f>
			<haxe_doc>
	 * in a JavaScript gradient, color ratio range from 0 to 1
	 </haxe_doc>
		</toNativeRatio>
		<toNativeCapStyle set="method" line="277" override="1">
			<f a="genericCapStyle">
				<e path="cocktail.domElement.CapsStyleValue"/>
				<d/>
			</f>
			<haxe_doc>
	 * in JavaScript, caps styles are String
	 </haxe_doc>
		</toNativeCapStyle>
		<toNativeJointStyle set="method" line="299" override="1">
			<f a="genericJointStyle">
				<e path="cocktail.domElement.JointStyleValue"/>
				<d/>
			</f>
			<haxe_doc>
	 * in JavaScript, joint styles are String
	 </haxe_doc>
		</toNativeJointStyle>
		<colorStopToRGBA set="method" line="327">
			<f a="colorStop">
				<t path="cocktail.domElement.ColorStopData"/>
				<c path="String"/>
			</f>
			<haxe_doc>
	 * Convert a color stored as an Int and it's alpha to an rgba string
	 * @param	colorStop contains the color value and it's alpha
	 * @return an rgba string, used for CSS styling
	 </haxe_doc>
		</colorStopToRGBA>
		<getHexColor set="method" line="337">
			<f a="color">
				<c path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>
	 * Convert an color stores as an int to its hexadecimal representation
	 * @return an hexa, starting with # and might be padded with 0
	 </haxe_doc>
		</getHexColor>
		<hexToRGB set="method" line="353">
			<f a="hex">
				<c path="String"/>
				<t path="cocktail.domElement.RGBData"/>
			</f>
			<haxe_doc>
	 * Converts an hexadecimal to it's rgb representation
	 * @return an RGB typedef, with 3 value ranging from 0 to 255
	 </haxe_doc>
		</hexToRGB>
		<initLineStyle set="method" line="371">
			<f a="lineStyleData">
				<t path="cocktail.domElement.LineStyleData"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Inits the line style of the canvas element, set all the 
	 * attributes of it but the stroke style
	 </haxe_doc>
		</initLineStyle>
		<getContext set="method" line="391">
			<f a=""><d/></f>
			<haxe_doc>
	 * Return the 2d canvas context of the native Canvas element
	 </haxe_doc>
		</getContext>
		<getCanvasPattern set="method" line="403">
			<f a="imageDOMElement:repeat">
				<c path="cocktailCore.domElement.js.DOMElement"/>
				<e path="Bool"/>
				<d/>
			</f>
			<haxe_doc><![CDATA[
	 * Create and return a JavaScript CanvasPattern object, used to draw
	 * picture on a canvas
	 * @param	imageDOMElement the imageDomObject whose native <img> element will create the 
	 * CanvasPattern
	 * @param	repeat whether to tile the CanvasPattern
	 ]]></haxe_doc>
		</getCanvasPattern>
		<getGradient set="method" line="428">
			<f a="gradientStyle">
				<t path="cocktail.domElement.GradientStyleData"/>
				<d/>
			</f>
			<haxe_doc>
	 * Create and return a JavaScript CanvasGradient object, used to draw a gradient
	 * on the Canvas
	 </haxe_doc>
		</getGradient>
		<new public="1" set="method" line="58">
			<f a="?nativeElement">
				<t path="cocktail.nativeElement.NativeElement"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * class constructor
	 </haxe_doc>
		</new>
		<haxe_doc>
 * This is the JavaScript implementation of the graphic DOMElement.
 * It draws shape programatically onto an HTML Canvas element
 * 
 * @author Yannick DOMINGUEZ
 </haxe_doc>
	</class>
	<typedef path="cocktailCore.domElement.ContainerDOMElementChildData" params="" file="/Users/lexa/Documents/repositories/lexoyo_Cocktail/demo/games/libs/cocktailCore/domElement/DOMElementData.hx" module="cocktailCore.domElement.DOMElementData">
		<a>
			<type><e path="cocktailCore.domElement.ContainerDOMElementChildValue"/></type>
			<child><d/></child>
		</a>
		<haxe_doc>
	 * ContainerDOMElement can have both DOMElement and TextElement
	 * as children. This structures holds of reference to the
	 * children and to its type
	 </haxe_doc>
	</typedef>
	<typedef path="cocktailCore.domElement.TextElementData" params="" file="/Users/lexa/Documents/repositories/lexoyo_Cocktail/demo/games/libs/cocktailCore/domElement/DOMElementData.hx" module="cocktailCore.domElement.DOMElementData">
		<a>
			<textTokens><c path="Array"><e path="cocktailCore.domElement.TextTokenValue"/></c></textTokens>
			<text><c path="String"/></text>
		</a>
		<haxe_doc>
	 * Holds the data of a text element, which
	 * is a string added to a ContainerDOMElement
	 * and taking its styles once rendered.
	 * 
	 * Keep a reference to the string of text
	 * and to the tokenised string of text
	 </haxe_doc>
	</typedef>
	<enum path="cocktailCore.domElement.TextTokenValue" params="" file="/Users/lexa/Documents/repositories/lexoyo_Cocktail/demo/games/libs/cocktailCore/domElement/DOMElementData.hx" module="cocktailCore.domElement.DOMElementData">
		<word a="value">
			<c path="String"/>
			<haxe_doc>
		 * a word, surrounded by
		 * spaces
		 </haxe_doc>
		</word>
		<tab><haxe_doc>
		 * a tabulation
		 </haxe_doc></tab>
		<space><haxe_doc>
		 * represents one
		 * space which can be 
		 * between 2 words or among
		 * a space sequence
		 </haxe_doc></space>
		<lineFeed><haxe_doc>
		 * a line feed (starts
		 * a new line)
		 </haxe_doc></lineFeed>
		<haxe_doc>
	 * Lists all the different consituant
	 * of a plain text, including 
	 * controls characters
	 </haxe_doc>
	</enum>
	<enum path="cocktailCore.domElement.ContainerDOMElementChildValue" params="" file="/Users/lexa/Documents/repositories/lexoyo_Cocktail/demo/games/libs/cocktailCore/domElement/DOMElementData.hx" module="cocktailCore.domElement.DOMElementData">
		<textElement/>
		<domElement/>
		<haxe_doc>
	 * The types of children a ContainerDOMElement
	 * can have
	 </haxe_doc>
	</enum>
	<class path="cocktailCore.resource.abstract.AbstractImageLoader" params="" file="/Users/lexa/Documents/repositories/lexoyo_Cocktail/demo/games/libs/cocktailCore/resource/abstract/AbstractImageLoader.hx">
		<extends path="cocktailCore.resource.js.ResourceLoader"/>
		<new public="1" set="method" line="29">
			<f a="?nativeElement">
				<t path="cocktail.nativeElement.NativeElement"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * class constructor
	 </haxe_doc>
		</new>
		<haxe_doc>
 * This class is in charge of loading a picture. When multiple
 * pictures are loaded with the same instance, the picture is 
 * replaced
 * 
 * @author Yannick DOMINGUEZ
 </haxe_doc>
	</class>
	<class path="Enum" params="T" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/Enum.hx" extern="1"><haxe_doc>
	An abstract type that represents an Enum.
	See [Type] for the haXe Reflection API.
</haxe_doc></class>
	<enum path="cocktail.style.FontSizeStyleValue" params="" file="/Users/lexa/Documents/repositories/lexoyo_Cocktail/demo/games/libs/cocktail/style/StyleData.hx" module="cocktail.style.StyleData">
		<relativeSize a="value">
			<e path="cocktail.unit.FontSizeRelativeSizeValue"/>
			<haxe_doc>
		 * Define if the font should be larger or smaller
		 * than its parent's font. The closest absolute
		 * size is determined using the parent computed
		 * font size and this absolute size is used as
		 * the font size
		 </haxe_doc>
		</relativeSize>
		<percentage a="value">
			<c path="Int"/>
			<haxe_doc>
		 * a percentage of the containing block
		 * font size
		 </haxe_doc>
		</percentage>
		<length a="value">
			<e path="cocktail.unit.LengthValue"/>
			<haxe_doc>
		 * absolute font size
		 </haxe_doc>
		</length>
		<absoluteSize a="value">
			<e path="cocktail.unit.FontSizeAbsoluteSizeValue"/>
			<haxe_doc>
		 * use a keyword indexed to a specified dimension.
		 * For instance in a desktop browser, an absolute
		 * size of medium maps to 16 pixels.
		 </haxe_doc>
		</absoluteSize>
		<haxe_doc>
	 * Controls the em box size
	 * of a font.
	 </haxe_doc>
	</enum>
	<enum path="cocktail.style.FontWeightStyleValue" params="" file="/Users/lexa/Documents/repositories/lexoyo_Cocktail/demo/games/libs/cocktail/style/StyleData.hx" module="cocktail.style.StyleData">
		<normal/>
		<bold/>
		<haxe_doc>
	 * Controls the weight of the
	 * font
	 </haxe_doc>
	</enum>
	<enum path="cocktail.style.FontStyleStyleValue" params="" file="/Users/lexa/Documents/repositories/lexoyo_Cocktail/demo/games/libs/cocktail/style/StyleData.hx" module="cocktail.style.StyleData">
		<normal/>
		<italic/>
		<haxe_doc>
	 * Controls wether the font
	 * is displayed in italic
	 </haxe_doc>
	</enum>
	<enum path="cocktail.style.FontFamilyStyleValue" params="" file="/Users/lexa/Documents/repositories/lexoyo_Cocktail/demo/games/libs/cocktail/style/StyleData.hx" module="cocktail.style.StyleData">
		<genericFamily a="genericName">
			<e path="cocktail.style.GenericFontFamilyValue"/>
			<haxe_doc>
		 * A generic family name, most
		 * likely used as a fallback
		 * if a more specific font 
		 * wasn't available
		 </haxe_doc>
		</genericFamily>
		<familyName a="name">
			<c path="String"/>
			<haxe_doc>
		 * A custom font family name
		 </haxe_doc>
		</familyName>
		<haxe_doc>
	 * Lists the type of font which can
	 * be affected to a text 
	 </haxe_doc>
	</enum>
	<enum path="cocktail.style.GenericFontFamilyValue" params="" file="/Users/lexa/Documents/repositories/lexoyo_Cocktail/demo/games/libs/cocktail/style/StyleData.hx" module="cocktail.style.StyleData">
		<serif/>
		<sansSerif/>
		<monospace/>
		<haxe_doc>
	 * Lists the available generic 
	 * font families
	 </haxe_doc>
	</enum>
	<enum path="cocktail.style.FontVariantStyleValue" params="" file="/Users/lexa/Documents/repositories/lexoyo_Cocktail/demo/games/libs/cocktail/style/StyleData.hx" module="cocktail.style.StyleData">
		<smallCaps/>
		<normal/>
		<haxe_doc>
	 * Controls wether text is
	 * displayed as small caps, where
	 * lowercase charachters look like
	 * smaller uppercase characters
	 </haxe_doc>
	</enum>
	<enum path="cocktail.style.WhiteSpaceStyleValue" params="" file="/Users/lexa/Documents/repositories/lexoyo_Cocktail/demo/games/libs/cocktail/style/StyleData.hx" module="cocktail.style.StyleData">
		<preWrap><haxe_doc>
		 * This value prevents user agents from collapsing sequences
		 * of white space. Lines are broken at preserved newline
		 * characters, and as necessary to fill line boxes.
		 </haxe_doc></preWrap>
		<preLine><haxe_doc>
		 * This value directs user agents to collapse sequences of white space.
		 * Lines are broken at preserved newline characters,
		 * and as necessary to fill line boxes.
		 </haxe_doc></preLine>
		<pre><haxe_doc>
		 * This value prevents user agents from collapsing
		 * sequences of white space. Lines are only broken at
		 * preserved newline characters.
		 </haxe_doc></pre>
		<nowrap><haxe_doc>
		 * This value collapses white space as for 'normal',
		 * but suppresses line breaks within text.
		 </haxe_doc></nowrap>
		<normal><haxe_doc>
		 * This value directs user agents to collapse sequences
		 * of white space, and break lines as necessary to fill line boxes.
		 </haxe_doc></normal>
		<haxe_doc>
	 * Controls how white space inside
	 * a DOMElement is handled
	 </haxe_doc>
	</enum>
	<enum path="cocktail.style.LetterSpacingStyleValue" params="" file="/Users/lexa/Documents/repositories/lexoyo_Cocktail/demo/games/libs/cocktail/style/StyleData.hx" module="cocktail.style.StyleData">
		<normal><haxe_doc>
		 * Use the default spacing of
		 * the chosen font
		 </haxe_doc></normal>
		<length a="value">
			<e path="cocktail.unit.LengthValue"/>
			<haxe_doc>
		 * A length to add to the 
		 * default spacing of the font,
		 * might be negative.
		 </haxe_doc>
		</length>
		<haxe_doc>
	 * Controls the amount of space
	 * between 2 letter in a text.
	 </haxe_doc>
	</enum>
	<enum path="cocktail.style.WordSpacingStyleValue" params="" file="/Users/lexa/Documents/repositories/lexoyo_Cocktail/demo/games/libs/cocktail/style/StyleData.hx" module="cocktail.style.StyleData">
		<normal><haxe_doc>
		 * Use the default inter-word
		 * spacing of the chosen font
		 </haxe_doc></normal>
		<length a="value">
			<e path="cocktail.unit.LengthValue"/>
			<haxe_doc>
		 * A length to add to each space
		 * character, might be negative
		 </haxe_doc>
		</length>
		<haxe_doc>
	 * Controls the amount of space between
	 * two words in a text
	 </haxe_doc>
	</enum>
	<enum path="cocktail.style.TextIndentStyleValue" params="" file="/Users/lexa/Documents/repositories/lexoyo_Cocktail/demo/games/libs/cocktail/style/StyleData.hx" module="cocktail.style.StyleData">
		<percentage a="value">
			<c path="Int"/>
			<haxe_doc>
		 * a percentage of the containing block
		 * width
		 </haxe_doc>
		</percentage>
		<length a="value">
			<e path="cocktail.unit.LengthValue"/>
			<haxe_doc>
		 * An absolute value for the text indentation
		 </haxe_doc>
		</length>
		<haxe_doc>
	 * Controls the indentation of the
	 * first line of text in a block of text
	 * with respect to the containing block
	 </haxe_doc>
	</enum>
	<enum path="cocktail.style.TextAlignStyleValue" params="" file="/Users/lexa/Documents/repositories/lexoyo_Cocktail/demo/games/libs/cocktail/style/StyleData.hx" module="cocktail.style.StyleData">
		<right/>
		<left/>
		<justify/>
		<center/>
		<haxe_doc>
	 * Controls how inline DOMElement inside
	 * a block container is aligned
	 </haxe_doc>
	</enum>
	<enum path="cocktail.style.TextTransformStyleValue" params="" file="/Users/lexa/Documents/repositories/lexoyo_Cocktail/demo/games/libs/cocktail/style/StyleData.hx" module="cocktail.style.StyleData">
		<uppercase/>
		<none/>
		<lowercase/>
		<capitalize/>
		<haxe_doc>
	 * Controls wether all charachters
	 * in a text are transformed to
	 * uppercase, lowercase or capitalised
	 * (only first letter of each word is
	 * set to uppercase)
	 </haxe_doc>
	</enum>
	<enum path="cocktail.style.LineHeightStyleValue" params="" file="/Users/lexa/Documents/repositories/lexoyo_Cocktail/demo/games/libs/cocktail/style/StyleData.hx" module="cocktail.style.StyleData">
		<percentage a="value">
			<c path="Int"/>
			<haxe_doc>
		 * With this value, the computed value of the line height 
		 * is equal to this percentage multiplied by the font size
		 </haxe_doc>
		</percentage>
		<number a="value">
			<c path="Float"/>
			<haxe_doc>
		 * With this value, the computed value of the line height 
		 * is equal to this number multiplied by the font size
		 </haxe_doc>
		</number>
		<normal><haxe_doc>
		 * Use a "reasonnable" line height value which
		 * is equal to the font size.
		 </haxe_doc></normal>
		<length a="value">
			<e path="cocktail.unit.LengthValue"/>
			<haxe_doc>
		 * absolute line height value
		 </haxe_doc>
		</length>
		<haxe_doc>
	 * On a container DOMElement with inline level
	 * children, this style controls the minimum height
	 * of each line 
	 * 
	 * On a non-embedded inline DOMElement, it controls
	 * the height of the DOMElement, used to calculate
	 * its line height
	 </haxe_doc>
	</enum>
	<enum path="cocktail.style.VerticalAlignStyleValue" params="" file="/Users/lexa/Documents/repositories/lexoyo_Cocktail/demo/games/libs/cocktail/style/StyleData.hx" module="cocktail.style.StyleData">
		<top><haxe_doc>
		 * Align the top of the aligned subtree with 
		 * the top of the line box.
		 </haxe_doc></top>
		<textTop><haxe_doc>
		 * Align the top of the box with the top of the
		 * parent's content area
		 </haxe_doc></textTop>
		<textBottom><haxe_doc>
		 * Align the bottom of the box with the bottom of the 
		 * parent's content area
		 </haxe_doc></textBottom>
		<superStyle><haxe_doc>
		 * Raise the baseline of the box to the proper 
		 * position for superscripts of the parent's box.
		 * 
		 * n.b: appended 'Style' to 'super' because 'super'
		 * is a reserved HaXe word
		 </haxe_doc></superStyle>
		<sub><haxe_doc>
		 * Lower the baseline of the box to the proper 
		 * position for subscripts of the parent's box
		 </haxe_doc></sub>
		<percent a="value">
			<c path="Int"/>
			<haxe_doc>
		 * a positive value raise the box, a
		 * negative lowers it, by taking the
		 * parent baseline as reference for
		 * 0%
		 </haxe_doc>
		</percent>
		<middle><haxe_doc>
		 * Align the vertical midpoint of the box with the baseline
		 * of the parent box plus half the x-height of the parent.
		 </haxe_doc></middle>
		<length a="value">
			<e path="cocktail.unit.LengthValue"/>
			<haxe_doc>
		 * a positive value raise the box, a
		 * negative lowers it, by taking the
		 * parent baseline as reference for
		 * 0
		 </haxe_doc>
		</length>
		<bottom><haxe_doc>
		 * Align the bottom of the aligned subtree with the 
		 * bottom of the line box.
		 </haxe_doc></bottom>
		<baseline><haxe_doc>
		 * Align the baseline of the box with the baseline
		 * of the parent box. If the box does not have a
		 * baseline, align the bottom margin edge with 
		 * the parent's baseline.
		 </haxe_doc></baseline>
		<haxe_doc>
	 * Controls the vertical alignement of an 
	 * inline DOMElement in its containing
	 * DOMElement
	 </haxe_doc>
	</enum>
	<enum path="cocktail.style.MarginStyleValue" params="" file="/Users/lexa/Documents/repositories/lexoyo_Cocktail/demo/games/libs/cocktail/style/StyleData.hx" module="cocktail.style.StyleData">
		<percent a="value">
			<c path="Int"/>
			<haxe_doc>
		 * thickness relatvie to the
		 * parent DOMElement's widthor height
		 </haxe_doc>
		</percent>
		<length a="value">
			<e path="cocktail.unit.LengthValue"/>
			<haxe_doc>
		 * absolute thickness
		 </haxe_doc>
		</length>
		<auto><haxe_doc>
		 * Margin takes the remaining space
		 * in the parent DOMElement width or height
		 </haxe_doc></auto>
		<haxe_doc>
	 * Dimensions values for margin thickness
	 </haxe_doc>
	</enum>
	<enum path="cocktail.style.PaddingStyleValue" params="" file="/Users/lexa/Documents/repositories/lexoyo_Cocktail/demo/games/libs/cocktail/style/StyleData.hx" module="cocktail.style.StyleData">
		<percent a="value">
			<c path="Int"/>
			<haxe_doc>
		 * thickness relative to the
		 * parent DOMElement width or height
		 </haxe_doc>
		</percent>
		<length a="value">
			<e path="cocktail.unit.LengthValue"/>
			<haxe_doc>
		 * absolute thickness
		 </haxe_doc>
		</length>
		<haxe_doc>
	 * Dimensions value for padding thickness
	 </haxe_doc>
	</enum>
	<enum path="cocktail.style.DimensionStyleValue" params="" file="/Users/lexa/Documents/repositories/lexoyo_Cocktail/demo/games/libs/cocktail/style/StyleData.hx" module="cocktail.style.StyleData">
		<percent a="value">
			<c path="Int"/>
			<haxe_doc>
		 * relative the parent DOMElement
		 * dimensions
		 </haxe_doc>
		</percent>
		<length a="value">
			<e path="cocktail.unit.LengthValue"/>
			<haxe_doc>
		 * absolute value
		 </haxe_doc>
		</length>
		<auto><haxe_doc>
		 * takes the remaining space in
		 * the parent element width or 
		 * height
		 </haxe_doc></auto>
		<haxe_doc>
	 * The dimension of the content of 
	 * a DOMElement (without margins 
	 * and paddings)
	 </haxe_doc>
	</enum>
	<enum path="cocktail.style.ConstrainedDimensionStyleValue" params="" file="/Users/lexa/Documents/repositories/lexoyo_Cocktail/demo/games/libs/cocktail/style/StyleData.hx" module="cocktail.style.StyleData">
		<percent a="value">
			<c path="Int"/>
			<haxe_doc>
		 * relative to the parent DOMElement
		 * dimensions 
		 </haxe_doc>
		</percent>
		<none><haxe_doc>
		 * No constraint is enforced
		 </haxe_doc></none>
		<length a="value">
			<e path="cocktail.unit.LengthValue"/>
			<haxe_doc>
		 * absolute value
		 </haxe_doc>
		</length>
		<haxe_doc>
	 * The constraint applied to the content
	 * of a DOMElement contrained its max/min
	 * width or height
	 </haxe_doc>
	</enum>
	<enum path="cocktail.style.DisplayStyleValue" params="" file="/Users/lexa/Documents/repositories/lexoyo_Cocktail/demo/games/libs/cocktail/style/StyleData.hx" module="cocktail.style.StyleData">
		<none><haxe_doc>
		 * The DOMElement isn't displays
		 * and doesn't influence the flow
		 </haxe_doc></none>
		<inlineStyle><haxe_doc>
		 * Displayed on the current line. 
		 * Can only have horizontal margins
		 * and paddings
		 * 
		 * n.b : appended 'Style' to 'inline'
		 * because inline is a reserved HaXe 
		 * word
		 </haxe_doc></inlineStyle>
		<inlineBlock><haxe_doc>
		 * Displays as block but is placed
		 * on the current line in the flow
		 </haxe_doc></inlineBlock>
		<block><haxe_doc>
		 * add a line break before 
		 * and after the DOMElement. Act
		 * as a box with margins, paddings
		 * and dimensions
		 </haxe_doc></block>
		<haxe_doc>
	 * Display of a DOMElement in a 
	 * DOMElements flow
	 </haxe_doc>
	</enum>
	<enum path="cocktail.style.FloatStyleValue" params="" file="/Users/lexa/Documents/repositories/lexoyo_Cocktail/demo/games/libs/cocktail/style/StyleData.hx" module="cocktail.style.StyleData">
		<right/>
		<none/>
		<left/>
		<haxe_doc>
	 * A floated DOMElement is pushed to the
	 * left-most or the right-most of its container
	 </haxe_doc>
	</enum>
	<enum path="cocktail.style.ClearStyleValue" params="" file="/Users/lexa/Documents/repositories/lexoyo_Cocktail/demo/games/libs/cocktail/style/StyleData.hx" module="cocktail.style.StyleData">
		<right/>
		<none/>
		<left/>
		<both/>
		<haxe_doc>
	 * A DOMElement with clearance cancels a preceding
	 * float. It is placed below any preceding left
	 * or right float that it clears
	 </haxe_doc>
	</enum>
	<enum path="cocktail.style.PositionStyleValue" params="" file="/Users/lexa/Documents/repositories/lexoyo_Cocktail/demo/games/libs/cocktail/style/StyleData.hx" module="cocktail.style.StyleData">
		<staticStyle><haxe_doc>
		 * Appear after its parent in the flow, on a
		 * new line or the current one based on its
		 * display
		 * 
		 * n.b: appended 'Style' to 'static' because
		 * 'static' is a reserved HaXe word
		 </haxe_doc></staticStyle>
		<relative><haxe_doc>
		 * same as static but an offset can be applied
		 * with the top, left, right and bottom styles
		 * once the DOMElement is placed in the flow
		 </haxe_doc></relative>
		<fixed><haxe_doc>
		 * The DOMElement is outside the flow, it
		 * is placed using its left, right, bottom
		 * and top offsets, its origin being the first
		 * DOMElement (the one at the top of the 
		 * hierarchy)
		 </haxe_doc></fixed>
		<absolute><haxe_doc>
		 * The DOMElement is outside of the flow, it 
		 * is placed using its left, right, bottom and
		 * top offsets, its origin being its first ancestor
		 * with a position different from static
		 </haxe_doc></absolute>
		<haxe_doc>
	 * Determine how a DOMElement is positioned relative
	 * to its ancestors
	 </haxe_doc>
	</enum>
	<enum path="cocktail.style.PositionOffsetStyleValue" params="" file="/Users/lexa/Documents/repositories/lexoyo_Cocktail/demo/games/libs/cocktail/style/StyleData.hx" module="cocktail.style.StyleData">
		<percent a="value">
			<c path="Int"/>
			<haxe_doc>
		 * relative to the parent
		 * DOMElement width or heigt
		 </haxe_doc>
		</percent>
		<length a="value">
			<e path="cocktail.unit.LengthValue"/>
			<haxe_doc>
		 * absolute offset
		 </haxe_doc>
		</length>
		<auto><haxe_doc>
		 * no offset
		 </haxe_doc></auto>
		<haxe_doc>
	 * The offset applied to a DOMElement
	 * once positioned
	 </haxe_doc>
	</enum>
	<enum path="cocktail.style.VisibilityStyleValue" params="" file="/Users/lexa/Documents/repositories/lexoyo_Cocktail/demo/games/libs/cocktail/style/StyleData.hx" module="cocktail.style.StyleData">
		<visible><haxe_doc>
		 * The DOMElement is visible
		 </haxe_doc></visible>
		<hidden><haxe_doc>
		 * The DOMElement is invisible 
		 * (fully transparent, nothing is drawn),
		 * but still affects layout.
		 * Furthermore, children of the DOMElement will
		 * be visible if they have 'visibility: visible'.
		 </haxe_doc></hidden>
		<haxe_doc>
	 * Specifies wether the DOMElement is
	 * displayed. A hidden DOMElement
	 * still affects layout
	 </haxe_doc>
	</enum>
	<enum path="cocktail.style.OpacityStyleValue" params="" file="/Users/lexa/Documents/repositories/lexoyo_Cocktail/demo/games/libs/cocktail/style/StyleData.hx" module="cocktail.style.StyleData">
		<number a="value"><c path="Float"/></number>
		<haxe_doc>
	 * Specifies the transparency of a DOMElement
	 * where 1.0 is opaque and 0 is transparent
	 * 
	 * TODO n.b : implemented as an enum instead of just
	 * a float to make room for the 'inherit' value
	 </haxe_doc>
	</enum>
	<enum path="cocktail.style.TransformStyleValue" params="" file="/Users/lexa/Documents/repositories/lexoyo_Cocktail/demo/games/libs/cocktail/style/StyleData.hx" module="cocktail.style.StyleData">
		<transformFunctions a="transformFunctions">
			<c path="Array"><e path="cocktail.style.TransformFunctionValue"/></c>
			<haxe_doc>
		 * A list of transformations
		 * to apply in order
		 </haxe_doc>
		</transformFunctions>
		<none><haxe_doc>
		 * no transformations
		 </haxe_doc></none>
		<haxe_doc>
	 * Specifiy a list of transormation to apply
	 * to the DOMElement. The transformation
	 * are applied in order. The final 
	 * transformation is obtained by performing
	 * a matrix concatenation of each entry in the list
	 </haxe_doc>
	</enum>
	<enum path="cocktail.style.TransformFunctionValue" params="" file="/Users/lexa/Documents/repositories/lexoyo_Cocktail/demo/games/libs/cocktail/style/StyleData.hx" module="cocktail.style.StyleData">
		<translateY a="ty">
			<e path="cocktail.style.TranslationValue"/>
			<haxe_doc>
		 * specifies a translation by the given amount in the
		 * Y direction
		 </haxe_doc>
		</translateY>
		<translateX a="tx">
			<e path="cocktail.style.TranslationValue"/>
			<haxe_doc>
		 * specifies a translation by the given amount in the
		 * X direction
		 </haxe_doc>
		</translateX>
		<translate a="tx:ty">
			<e path="cocktail.style.TranslationValue"/>
			<e path="cocktail.style.TranslationValue"/>
			<haxe_doc>
		 * specify a 2D translation by the vector [tx, ty]
		 </haxe_doc>
		</translate>
		<skewY a="angle">
			<e path="cocktail.unit.AngleValue"/>
			<haxe_doc>
		 * specifies a skew transformation
		 * along the Y axis by the given angle.
		 </haxe_doc>
		</skewY>
		<skewX a="angle">
			<e path="cocktail.unit.AngleValue"/>
			<haxe_doc>
		 * specifies a skew transformation
		 * along the X axis by the given angle.
		 </haxe_doc>
		</skewX>
		<skew a="angleX:angleY">
			<e path="cocktail.unit.AngleValue"/>
			<e path="cocktail.unit.AngleValue"/>
			<haxe_doc>
		 * specifies a skew transformation 
		 * along the X and Y axes.
		 </haxe_doc>
		</skew>
		<scaleY a="sy">
			<c path="Float"/>
			<haxe_doc>
		 * Specifies a 2D scale operation by the
		 * [1, sy] scaling vector
		 </haxe_doc>
		</scaleY>
		<scaleX a="sx">
			<c path="Float"/>
			<haxe_doc>
		 * Specifies a 2D scale operation by the
		 * [sx, 1] scaling vector
		 </haxe_doc>
		</scaleX>
		<scale a="sx:sy">
			<c path="Float"/>
			<c path="Float"/>
			<haxe_doc>
		 * Specifies a 2D scale operation by the
		 * [sx, sy] scaling vector
		 </haxe_doc>
		</scale>
		<rotate a="angle">
			<e path="cocktail.unit.AngleValue"/>
			<haxe_doc>
		 * specifies a 2D rotation by the angle specified in the
		 * parameter about the origin of the element,
		 * as defined by the TransformOriginStyleValue property
		 </haxe_doc>
		</rotate>
		<matrix a="data">
			<t path="cocktail.geom.MatrixData"/>
			<haxe_doc>
		 * specify a 2D transformation in the form of
		 * a transformation matrix
		 </haxe_doc>
		</matrix>
		<haxe_doc>
	 * The list of allowed transform functions to
	 * apply to a DOMElement
	 </haxe_doc>
	</enum>
	<enum path="cocktail.style.TranslationValue" params="" file="/Users/lexa/Documents/repositories/lexoyo_Cocktail/demo/games/libs/cocktail/style/StyleData.hx" module="cocktail.style.StyleData">
		<percent a="value">
			<c path="Int"/>
			<haxe_doc>
		 * a percentage relative to the DOMElement
		 * dimensions
		 </haxe_doc>
		</percent>
		<length a="value">
			<e path="cocktail.unit.LengthValue"/>
			<haxe_doc>
		 * a length value
		 </haxe_doc>
		</length>
		<haxe_doc>
	 * The list of value allowed to 
	 * specify the amount of a translation
	 </haxe_doc>
	</enum>
	<typedef path="cocktail.style.TransformOriginStyleData" params="" file="/Users/lexa/Documents/repositories/lexoyo_Cocktail/demo/games/libs/cocktail/style/StyleData.hx" module="cocktail.style.StyleData">
		<a>
			<y>
				<e path="cocktail.style.TransformOriginYStyleValue"/>
				<haxe_doc>
		 * y axis origin
		 </haxe_doc>
			</y>
			<x><e path="cocktail.style.TransformOriginXStyleValue"/></x>
		</a>
		<haxe_doc>
	 * Specifies the origin of transformation
	 * for a DOMElement along the x and y
	 * axis
	 </haxe_doc>
	</typedef>
	<enum path="cocktail.style.TransformOriginXStyleValue" params="" file="/Users/lexa/Documents/repositories/lexoyo_Cocktail/demo/games/libs/cocktail/style/StyleData.hx" module="cocktail.style.StyleData">
		<right><haxe_doc>
		 * same as 100%
		 </haxe_doc></right>
		<percent a="value">
			<c path="Int"/>
			<haxe_doc>
		 * a percentage relative
		 * to the DOMElement's width
		 </haxe_doc>
		</percent>
		<length a="value">
			<e path="cocktail.unit.LengthValue"/>
			<haxe_doc>
		 * a length value
		 </haxe_doc>
		</length>
		<left><haxe_doc>
		 * same as 0%
		 </haxe_doc></left>
		<center><haxe_doc>
		 * same as 50%
		 </haxe_doc></center>
		<haxe_doc>
	 * The list of available transformation
	 * origin values for x axis
	 </haxe_doc>
	</enum>
	<enum path="cocktail.style.TransformOriginYStyleValue" params="" file="/Users/lexa/Documents/repositories/lexoyo_Cocktail/demo/games/libs/cocktail/style/StyleData.hx" module="cocktail.style.StyleData">
		<top><haxe_doc>
		 * same as 0%
		 </haxe_doc></top>
		<percent a="value">
			<c path="Int"/>
			<haxe_doc>
		 * a percentage relative
		 * to the DOMElement's height
		 </haxe_doc>
		</percent>
		<length a="value">
			<e path="cocktail.unit.LengthValue"/>
			<haxe_doc>
		 * a length value
		 </haxe_doc>
		</length>
		<center><haxe_doc>
		 * same as 50%
		 </haxe_doc></center>
		<bottom><haxe_doc>
		 * same as 100%
		 </haxe_doc></bottom>
		<haxe_doc>
	 * The list of available transformation
	 * origin values for y axis
	 </haxe_doc>
	</enum>
	<typedef path="cocktail.viewport.Viewport" params="" file="/Users/lexa/Documents/repositories/lexoyo_Cocktail/demo/games/libs/cocktail/viewport/Viewport.hx"><c path="cocktailCore.viewport.js.Viewport"/></typedef>
	<typedef path="cocktailCore.style.ContainingDOMElementData" params="" file="/Users/lexa/Documents/repositories/lexoyo_Cocktail/demo/games/libs/cocktailCore/style/StyleData.hx" module="cocktailCore.style.StyleData">
		<a>
			<width><c path="Int"/></width>
			<isWidthAuto><e path="Bool"/></isWidthAuto>
			<isHeightAuto><e path="Bool"/></isHeightAuto>
			<height><c path="Int"/></height>
			<globalY><c path="Int"/></globalY>
			<globalX><c path="Int"/></globalX>
		</a>
		<haxe_doc>
	 * Represents the width, height of a DOMElement's
	 * parent content, and it's global position, relative
	 * to the root DOMElement.
	 * Specify for each dimension if it is 'auto', 
	 * meaning it depends on its content
	 </haxe_doc>
	</typedef>
	<typedef path="cocktailCore.style.LastPositionedDOMElementData" params="" file="/Users/lexa/Documents/repositories/lexoyo_Cocktail/demo/games/libs/cocktailCore/style/StyleData.hx" module="cocktailCore.style.StyleData">
		<a>
			<data><t path="cocktailCore.style.ContainingDOMElementData"/></data>
			<children><c path="Array"><t path="cocktailCore.style.PositionedDOMElementData"/></c></children>
		</a>
		<haxe_doc>
	 * Contains the data of the first 
	 * positioned ancestor (a DOMElement with
	 * a position style of relative, absolute,
	 * or fixed) and a reference to each of
	 * the style objects using the data
	 * as origin to layout an absolutely
	 * positioned DOMElement.
	 </haxe_doc>
	</typedef>
	<typedef path="cocktailCore.style.PositionedDOMElementData" params="" file="/Users/lexa/Documents/repositories/lexoyo_Cocktail/demo/games/libs/cocktailCore/style/StyleData.hx" module="cocktailCore.style.StyleData">
		<a>
			<style><c path="cocktailCore.style.abstract.AbstractStyle"/></style>
			<staticPosition><t path="cocktail.geom.PointData"/></staticPosition>
		</a>
		<haxe_doc>
	 * Holds a reference to the Style of a
	 * positioned DOMElement. The static position
	 * is the x,y point where the DOMElement
	 * would have been if its position style
	 * had been 'static'.
	 * 
	 * It is used if left and right or
	 * top and bottom styles are both
	 * set to 'auto'
	 </haxe_doc>
	</typedef>
	<typedef path="cocktailCore.style.ComputedStyleData" params="" file="/Users/lexa/Documents/repositories/lexoyo_Cocktail/demo/games/libs/cocktailCore/style/StyleData.hx" module="cocktailCore.style.StyleData">
		<a>
			<wordSpacing><c path="Int"/></wordSpacing>
			<width><c path="Int"/></width>
			<whiteSpace><e path="cocktail.style.WhiteSpaceStyleValue"/></whiteSpace>
			<visibility><e path="Bool"/></visibility>
			<verticalAlign><c path="Float"/></verticalAlign>
			<transformOrigin><t path="cocktail.geom.PointData"/></transformOrigin>
			<transform><c path="cocktail.geom.Matrix"/></transform>
			<top><c path="Int"/></top>
			<textTransform>
				<e path="cocktail.style.TextTransformStyleValue"/>
				<haxe_doc>
		 * text
		 </haxe_doc>
			</textTransform>
			<textIndent><c path="Int"/></textIndent>
			<textAlign><e path="cocktail.style.TextAlignStyleValue"/></textAlign>
			<right><c path="Int"/></right>
			<position><e path="cocktail.style.PositionStyleValue"/></position>
			<paddingTop><c path="Int"/></paddingTop>
			<paddingRight><c path="Int"/></paddingRight>
			<paddingLeft>
				<c path="Int"/>
				<haxe_doc>
		 * paddings
		 </haxe_doc>
			</paddingLeft>
			<paddingBottom><c path="Int"/></paddingBottom>
			<opacity><c path="Float"/></opacity>
			<minWidth>
				<c path="Int"/>
				<haxe_doc>
		 * content dimensions constraints
		 </haxe_doc>
			</minWidth>
			<minHeight><c path="Int"/></minHeight>
			<maxWidth><c path="Int"/></maxWidth>
			<maxHeight><c path="Int"/></maxHeight>
			<marginTop><c path="Int"/></marginTop>
			<marginRight><c path="Int"/></marginRight>
			<marginLeft>
				<c path="Int"/>
				<haxe_doc>
		 * margins
		 </haxe_doc>
			</marginLeft>
			<marginBottom><c path="Int"/></marginBottom>
			<lineHeight><c path="Float"/></lineHeight>
			<letterSpacing><c path="Int"/></letterSpacing>
			<left>
				<c path="Int"/>
				<haxe_doc>
		 * position offset
		 </haxe_doc>
			</left>
			<height><c path="Int"/></height>
			<fontWeight><e path="cocktail.style.FontWeightStyleValue"/></fontWeight>
			<fontVariant><e path="cocktail.style.FontVariantStyleValue"/></fontVariant>
			<fontStyle><e path="cocktail.style.FontStyleStyleValue"/></fontStyle>
			<fontSize>
				<c path="Float"/>
				<haxe_doc>
		 * font
		 </haxe_doc>
			</fontSize>
			<fontFamily><c path="Array"><e path="cocktail.style.FontFamilyStyleValue"/></c></fontFamily>
			<float><e path="cocktail.style.FloatStyleValue"/></float>
			<display>
				<e path="cocktail.style.DisplayStyleValue"/>
				<haxe_doc>
		 * display
		 </haxe_doc>
			</display>
			<color><c path="Int"/></color>
			<clear><e path="cocktail.style.ClearStyleValue"/></clear>
			<bottom><c path="Int"/></bottom>
		</a>
		<haxe_doc>
	 * Stores all the computed styles
	 * of a DOMElement as they are 
	 * used multiple times when applying
	 * styles
	 </haxe_doc>
	</typedef>
	<typedef path="cocktailCore.style.DefaultStylesData" params="" file="/Users/lexa/Documents/repositories/lexoyo_Cocktail/demo/games/libs/cocktailCore/style/StyleData.hx" module="cocktailCore.style.StyleData">
		<a>
			<fontFamily><c path="Array"><e path="cocktail.style.FontFamilyStyleValue"/></c></fontFamily>
			<color><e path="cocktail.unit.ColorValue"/></color>
		</a>
		<haxe_doc>
	 * Holds a reference to default styles values.
	 * Those styles default values are defined by 
	 * the User Agent in JS, for Flash and other
	 * runtime they will be hard-coded in this
	 * structure.
	 </haxe_doc>
	</typedef>
	<typedef path="cocktailCore.style.FlowData" params="" file="/Users/lexa/Documents/repositories/lexoyo_Cocktail/demo/games/libs/cocktailCore/style/StyleData.hx" module="cocktailCore.style.StyleData">
		<a>
			<yOffset>
				<c path="Int"/>
				<haxe_doc>
		 * The y offset applied to the formatting context
		 * (matches the containing DOMElement top padding)
		 </haxe_doc>
			</yOffset>
			<y>
				<c path="Int"/>
				<haxe_doc>
		 * the y position where the next in flow DOMElement
		 * should be
		 </haxe_doc>
			</y>
			<xOffset>
				<c path="Int"/>
				<haxe_doc>
		 * The x offset applied to each starting line
		 * (matches the containing DOMElement left padding)
		 </haxe_doc>
			</xOffset>
			<x><c path="Int"/></x>
			<totalHeight>
				<c path="Int"/>
				<haxe_doc>
		 * The accumulated height of all the in flow DOMElements
		 * (includes paddings and margins)
		 </haxe_doc>
			</totalHeight>
			<maxWidth>
				<c path="Int"/>
				<haxe_doc>
		 * Determine the largest width of a line in
		 * a formatting context
		 </haxe_doc>
			</maxWidth>
		</a>
		<haxe_doc>
	 * Contains the data necessary to place
	 * a DOMElement in flow
	 </haxe_doc>
	</typedef>
	<typedef path="cocktailCore.style.FloatsData" params="" file="/Users/lexa/Documents/repositories/lexoyo_Cocktail/demo/games/libs/cocktailCore/style/StyleData.hx" module="cocktailCore.style.StyleData">
		<a>
			<right><c path="Array"><t path="cocktailCore.style.FloatData"/></c></right>
			<left><c path="Array"><t path="cocktailCore.style.FloatData"/></c></left>
		</a>
		<haxe_doc>
	 * Represents the left and right
	 * floats registered for a 
	 * container DOMElement
	 </haxe_doc>
	</typedef>
	<typedef path="cocktailCore.style.FloatData" params="" file="/Users/lexa/Documents/repositories/lexoyo_Cocktail/demo/games/libs/cocktailCore/style/StyleData.hx" module="cocktailCore.style.StyleData">
		<a>
			<y><c path="Int"/></y>
			<x><c path="Int"/></x>
			<width><c path="Int"/></width>
			<height><c path="Int"/></height>
		</a>
		<haxe_doc>
	 * Represents the coordinates and
	 * dimensions of the float in its
	 * parent coordinate space
	 </haxe_doc>
	</typedef>
	<typedef path="cocktailCore.style.FontMetricsData" params="" file="/Users/lexa/Documents/repositories/lexoyo_Cocktail/demo/games/libs/cocktailCore/style/StyleData.hx" module="cocktailCore.style.StyleData">
		<a>
			<xHeight>
				<c path="Int"/>
				<haxe_doc>
		 * This is a standard metrics used 
		 * to define a font size. Represents
		 * the height of a lowercase "x" glyph
		 * at the given font size
		 </haxe_doc>
			</xHeight>
			<underlineOffset>
				<c path="Int"/>
				<haxe_doc>
		 * A suggested offset to apply from
		 * the baseline when drawing underlines
		 </haxe_doc>
			</underlineOffset>
			<superscriptOffset>
				<c path="Int"/>
				<haxe_doc>
		 * A suggested offset to apply
		 * from the baseline for superscript
		 * glyphs
		 </haxe_doc>
			</superscriptOffset>
			<subscriptOffset>
				<c path="Int"/>
				<haxe_doc>
		 * A suggested offset to apply
		 * from the baseline for subscript
		 * glyphs
		 </haxe_doc>
			</subscriptOffset>
			<spaceWidth>
				<c path="Int"/>
				<haxe_doc>
		 * the width of a space character for
		 * a given font at a given size
		 </haxe_doc>
			</spaceWidth>
			<fontSize><c path="Float"/></fontSize>
			<descent>
				<c path="Int"/>
				<haxe_doc>
		 * A characteristic height
		 * of the font below the 
		 * baseline defined by
		 * the font creator. This is a metric
		 * for the font has a whole, 
		 * not specific to any glyphs
		 </haxe_doc>
			</descent>
			<ascent>
				<c path="Int"/>
				<haxe_doc>
		 * A characteristic height
		 * of the font above the 
		 * baseline defined by
		 * the font creator. This is a metric
		 * for the font has a whole, 
		 * not specific to any glyphs
		 </haxe_doc>
			</ascent>
		</a>
		<haxe_doc>
	 * Given a font family and a font size
	 * provided by the DOMElement's styles, 
	 * this structures return metrics info
	 * on the font
	 </haxe_doc>
	</typedef>
	<typedef path="cocktailCore.style.LineBoxElementData" params="" file="/Users/lexa/Documents/repositories/lexoyo_Cocktail/demo/games/libs/cocktailCore/style/StyleData.hx" module="cocktailCore.style.StyleData">
		<a>
			<domElementType><e path="cocktailCore.style.InlineBoxValue"/></domElementType>
			<domElement><t path="cocktail.domElement.DOMElement"/></domElement>
		</a>
		<haxe_doc>
	 * Defines a DOMElement added to a LineBox
	 * and its type
	 </haxe_doc>
	</typedef>
	<enum path="cocktailCore.style.InlineBoxValue" params="" file="/Users/lexa/Documents/repositories/lexoyo_Cocktail/demo/games/libs/cocktailCore/style/StyleData.hx" module="cocktailCore.style.StyleData">
		<tab/>
		<space/>
		<domElement/>
		<haxe_doc>
	 * Lists the different kind of
	 * boxes that can be added in an
	 * inline formatting context.
	 * 
	 * Spaces and tabs are separated
	 * from other domElement as they
	 * can influence a linebox layout
	 * once it is complete
	 </haxe_doc>
	</enum>
	<class path="cocktailCore.style.computer.boxComputers.InLineBoxStylesComputer" params="" file="/Users/lexa/Documents/repositories/lexoyo_Cocktail/demo/games/libs/cocktailCore/style/computer/boxComputers/InLineBoxStylesComputer.hx">
		<extends path="cocktailCore.style.computer.BoxStylesComputer"/>
		<getComputedAutoMargin set="method" line="35" override="1">
			<f a="marginStyleValue:opositeMarginStyleValue:containingDOMElementDimension:computedDimension:isDimensionAuto:computedPaddingsDimension:fontSize:xHeight:?isHorizontalMargin">
				<e path="cocktail.style.MarginStyleValue"/>
				<e path="cocktail.style.MarginStyleValue"/>
				<c path="Int"/>
				<c path="Int"/>
				<e path="Bool"/>
				<c path="Int"/>
				<c path="Float"/>
				<c path="Float"/>
				<e path="Bool"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
	 * auto margin compute to 0 for inline non-embedded DOMElement
	 </haxe_doc>
		</getComputedAutoMargin>
		<getComputedWidth set="method" line="43" override="1">
			<f a="style:containingDOMElementData">
				<c path="cocktailCore.style.abstract.AbstractStyle"/>
				<t path="cocktailCore.style.ContainingDOMElementData"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
	 * for inline, non embedded DOMElement, the width doesn't apply
	 </haxe_doc>
		</getComputedWidth>
		<getComputedHeight set="method" line="51" override="1">
			<f a="style:containingDOMElementData">
				<c path="cocktailCore.style.abstract.AbstractStyle"/>
				<t path="cocktailCore.style.ContainingDOMElementData"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
	 * for inline, non embedded DOMElement, the height doesn't apply
	 </haxe_doc>
		</getComputedHeight>
		<new public="1" set="method" line="27">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * class constructor
	 </haxe_doc>
		</new>
		<haxe_doc>
 * The is the box style computer for inline non-embedded
 * DOMElement, such as a fragment of text
 * 
 * @author Yannick DOMINGUEZ
 </haxe_doc>
	</class>
	<class path="cocktailCore.resource.js.ImageLoader" params="" file="/Users/lexa/Documents/repositories/lexoyo_Cocktail/demo/games/libs/cocktailCore/resource/js/ImageLoader.hx">
		<extends path="cocktailCore.resource.abstract.AbstractImageLoader"/>
		<new public="1" set="method" line="35">
			<f a="?nativeElement">
				<t path="cocktail.nativeElement.NativeElement"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * class constructor
	 </haxe_doc>
		</new>
		<haxe_doc><![CDATA[
 * This is the Image loader implementation for the JavaScript runtime. It is used to 
 * load pictures that will be attached to the DOM. It loads the picture using
 * an <img> tag and setting it's source to the url of the file to load.
 * 
 * 
 * @author Yannick DOMINGUEZ
 ]]></haxe_doc>
	</class>
	<class path="cocktailCore.style.computer.DisplayStylesComputer" params="" file="/Users/lexa/Documents/repositories/lexoyo_Cocktail/demo/games/libs/cocktailCore/style/computer/DisplayStylesComputer.hx">
		<compute public="1" set="method" line="50" static="1">
			<f a="style">
				<c path="cocktailCore.style.abstract.AbstractStyle"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Compute all the styles affecting display by applying CSS
	 * rules. Each of this style might affect the computed value
	 * of another style. For example, a DOMElement which is a float
	 * must have a display of 'block'.
	 * 
	 * Some computed style value are the same as the defined
	 * style values
	 * 
	 * @param	style contain the styles definition of the 
	 * target DOMElement
	 </haxe_doc>
		</compute>
		<getComputedPosition set="method" line="77" static="1">
			<f a="style">
				<c path="cocktailCore.style.abstract.AbstractStyle"/>
				<e path="cocktail.style.PositionStyleValue"/>
			</f>
			<haxe_doc>
	 * Compute the 'position' style. It is the same as the defined style
	 * as no other style can affect the computed 'position' style value
	 </haxe_doc>
		</getComputedPosition>
		<getComputedFloat set="method" line="88" static="1">
			<f a="style:computedPosition">
				<c path="cocktailCore.style.abstract.AbstractStyle"/>
				<e path="cocktail.style.PositionStyleValue"/>
				<e path="cocktail.style.FloatStyleValue"/>
			</f>
			<haxe_doc>
	 * Compute the 'float' style which might be affect affected by the 'position'
	 * style, as an absolute positioned DOMElement can't be floated
	 * @param	style
	 * @param	computedPosition the computed value of position, computed before float
	 </haxe_doc>
		</getComputedFloat>
		<getComputedDisplay set="method" line="115" static="1">
			<f a="style:computedFloat">
				<c path="cocktailCore.style.abstract.AbstractStyle"/>
				<e path="cocktail.style.FloatStyleValue"/>
				<e path="cocktail.style.DisplayStyleValue"/>
			</f>
			<haxe_doc>
	 * Compute the 'display' style which might be affected by
	 * the defined 'float' style
	 * @param	style
	 * @param	computedFloat the computed value of the float which must be computed before this
	 * one
	 </haxe_doc>
		</getComputedDisplay>
		<getComputedClear set="method" line="153" static="1">
			<f a="style:computedPosition:computedDisplay">
				<c path="cocktailCore.style.abstract.AbstractStyle"/>
				<e path="cocktail.style.PositionStyleValue"/>
				<e path="cocktail.style.DisplayStyleValue"/>
				<e path="cocktail.style.ClearStyleValue"/>
			</f>
			<haxe_doc>
	 * Compute the clear style which might be affected by 
	 * the display and position style. Only block level
	 * DOMElement can clear floats and they must
	 * also be 'in-flow' element (with a 'position' value
	 * of relative or static)
	 * 
	 * @param	style
	 * @param	computedPosition
	 * @param	computedDisplay
	 </haxe_doc>
		</getComputedClear>
		<new set="method" line="29">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * Class contructor. Private, as
	 * this class is meant to be accessed
	 * through its public static methods
	 </haxe_doc>
		</new>
		<haxe_doc>
 * This is a static class in charge of
 * computing the styles that affect how a
 * DOMElement will be displayed
 * 
 * @author Yannick DOMINGUEZ
 </haxe_doc>
	</class>
	<enum path="cocktail.unit.LengthValue" params="" file="/Users/lexa/Documents/repositories/lexoyo_Cocktail/demo/games/libs/cocktail/unit/UnitData.hx" module="cocktail.unit.UnitData">
		<px a="value">
			<c path="Float"/>
			<haxe_doc>
	 * pixel, 1px is equal to 0.75pt.
	 </haxe_doc>
		</px>
		<pt a="value">
			<c path="Float"/>
			<haxe_doc>
	 * points, the points
	 * are equal to 1/72nd of 1in. 
	 </haxe_doc>
		</pt>
		<pc a="value">
			<c path="Float"/>
			<haxe_doc>
	 * picas, 1pc is equal to 12pt.
	 </haxe_doc>
		</pc>
		<mm a="value">
			<c path="Float"/>
			<haxe_doc>
	 * millimeters
	 </haxe_doc>
		</mm>
		<ex a="value">
			<c path="Float"/>
			<haxe_doc>
	 * The 'ex' unit is defined by the element's first available font.
	 * The exception is when 'ex' occurs in
	 * the value of the 'font-size' property,
	 * in which case it refers to the 'ex' of the
	 * parent element.The 'x-height' 
	 * is so called because it is often equal to the height
	 * of the lowercase "x". However, an 'ex' is
	 * defined even for fonts that do not contain an "x".
	 </haxe_doc>
		</ex>
		<em a="value">
			<c path="Float"/>
			<haxe_doc>
	 * The 'em' unit is equal to the
	 * computed value of the 'font-size'
	 * property of the element on which it is used.
	 * The exception is when 'em'
	 * occurs in the value of the 'font-size' 
	 * property itself, in which case it
	 * refers to the font size of the parent
	 * element. It may be used for vertical or
	 * horizontal measurement.
	 </haxe_doc>
		</em>
		<cm a="value">
			<c path="Float"/>
			<haxe_doc>
	 * centimeters
	 </haxe_doc>
		</cm>
		<_in a="value">
			<c path="Float"/>
			<haxe_doc>
	 * inches, 1in is equal to 2.54cm.
	 </haxe_doc>
		</_in>
		<haxe_doc>
 * Lists the different types of 
 * unit supported with an explicitly
 * set length such as px, cm, em...
 * 
 * There are two kinds of length units :
 * - absolute (px, cm, mm, pt, pc, in).
 * absolute length are all computed to pixel
 * values.
 * 
 * - relative (em and ex). Relative length units 
 * specify a length relative to another length property.
 </haxe_doc>
	</enum>
	<enum path="cocktail.unit.FontSizeAbsoluteSizeValue" params="" file="/Users/lexa/Documents/repositories/lexoyo_Cocktail/demo/games/libs/cocktail/unit/UnitData.hx" module="cocktail.unit.UnitData">
		<xxSmall/>
		<xxLarge/>
		<xSmall/>
		<xLarge/>
		<small/>
		<medium/>
		<large/>
		<haxe_doc>
 * Lists the possible values to 
 * define an absolute size for a font.
 * The actual value matching each
 * of the absolute values depends 
 * on the user agent and the user 
 * preferences
 </haxe_doc>
	</enum>
	<enum path="cocktail.unit.FontSizeRelativeSizeValue" params="" file="/Users/lexa/Documents/repositories/lexoyo_Cocktail/demo/games/libs/cocktail/unit/UnitData.hx" module="cocktail.unit.UnitData">
		<smaller/>
		<larger/>
		<haxe_doc>
 * Lists the possible relative values
 * to define the font size of a
 * DOMElement in relation
 * with the parent font size.
 </haxe_doc>
	</enum>
	<enum path="cocktail.unit.ColorValue" params="" file="/Users/lexa/Documents/repositories/lexoyo_Cocktail/demo/games/libs/cocktail/unit/UnitData.hx" module="cocktail.unit.UnitData">
		<keyword a="value">
			<e path="cocktail.unit.ColorKeywordValue"/>
			<haxe_doc>
	 * the color is chosen among a
	 * set of predefined colors
	 </haxe_doc>
		</keyword>
		<hex a="value">
			<c path="String"/>
			<haxe_doc>
	 * The color value must be represented
	 * as 6 hexadecimal number string started
	 * with a "#" charachter.
	 * e.g : for red, #FF0000
	 </haxe_doc>
		</hex>
		<RGB a="red:green:blue">
			<c path="Int"/>
			<c path="Int"/>
			<c path="Int"/>
			<haxe_doc>
	 * each value (red, green and blue)
	 * must be an integer from 0 to 255
	 </haxe_doc>
		</RGB>
		<haxe_doc>
 * Lists the different color format supported.
 * Each value describes one color
 </haxe_doc>
	</enum>
	<enum path="cocktail.unit.ColorKeywordValue" params="" file="/Users/lexa/Documents/repositories/lexoyo_Cocktail/demo/games/libs/cocktail/unit/UnitData.hx" module="cocktail.unit.UnitData">
		<yellow/>
		<white/>
		<teal/>
		<silver/>
		<red/>
		<purple/>
		<orange/>
		<olive/>
		<navy/>
		<maroon/>
		<lime/>
		<green/>
		<gray/>
		<fuchsia/>
		<blue/>
		<black/>
		<aqua/>
		<haxe_doc>
 * Lists the default available colors
 </haxe_doc>
	</enum>
	<enum path="cocktail.unit.AngleValue" params="" file="/Users/lexa/Documents/repositories/lexoyo_Cocktail/demo/games/libs/cocktail/unit/UnitData.hx" module="cocktail.unit.UnitData">
		<turn a="value">
			<c path="Float"/>
			<haxe_doc>
	 * Turns. There is 1 
	 * turn in a full circle. 
	 </haxe_doc>
		</turn>
		<rad a="value">
			<c path="Float"/>
			<haxe_doc>
	 * Radians. There are 2π
	 * radians in a full circle.
	 </haxe_doc>
		</rad>
		<grad a="value">
			<c path="Float"/>
			<haxe_doc>
	 * Gradians. There
	 * are 400 gradians in
	 * a full circle
	 </haxe_doc>
		</grad>
		<deg a="value">
			<c path="Float"/>
			<haxe_doc>
	 * Degress. There are
	 * 360 degrees in a full 
	 * circle
	 </haxe_doc>
		</deg>
		<haxe_doc>
 * Lists the different available
 * units to specify an angle
 </haxe_doc>
	</enum>
	<typedef path="cocktailCore.resource.ImageLoader" params="" file="/Users/lexa/Documents/repositories/lexoyo_Cocktail/demo/games/libs/cocktailCore/resource/ImageLoader.hx">
		<c path="cocktailCore.resource.js.ImageLoader"/>
		<haxe_doc>
 * Set the right runtime specific ImageLoader at compile-time
 </haxe_doc>
	</typedef>
	<typedef path="cocktail.domElement.ContainerDOMElement" params="" file="/Users/lexa/Documents/repositories/lexoyo_Cocktail/demo/games/libs/cocktail/domElement/ContainerDOMElement.hx">
		<c path="cocktailCore.domElement.js.ContainerDOMElement"/>
		<haxe_doc>
 * Set the right runtime specific ContainerDOMElement at compile-time
 </haxe_doc>
	</typedef>
	<class path="cocktailCore.style.computer.boxComputers.EmbeddedPositionedBoxStylesComputer" params="" file="/Users/lexa/Documents/repositories/lexoyo_Cocktail/demo/games/libs/cocktailCore/style/computer/boxComputers/EmbeddedPositionedBoxStylesComputer.hx">
		<extends path="cocktailCore.style.computer.boxComputers.EmbeddedBlockBoxStylesComputer"/>
		<measurePositionOffsets set="method" line="31" override="1">
			<f a="style:containingDOMElementData">
				<c path="cocktailCore.style.abstract.AbstractStyle"/>
				<t path="cocktailCore.style.ContainingDOMElementData"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Compute the 'position offsets' styles :
	 * top, left, bottom, right, used if the DOMElement
	 * is 'positioned' (position style other than 'static')
	 </haxe_doc>
		</measurePositionOffsets>
		<measureHorizontalPositionOffsets set="method" line="44"><f a="style:containingDOMElementData">
	<c path="cocktailCore.style.abstract.AbstractStyle"/>
	<t path="cocktailCore.style.ContainingDOMElementData"/>
	<e path="Void"/>
</f></measureHorizontalPositionOffsets>
		<measureVerticalPositionOffsets set="method" line="113"><f a="style:containingDOMElementData">
	<c path="cocktailCore.style.abstract.AbstractStyle"/>
	<t path="cocktailCore.style.ContainingDOMElementData"/>
	<e path="Void"/>
</f></measureVerticalPositionOffsets>
		<getComputedStaticLeft set="method" line="186">
			<f a="style:containingDOMElementData">
				<c path="cocktailCore.style.abstract.AbstractStyle"/>
				<t path="cocktailCore.style.ContainingDOMElementData"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
	 * compute the static value for left which is the value that will place the left margin edge
	 * of the DOMElement to the left edge of its containing DOMElement
	 </haxe_doc>
		</getComputedStaticLeft>
		<getComputedStaticTop set="method" line="195">
			<f a="style:containingDOMElementData">
				<c path="cocktailCore.style.abstract.AbstractStyle"/>
				<t path="cocktailCore.style.ContainingDOMElementData"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
	 * compute the static value for top which is the value that will place the top margin edge
	 * of the DOMElement to the top edge of its containing DOMElement
	 </haxe_doc>
		</getComputedStaticTop>
		<new public="1" set="method" line="21"><f a=""><e path="Void"/></f></new>
		<haxe_doc>
 * ...
 * @author Yannick DOMINGUEZ
 </haxe_doc>
	</class>
	<typedef path="cocktailCore.style.Style" params="" file="/Users/lexa/Documents/repositories/lexoyo_Cocktail/demo/games/libs/cocktailCore/style/Style.hx">
		<c path="cocktailCore.style.js.Style"/>
		<haxe_doc>
 * Set the right runtime specific Style at compile-time
 </haxe_doc>
	</typedef>
	<class path="cocktailCore.style.computer.FontAndTextStylesComputer" params="" file="/Users/lexa/Documents/repositories/lexoyo_Cocktail/demo/games/libs/cocktailCore/style/computer/FontAndTextStylesComputer.hx">
		<compute public="1" set="method" line="46" static="1">
			<f a="style:containingDOMElementData:containingDOMElementFontMetricsData">
				<c path="cocktailCore.style.abstract.AbstractStyle"/>
				<t path="cocktailCore.style.ContainingDOMElementData"/>
				<t path="cocktailCore.style.FontMetricsData"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * compute all the font and text styles of the DOMElement
	 * @param	style
	 * @param	containingDOMElementData
	 * @param	containingDOMElementFontMetricsData
	 </haxe_doc>
		</compute>
		<getComputedTextIndent set="method" line="109" static="1">
			<f a="style:containingDOMElementData">
				<c path="cocktailCore.style.abstract.AbstractStyle"/>
				<t path="cocktailCore.style.ContainingDOMElementData"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
	 * Compute the text indent to apply to the first line of an inline formatting context
	 </haxe_doc>
		</getComputedTextIndent>
		<getComputedVerticalAlign set="method" line="129" static="1">
			<f a="style:containingDOMElementFontMetricsData">
				<c path="cocktailCore.style.abstract.AbstractStyle"/>
				<t path="cocktailCore.style.FontMetricsData"/>
				<c path="Float"/>
			</f>
			<haxe_doc>
	 * Compute the vertical offset to apply to a DOMElement in an inline
	 * formatting context
	 </haxe_doc>
		</getComputedVerticalAlign>
		<getComputedTextAlign set="method" line="176" static="1">
			<f a="style:computedWhiteSpace">
				<c path="cocktailCore.style.abstract.AbstractStyle"/>
				<e path="cocktail.style.WhiteSpaceStyleValue"/>
				<e path="cocktail.style.TextAlignStyleValue"/>
			</f>
			<haxe_doc>
	 * The text alignement might be influenced by the
	 * white space style. when there are no line-break,
	 * the text can't be justified
	 </haxe_doc>
		</getComputedTextAlign>
		<getComputedColor set="method" line="198" static="1">
			<f a="style">
				<c path="cocktailCore.style.abstract.AbstractStyle"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
	 * Computed the color of a text of the DOMElement
	 </haxe_doc>
		</getComputedColor>
		<getComputedWordSpacing set="method" line="207" static="1">
			<f a="style">
				<c path="cocktailCore.style.abstract.AbstractStyle"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
	 * Compute the space to add between each word in a text in
	 * addition of the regular font space
	 </haxe_doc>
		</getComputedWordSpacing>
		<getComputedLineHeight set="method" line="227" static="1">
			<f a="style">
				<c path="cocktailCore.style.abstract.AbstractStyle"/>
				<c path="Float"/>
			</f>
			<haxe_doc>
	 * Compute the line height of a DOMElement in an inline
	 * formatting context
	 </haxe_doc>
		</getComputedLineHeight>
		<getComputedLetterSpacing set="method" line="254" static="1">
			<f a="style">
				<c path="cocktailCore.style.abstract.AbstractStyle"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
	 * Compute the space to apply between each
	 * letter in a text, in addition to the regular
	 * font letter spacing
	 </haxe_doc>
		</getComputedLetterSpacing>
		<getComputedFontSize set="method" line="273" static="1">
			<f a="style:parentFontSize:parentXHeight">
				<c path="cocktailCore.style.abstract.AbstractStyle"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
			</f>
			<haxe_doc>
	 * Compute the font size of the text of a DOMElement
	 </haxe_doc>
		</getComputedFontSize>
		<new set="method" line="31">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * Class contructor. Private, as
	 * this class is meant to be accessed
	 * through its public static methods
	 </haxe_doc>
		</new>
		<haxe_doc>
 * Compute the Font and Text related styles
 * of a DOMElement, helped by the containing
 * DOMElement dimensions and font metrics
 * 
 * @author Yannick DOMINGUEZ
 </haxe_doc>
	</class>
	<class path="haxe.Log" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/haxe/Log.hx">
		<trace public="1" set="dynamic" line="29" static="1"><f a="v:?infos">
	<d/>
	<t path="haxe.PosInfos"/>
	<e path="Void"/>
</f></trace>
		<clear public="1" set="dynamic" line="43" static="1"><f a=""><e path="Void"/></f></clear>
	</class>
	<class path="Hash" params="T" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/js/_std/Hash.hx">
		<h><d/></h>
		<set public="1" set="method" line="40">
			<f a="key:value">
				<c path="String"/>
				<c path="Hash.T"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Set a value for the given key.
	</haxe_doc>
		</set>
		<get public="1" set="method" line="44">
			<f a="key">
				<c path="String"/>
				<t path="Null"><c path="Hash.T"/></t>
			</f>
			<haxe_doc>
		Get a value for the given key.
	</haxe_doc>
		</get>
		<exists public="1" set="method" line="48">
			<f a="key">
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if a value exists for the given key.
		In particular, it's useful to tells if a key has
		a [null] value versus no value.
	</haxe_doc>
		</exists>
		<remove public="1" set="method" line="58">
			<f a="key">
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Removes a hashtable entry. Returns [true] if
		there was such entry.
	</haxe_doc>
		</remove>
		<keys public="1" set="method" line="65">
			<f a=""><t path="Iterator"><c path="String"/></t></f>
			<haxe_doc>
		Returns an iterator of all keys in the hashtable.
	</haxe_doc>
		</keys>
		<iterator public="1" set="method" line="71">
			<f a=""><t path="Iterator"><c path="Hash.T"/></t></f>
			<haxe_doc>
		Returns an iterator of all values in the hashtable.
	</haxe_doc>
		</iterator>
		<toString public="1" set="method" line="80">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns an displayable representation of the hashtable content.
	</haxe_doc>
		</toString>
		<new public="1" set="method" line="30"><f a=""><e path="Void"/></f></new>
		<haxe_doc>
	Hashtable over a set of elements, using [String] as keys.
	Other kind of keys are not possible on all platforms since they
	can't always be implemented efficiently.
</haxe_doc>
	</class>
	<enum path="cocktail.nativeElement.NativeElementTypeValue" params="" file="/Users/lexa/Documents/repositories/lexoyo_Cocktail/demo/games/libs/cocktail/nativeElement/NativeElementData.hx" module="cocktail.nativeElement.NativeElementData">
		<text><haxe_doc>
	  * text type such as an HTML TextElement
	  </haxe_doc></text>
		<skin><haxe_doc>
	  * Skin such as an HTML String in
	  * HTML
	  </haxe_doc></skin>
		<neutral><haxe_doc>
	  * standard container type, such as 
	  * a div in HTML
	  </haxe_doc></neutral>
		<library><haxe_doc>
	  * Class library such as a script
	  * tag in HTML
	  </haxe_doc></library>
		<image><haxe_doc>
	  * Image type such as an HTML img tag
	  </haxe_doc></image>
		<graphic><haxe_doc>
	  * drawing type such as a Canvas in 
	  * HTML or a sprite (with a graphic
	  * object) in Flash
	  </haxe_doc></graphic>
		<custom a="name">
			<c path="String"/>
			<haxe_doc>
	  * Can be any other type of native element.
	  * The name can be used for instance in HTML
	  * as a tag name
	  </haxe_doc>
		</custom>
		<haxe_doc>
  * Lists the different type of 
  * native element which can be created.
  </haxe_doc>
	</enum>
	<class path="cocktailCore.style.computer.boxComputers.NoneBoxStylesComputer" params="" file="/Users/lexa/Documents/repositories/lexoyo_Cocktail/demo/games/libs/cocktailCore/style/computer/boxComputers/NoneBoxStylesComputer.hx">
		<extends path="cocktailCore.style.computer.BoxStylesComputer"/>
		<new public="1" set="method" line="20"><f a=""><e path="Void"/></f></new>
		<haxe_doc>
 * ...
 * @author Yannick DOMINGUEZ
 </haxe_doc>
	</class>
	<class path="pong.Ball" params="" file="/Users/lexa/Documents/repositories/lexoyo_Cocktail/demo/games/src/pong/Ball.hx">
		<extends path="engine.MovingObject"/>
		<IMAGE_URL public="1" get="inline" set="null" line="9" static="1"><c path="String"/></IMAGE_URL>
		<onTouchRightSide public="1"><f a=""><e path="Void"/></f></onTouchRightSide>
		<onTouchLeftSide public="1"><f a=""><e path="Void"/></f></onTouchLeftSide>
		<onTouchTopSide public="1"><f a=""><e path="Void"/></f></onTouchTopSide>
		<onTouchBottomSide public="1"><f a=""><e path="Void"/></f></onTouchBottomSide>
		<update public="1" set="method" line="24" override="1"><f a=""><e path="Void"/></f></update>
		<new public="1" set="method" line="16"><f a="timeline">
	<t path="cocktail.domElement.ContainerDOMElement"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="Array" params="T" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/Array.hx" extern="1">
		<length public="1" set="null">
			<c path="Int"/>
			<haxe_doc>
		The length of the Array
	</haxe_doc>
		</length>
		<concat public="1" set="method">
			<f a="a">
				<c path="Array"><c path="Array.T"/></c>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>
		Returns a new Array by appending [a] to [this].
	</haxe_doc>
		</concat>
		<join public="1" set="method">
			<f a="sep">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Returns a representation of an array with [sep] for separating each element.
	</haxe_doc>
		</join>
		<pop public="1" set="method">
			<f a=""><t path="Null"><c path="Array.T"/></t></f>
			<haxe_doc>
		Removes the last element of the array and returns it.
	</haxe_doc>
		</pop>
		<push public="1" set="method">
			<f a="x">
				<c path="Array.T"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
		Adds the element [x] at the end of the array.
	</haxe_doc>
		</push>
		<reverse public="1" set="method">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
		Reverse the order of elements of the Array.
	</haxe_doc>
		</reverse>
		<shift public="1" set="method">
			<f a=""><t path="Null"><c path="Array.T"/></t></f>
			<haxe_doc>
		Removes the first element and returns it.
	</haxe_doc>
		</shift>
		<slice public="1" set="method">
			<f a="pos:?end">
				<c path="Int"/>
				<c path="Int"/>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>
		Copies the range of the array starting at [pos] up to,
		but not including, [end]. Both [pos] and [end] can be
		negative to count from the end: -1 is the last item in
		the array.
	</haxe_doc>
		</slice>
		<sort public="1" set="method">
			<f a="f">
				<f a=":">
					<c path="Array.T"/>
					<c path="Array.T"/>
					<c path="Int"/>
				</f>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[
		Sort the Array according to the comparison function [f].
		[f(x,y)] should return [0] if [x == y], [>0] if [x > y]
		and [<0] if [x < y].
	]]></haxe_doc>
		</sort>
		<splice public="1" set="method">
			<f a="pos:len">
				<c path="Int"/>
				<c path="Int"/>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>
		Removes [len] elements starting from [pos] an returns them.
	</haxe_doc>
		</splice>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns a displayable representation of the Array content.
	</haxe_doc>
		</toString>
		<unshift public="1" set="method">
			<f a="x">
				<c path="Array.T"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Adds the element [x] at the start of the array.
	</haxe_doc>
		</unshift>
		<insert public="1" set="method">
			<f a="pos:x">
				<c path="Int"/>
				<c path="Array.T"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Inserts the element [x] at the position [pos].
		All elements after [pos] are moved one index ahead.
	</haxe_doc>
		</insert>
		<remove public="1" set="method">
			<f a="x">
				<c path="Array.T"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Removes the first occurence of [x].
		Returns false if [x] was not present.
		Elements are compared by using standard equality.
	</haxe_doc>
		</remove>
		<copy public="1" set="method">
			<f a=""><c path="Array"><c path="Array.T"/></c></f>
			<haxe_doc>
		Returns a copy of the Array. The values are not
		copied, only the Array structure.
	</haxe_doc>
		</copy>
		<iterator public="1" set="method">
			<f a=""><t path="Iterator"><t path="Null"><c path="Array.T"/></t></t></f>
			<haxe_doc>
		Returns an iterator of the Array values.
	</haxe_doc>
		</iterator>
		<new public="1" set="method">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
		Creates a new Array.
	</haxe_doc>
		</new>
		<haxe_doc>
	An Array is a storage for values. You can access it using indexes or
	with its API. On the server side, it's often better to use a [List] which
	is less memory and CPU consuming, unless you really need indexed access.
</haxe_doc>
	</class>
	<class path="Std" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/js/_std/Std.hx">
		<is public="1" set="method" line="28" static="1">
			<f a="v:t">
				<d/>
				<d/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if a value v is of the type t.
	</haxe_doc>
		</is>
		<string public="1" set="method" line="32" static="1">
			<f a="s">
				<d/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Convert any value to a String
	</haxe_doc>
		</string>
		<int public="1" set="method" line="36" static="1">
			<f a="x">
				<c path="Float"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
		Convert a Float to an Int, rounded down.
	</haxe_doc>
		</int>
		<parseInt public="1" set="method" line="41" static="1">
			<f a="x">
				<c path="String"/>
				<t path="Null"><c path="Int"/></t>
			</f>
			<haxe_doc>
		Convert a String to an Int, parsing different possible representations. Returns [null] if could not be parsed.
	</haxe_doc>
		</parseInt>
		<parseFloat public="1" set="method" line="51" static="1">
			<f a="x">
				<c path="String"/>
				<c path="Float"/>
			</f>
			<haxe_doc>
		Convert a String to a Float, parsing different possible reprensations.
	</haxe_doc>
		</parseFloat>
		<random public="1" set="method" line="55" static="1">
			<f a="x">
				<c path="Int"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
		Return a random integer between 0 included and x excluded.
	</haxe_doc>
		</random>
		<haxe_doc>
	The Std class provides standard methods for manipulating basic types.
</haxe_doc>
	</class>
	<enum path="cocktailCore.textElement.TextTokenValue" params="" file="/Users/lexa/Documents/repositories/lexoyo_Cocktail/demo/games/libs/cocktailCore/textElement/TextElementData.hx" module="cocktailCore.textElement.TextElementData">
		<word a="value">
			<c path="String"/>
			<haxe_doc>
	 * a word, surrounded by
	 * spaces
	 </haxe_doc>
		</word>
		<tab><haxe_doc>
	 * a tabulation
	 </haxe_doc></tab>
		<space><haxe_doc>
	 * represents one
	 * space which can be 
	 * between 2 words or among
	 * a space sequence
	 </haxe_doc></space>
		<lineFeed><haxe_doc>
	 * a line feed (starts
	 * a new line)
	 </haxe_doc></lineFeed>
		<haxe_doc>
 * Lists all the different consituant
 * of a plain text, including 
 * controls characters
 </haxe_doc>
	</enum>
	<typedef path="cocktailCore.textElement.TextFragmentData" params="" file="/Users/lexa/Documents/repositories/lexoyo_Cocktail/demo/games/libs/cocktailCore/textElement/TextElementData.hx" module="cocktailCore.textElement.TextElementData">
		<a>
			<textToken><e path="cocktailCore.textElement.TextTokenValue"/></textToken>
			<textFragmentDOMElement><t path="cocktailCore.domElement.TextFragmentDOMElement"/></textFragmentDOMElement>
		</a>
		<haxe_doc>
 * Holds a text token and its visual
 * representation (a TextFragmentDOMElement)
 </haxe_doc>
	</typedef>
	<class path="Main" params="" file="/Users/lexa/Documents/repositories/lexoyo_Cocktail/demo/games/src/Main.hx">
		<main public="1" set="method" line="11" static="1"><f a=""><e path="Void"/></f></main>
		<new public="1" set="method" line="5"><f a=""><e path="Void"/></f></new>
	</class>
	<typedef path="cocktail.nativeElement.NativeElement" params="" file="/Users/lexa/Documents/repositories/lexoyo_Cocktail/demo/games/libs/cocktail/nativeElement/NativeElement.hx">
		<t path="js.HtmlDom"/>
		<haxe_doc>
 * Set the right runtime specific NativeElement at compile-time
 </haxe_doc>
	</typedef>
	<typedef path="cocktail.resource.ResourceData" params="" file="/Users/lexa/Documents/repositories/lexoyo_Cocktail/demo/games/libs/cocktail/resource/ResourceData.hx">
		<a>
			<url>
				<c path="String"/>
				<haxe_doc>
	 * The url of the file to load
	 </haxe_doc>
			</url>
			<onLoadError>
				<f a="">
					<d/>
					<e path="Void"/>
				</f>
				<haxe_doc>
	 * Reference to the callback to execute when there is an error during loading
	 </haxe_doc>
			</onLoadError>
			<onLoadComplete><f a="">
	<d/>
	<e path="Void"/>
</f></onLoadComplete>
			<loadingType>
				<e path="cocktail.resource.LoadingTypeValue"/>
				<haxe_doc>
	 * The type of loaded file
	 </haxe_doc>
			</loadingType>
			<allowCache>
				<e path="Bool"/>
				<haxe_doc>
	 * Wether to allow the browser to cache the file
	 </haxe_doc>
			</allowCache>
		</a>
		<haxe_doc>
  * Stores the data relative to a resource.
  </haxe_doc>
	</typedef>
	<enum path="cocktail.resource.LoadingTypeValue" params="" file="/Users/lexa/Documents/repositories/lexoyo_Cocktail/demo/games/libs/cocktail/resource/ResourceData.hx" module="cocktail.resource.ResourceData">
		<library/>
		<data/>
		<haxe_doc>
 * Enumerates the file type which can be loaded : 
 * data for text file,
 * and library for classes library which may be stored in .swf or .js files for instance
 </haxe_doc>
	</enum>
	<class path="cocktailCore.style.positioner.RelativePositioner" params="" file="/Users/lexa/Documents/repositories/lexoyo_Cocktail/demo/games/libs/cocktailCore/style/positioner/RelativePositioner.hx">
		<extends path="cocktailCore.style.positioner.BoxPositioner"/>
		<applyGlobalX set="method" line="44" override="1">
			<f a="domElement:globalX">
				<t path="cocktail.domElement.DOMElement"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Overriden as relative DOMElement are positioned in the flow
	 </haxe_doc>
		</applyGlobalX>
		<applyGlobalY set="method" line="52" override="1">
			<f a="domElement:globalY">
				<t path="cocktail.domElement.DOMElement"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Overriden as relative DOMElement are positioned in the flow
	 </haxe_doc>
		</applyGlobalY>
		<getLeftOffset set="method" line="61" override="1">
			<f a="domElement">
				<t path="cocktail.domElement.DOMElement"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
	 * Overriden because the margin isn't use as is it already applied when the
	 * relative DOMElement is inserted into the flow
	 </haxe_doc>
		</getLeftOffset>
		<getRightOffset set="method" line="70" override="1">
			<f a="domElement:containingDOMElementWidth">
				<t path="cocktail.domElement.DOMElement"/>
				<c path="Int"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
	 * Overriden because the margin isn't use as is it already applied when the
	 * relative DOMElement is inserted into the flow
	 </haxe_doc>
		</getRightOffset>
		<getTopOffset set="method" line="79" override="1">
			<f a="domElement">
				<t path="cocktail.domElement.DOMElement"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
	 * Overriden because the margin isn't use as is it already applied when the
	 * relative DOMElement is inserted into the flow
	 </haxe_doc>
		</getTopOffset>
		<getBottomOffset set="method" line="88" override="1">
			<f a="domElement:containingDOMElementHeight">
				<t path="cocktail.domElement.DOMElement"/>
				<c path="Int"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
	 * Overriden because the margin isn't use as is it already applied when the
	 * relative DOMElement is inserted into the flow
	 </haxe_doc>
		</getBottomOffset>
		<new public="1" set="method" line="32">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * class constructor
	 </haxe_doc>
		</new>
		<haxe_doc>
 * This is the box positioner implementation
 * for 'relative' DOMElement.
 * 
 * Prevents DOMElement from being globally
 * positioned as 'relative' DOMElement remain
 * in normal flow, only an offset is applied to
 * them
 * 
 * @author Yannick DOMINGUEZ
 </haxe_doc>
	</class>
	<class path="cocktailCore.nativeElement.abstract.AbstractNativeElementPathManager" params="" file="/Users/lexa/Documents/repositories/lexoyo_Cocktail/demo/games/libs/cocktailCore/nativeElement/abstract/AbstractNativeElementPathManager.hx">
		<getRoot public="1" set="method" line="32">
			<f a=""><t path="cocktail.nativeElement.NativeElement"/></f>
			<haxe_doc>
	 * Returns the root of the DOM. Implemented by subclasses
	 </haxe_doc>
		</getRoot>
		<new public="1" set="method" line="24">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * class contructor
	 </haxe_doc>
		</new>
		<haxe_doc>
 * This is a base class for the path manager. 
 * It retrieves and return the root of the DOM, 
 * sush as the body tag in HTML
 * 
 * @author Yannick DOMINGUEZ
 </haxe_doc>
	</class>
	<class path="cocktailCore.nativeElement.js.NativeElementPathManager" params="" file="/Users/lexa/Documents/repositories/lexoyo_Cocktail/demo/games/libs/cocktailCore/nativeElement/js/NativeElementPathManager.hx">
		<extends path="cocktailCore.nativeElement.abstract.AbstractNativeElementPathManager"/>
		<getRoot public="1" set="method" line="33" override="1">
			<f a=""><t path="cocktail.nativeElement.NativeElement"/></f>
			<haxe_doc>
	 * Returns a reference to the Flash Stage
	 </haxe_doc>
		</getRoot>
		<new public="1" set="method" line="25">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * class contructor
	 </haxe_doc>
		</new>
		<haxe_doc>
 * This is the JavaScript implementation for the path manager. 
 * It returns the HTML document body
 * 
 * @author Yannick DOMINGUEZ
 </haxe_doc>
	</class>
	<class path="cocktailCore.style.computer.boxComputers.BlockBoxStylesComputer" params="" file="/Users/lexa/Documents/repositories/lexoyo_Cocktail/demo/games/libs/cocktailCore/style/computer/boxComputers/BlockBoxStylesComputer.hx">
		<extends path="cocktailCore.style.computer.BoxStylesComputer"/>
		<new public="1" set="method" line="26">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * class constructor
	 </haxe_doc>
		</new>
		<haxe_doc>
 * This is the box computer implementation for a
 * non-embedded block level element.
 * 
 * This is the default implementation on boxStylesComputer
 * 
 * @author Yannick DOMINGUEZ
 </haxe_doc>
	</class>
	<class path="cocktailCore.style.computer.boxComputers.PositionedBoxStylesComputer" params="" file="/Users/lexa/Documents/repositories/lexoyo_Cocktail/demo/games/libs/cocktailCore/style/computer/boxComputers/PositionedBoxStylesComputer.hx">
		<extends path="cocktailCore.style.computer.BoxStylesComputer"/>
		<shrinkToFit public="1" set="method" line="42" override="1">
			<f a="style:containingDOMElementData:minimumWidth">
				<c path="cocktailCore.style.abstract.AbstractStyle"/>
				<t path="cocktailCore.style.ContainingDOMElementData"/>
				<c path="Int"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
	 * if the width is set to 'auto', then this method is called and might shrink the
	 * width of the DOMElement to fit its content
	 </haxe_doc>
		</shrinkToFit>
		<applyContentHeight public="1" set="method" line="86" override="1">
			<f a="style:containingDOMElementData:childrenHeight">
				<c path="cocktailCore.style.abstract.AbstractStyle"/>
				<t path="cocktailCore.style.ContainingDOMElementData"/>
				<c path="Int"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
	 * Overriden as in some cases, depending on the specified value of
	 * top and bottom style, the height used value might not be the children
	 * height of the DOMElement
	 </haxe_doc>
		</applyContentHeight>
		<measurePositionOffsets set="method" line="113" override="1">
			<f a="style:containingDOMElementData">
				<c path="cocktailCore.style.abstract.AbstractStyle"/>
				<t path="cocktailCore.style.ContainingDOMElementData"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Overriden to prevent computing left, right,
	 * top and bottom which in this case are computed in the 
	 * width and height methods
	 </haxe_doc>
		</measurePositionOffsets>
		<measureAutoWidth set="method" line="126" override="1">
			<f a="style:containingDOMElementData">
				<c path="cocktailCore.style.abstract.AbstractStyle"/>
				<t path="cocktailCore.style.ContainingDOMElementData"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * overriden to compute also left, right and the horizontal margins when an
	 * auto width is computed. Left and right might be computed in the shrink-to-fit
	 * method if they are defined as auto
	 </haxe_doc>
		</measureAutoWidth>
		<measureWidth set="method" line="165" override="1">
			<f a="style:containingDOMElementData">
				<c path="cocktailCore.style.abstract.AbstractStyle"/>
				<t path="cocktailCore.style.ContainingDOMElementData"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * overriden to also compute left and right style
	 </haxe_doc>
		</measureWidth>
		<measureAutoHeight set="method" line="270" override="1">
			<f a="style:containingDOMElementData">
				<c path="cocktailCore.style.abstract.AbstractStyle"/>
				<t path="cocktailCore.style.ContainingDOMElementData"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * overriden to compute also top, bottom and the vertical margins when an
	 * auto height is computed.
	 </haxe_doc>
		</measureAutoHeight>
		<measureHeight set="method" line="312" override="1">
			<f a="style:containingDOMElementData">
				<c path="cocktailCore.style.abstract.AbstractStyle"/>
				<t path="cocktailCore.style.ContainingDOMElementData"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * overriden to also compute top and bottom style
	 </haxe_doc>
		</measureHeight>
		<getComputedStaticLeft set="method" line="418">
			<f a="style:containingDOMElementData">
				<c path="cocktailCore.style.abstract.AbstractStyle"/>
				<t path="cocktailCore.style.ContainingDOMElementData"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
	 * compute the static value for left which is the value that will place the left margin edge
	 * of the DOMElement to the left edge of its containing DOMElement
	 </haxe_doc>
		</getComputedStaticLeft>
		<getComputedStaticTop set="method" line="427">
			<f a="style:containingDOMElementData">
				<c path="cocktailCore.style.abstract.AbstractStyle"/>
				<t path="cocktailCore.style.ContainingDOMElementData"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
	 * compute the static value for top which is the value that will place the top margin edge
	 * of the DOMElement to the top edge of its containing DOMElement
	 </haxe_doc>
		</getComputedStaticTop>
		<doShrinkToFit set="method" line="435">
			<f a="style:containingDOMElementData:minimumWidth">
				<c path="cocktailCore.style.abstract.AbstractStyle"/>
				<t path="cocktailCore.style.ContainingDOMElementData"/>
				<c path="Int"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
	 * Actually shrink the width
	 </haxe_doc>
		</doShrinkToFit>
		<new public="1" set="method" line="29">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * class constructor
	 </haxe_doc>
		</new>
		<haxe_doc>
 * This is the box computer for non-replaced
 * absolutely positioned DOMElement, such as
 * an absolutely positioned ContainerDOMElement
 * 
 * @author Yannick DOMINGUEZ
 </haxe_doc>
	</class>
	<class path="pong.Bat" params="" file="/Users/lexa/Documents/repositories/lexoyo_Cocktail/demo/games/src/pong/Bat.hx">
		<extends path="engine.MovingObject"/>
		<IMAGE_URL public="1" get="inline" set="null" line="9" static="1"><c path="String"/></IMAGE_URL>
		<update public="1" set="method" line="18" override="1"><f a=""><e path="Void"/></f></update>
		<new public="1" set="method" line="10"><f a="timeline">
	<t path="cocktail.domElement.ContainerDOMElement"/>
	<e path="Void"/>
</f></new>
	</class>
	<typedef path="cocktailCore.mouse.Mouse" params="" file="/Users/lexa/Documents/repositories/lexoyo_Cocktail/demo/games/libs/cocktailCore/mouse/Mouse.hx">
		<c path="cocktailCore.mouse.js.Mouse"/>
		<haxe_doc>
 * Set the right runtime specific mouse manager at compile-time
 </haxe_doc>
	</typedef>
	<class path="cocktailCore.style.formatter.BlockFormattingContext" params="" file="/Users/lexa/Documents/repositories/lexoyo_Cocktail/demo/games/libs/cocktailCore/style/formatter/BlockFormattingContext.hx">
		<extends path="cocktailCore.style.formatter.FormattingContext"/>
		<place set="method" line="35" override="1">
			<f a="domElement">
				<t path="cocktail.domElement.DOMElement"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Place the DOMElement below the preceding DOMElement
	 </haxe_doc>
		</place>
		<clearFloat public="1" set="method" line="69" override="1">
			<f a="clear:isFloat">
				<e path="cocktail.style.ClearStyleValue"/>
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * clear left, right or both floats and set the y of the flowData below
	 * the last cleared float
	 </haxe_doc>
		</clearFloat>
		<new public="1" set="method" line="27">
			<f a="domElement:previousFormattingContext">
				<t path="cocktail.domElement.DOMElement"/>
				<c path="cocktailCore.style.formatter.FormattingContext"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * class constructor
	 </haxe_doc>
		</new>
		<haxe_doc>
 * This formatting context layout DOMElement below each other
 * following the DOM tree order.
 * 
 * @author Yannick DOMINGUEZ
 </haxe_doc>
	</class>
	<class path="pong.PongGame" params="" file="/Users/lexa/Documents/repositories/lexoyo_Cocktail/demo/games/src/pong/PongGame.hx">
		<BG_IMAGE_URL public="1" get="inline" set="null" line="21" static="1"><c path="String"/></BG_IMAGE_URL>
		<_ball><c path="pong.Ball"/></_ball>
		<_isMouseDown><e path="Bool"/></_isMouseDown>
		<_bat01><c path="pong.Bat"/></_bat01>
		<_bat02><c path="pong.Bat"/></_bat02>
		<_mouseX><c path="Int"/></_mouseX>
		<_mouseY><c path="Int"/></_mouseY>
		<reset public="1" set="method" line="77"><f a=""><e path="Void"/></f></reset>
		<ballOutMySide public="1" set="method" line="91"><f a=""><e path="Void"/></f></ballOutMySide>
		<ballOutYourSide public="1" set="method" line="106"><f a=""><e path="Void"/></f></ballOutYourSide>
		<iWon public="1" set="method" line="121"><f a=""><e path="Void"/></f></iWon>
		<iLost public="1" set="method" line="125"><f a=""><e path="Void"/></f></iLost>
		<attachKeyboardEvents public="1" set="method" line="129"><f a="bgDOMElement">
	<t path="cocktail.domElement.DOMElement"/>
	<e path="Void"/>
</f></attachKeyboardEvents>
		<onMouseDown public="1" set="method" line="133"><f a="mouseEventData">
	<t path="cocktail.mouse.MouseEventData"/>
	<e path="Void"/>
</f></onMouseDown>
		<onMouseUp public="1" set="method" line="139"><f a="mouseEventData">
	<t path="cocktail.mouse.MouseEventData"/>
	<e path="Void"/>
</f></onMouseUp>
		<onMouseMove public="1" set="method" line="144"><f a="mouseEventData">
	<t path="cocktail.mouse.MouseEventData"/>
	<e path="Void"/>
</f></onMouseMove>
		<followMousePosition public="1" set="method" line="151"><f a=""><e path="Void"/></f></followMousePosition>
		<goUp public="1" set="method" line="159"><f a=""><e path="Void"/></f></goUp>
		<goDown public="1" set="method" line="164"><f a=""><e path="Void"/></f></goDown>
		<onKeyDown public="1" set="method" line="169"><f a="key">
	<t path="cocktail.keyboard.KeyEventData"/>
	<e path="Void"/>
</f></onKeyDown>
		<mainLoop public="1" set="method" line="178"><f a=""><e path="Void"/></f></mainLoop>
		<new public="1" set="method" line="23"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="Date" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/Date.hx" extern="1">
		<now public="1" set="method" static="1">
			<f a=""><c path="Date"/></f>
			<haxe_doc>
		Returns a Date representing the current local time.
	</haxe_doc>
		</now>
		<fromTime public="1" set="method" static="1">
			<f a="t">
				<c path="Float"/>
				<c path="Date"/>
			</f>
			<haxe_doc>
		Returns a Date from a timestamp [t] which is the number of
		milliseconds elapsed since 1st January 1970.
	</haxe_doc>
		</fromTime>
		<fromString public="1" set="method" static="1">
			<f a="s">
				<c path="String"/>
				<c path="Date"/>
			</f>
			<haxe_doc>
		Returns a Date from a formated string of one of the following formats :
		[YYYY-MM-DD hh:mm:ss] or [YYYY-MM-DD] or [hh:mm:ss]. The first two formats
		are expressed in local time, the third in UTC Epoch.
	</haxe_doc>
		</fromString>
		<getTime public="1" set="method">
			<f a=""><c path="Float"/></f>
			<haxe_doc>
		Returns the timestamp of the date. It's the number of milliseconds
		elapsed since 1st January 1970. It might only have a per-second precision
		depending on the platforms.
	</haxe_doc>
		</getTime>
		<getHours public="1" set="method">
			<f a=""><c path="Int"/></f>
			<haxe_doc>
		Returns the hours value of the date (0-23 range).
	</haxe_doc>
		</getHours>
		<getMinutes public="1" set="method">
			<f a=""><c path="Int"/></f>
			<haxe_doc>
		Returns the minutes value of the date (0-59 range).
	</haxe_doc>
		</getMinutes>
		<getSeconds public="1" set="method">
			<f a=""><c path="Int"/></f>
			<haxe_doc>
		Returns the seconds of the date (0-59 range).
	</haxe_doc>
		</getSeconds>
		<getFullYear public="1" set="method">
			<f a=""><c path="Int"/></f>
			<haxe_doc>
		Returns the full year of the date.
	</haxe_doc>
		</getFullYear>
		<getMonth public="1" set="method">
			<f a=""><c path="Int"/></f>
			<haxe_doc>
		Returns the month of the date (0-11 range).
	</haxe_doc>
		</getMonth>
		<getDate public="1" set="method">
			<f a=""><c path="Int"/></f>
			<haxe_doc>
		Returns the day of the date (1-31 range).
	</haxe_doc>
		</getDate>
		<getDay public="1" set="method">
			<f a=""><c path="Int"/></f>
			<haxe_doc>
		Returns the week day of the date (0-6 range).
	</haxe_doc>
		</getDay>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns a string representation for the Date, by using the
		standard format [YYYY-MM-DD HH:MM:SS]. See [DateTools.format] for
		other formating rules.
	</haxe_doc>
		</toString>
		<new public="1" set="method">
			<f a="year:month:day:hour:min:sec">
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Creates a new date object.
	</haxe_doc>
		</new>
		<haxe_doc>
	The Date class is used for date manipulation. There is some extra functions
	available in the [DateTools] class.
</haxe_doc>
	</class>
	<class path="js.Lib" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/js/Lib.hx">
		<isIE public="1" static="1"><e path="Bool"/></isIE>
		<isOpera public="1" static="1"><e path="Bool"/></isOpera>
		<document public="1" static="1"><t path="js.Document"/></document>
		<window public="1" static="1"><t path="js.Window"/></window>
		<onerror line="35" static="1"><f a=":">
	<c path="String"/>
	<c path="Array"><c path="String"/></c>
	<e path="Bool"/>
</f></onerror>
		<alert public="1" set="method" line="37" static="1"><f a="v">
	<d/>
	<e path="Void"/>
</f></alert>
		<eval public="1" set="method" line="41" static="1"><f a="code">
	<c path="String"/>
	<d/>
</f></eval>
		<setErrorHandler public="1" set="method" line="45" static="1"><f a="f">
	<f a=":">
		<c path="String"/>
		<c path="Array"><c path="String"/></c>
		<e path="Bool"/>
	</f>
	<e path="Void"/>
</f></setErrorHandler>
	</class>
	<class path="StringTools" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/StringTools.hx">
		<urlEncode public="1" set="method" line="38" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Encode an URL by using the standard format.
	</haxe_doc>
		</urlEncode>
		<urlDecode public="1" set="method" line="59" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Decode an URL using the standard format.
	</haxe_doc>
		</urlDecode>
		<htmlEscape public="1" set="method" line="80" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Escape HTML special characters of the string.
	</haxe_doc>
		</htmlEscape>
		<htmlUnescape public="1" set="method" line="87" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Unescape HTML special characters of the string.
	</haxe_doc>
		</htmlUnescape>
		<startsWith public="1" set="method" line="98" static="1">
			<f a="s:start">
				<c path="String"/>
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if the string [s] starts with the string [start].
	</haxe_doc>
		</startsWith>
		<endsWith public="1" set="method" line="105" static="1">
			<f a="s:end">
				<c path="String"/>
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if the string [s] ends with the string [end].
	</haxe_doc>
		</endsWith>
		<isSpace public="1" set="method" line="114" static="1">
			<f a="s:pos">
				<c path="String"/>
				<c path="Int"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if the character in the string [s] at position [pos] is a space.
	</haxe_doc>
		</isSpace>
		<ltrim public="1" set="method" line="122" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Removes spaces at the left of the String [s].
	</haxe_doc>
		</ltrim>
		<rtrim public="1" set="method" line="141" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Removes spaces at the right of the String [s].
	</haxe_doc>
		</rtrim>
		<trim public="1" set="method" line="161" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Removes spaces at the beginning and the end of the String [s].
	</haxe_doc>
		</trim>
		<rpad public="1" set="method" line="172" static="1">
			<f a="s:c:l">
				<c path="String"/>
				<c path="String"/>
				<c path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Pad the string [s] by appending [c] at its right until it reach [l] characters.
	</haxe_doc>
		</rpad>
		<lpad public="1" set="method" line="194" static="1">
			<f a="s:c:l">
				<c path="String"/>
				<c path="String"/>
				<c path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Pad the string [s] by appending [c] at its left until it reach [l] characters.
	</haxe_doc>
		</lpad>
		<replace public="1" set="method" line="219" static="1">
			<f a="s:sub:by">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Replace all occurences of the string [sub] in the string [s] by the string [by].
	</haxe_doc>
		</replace>
		<hex public="1" set="method" line="230" static="1">
			<f a="n:?digits">
				<c path="Int"/>
				<c path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Encode a number into a hexadecimal representation, with an optional number of zeros for left padding.
	</haxe_doc>
		</hex>
		<fastCodeAt public="1" get="inline" set="null" line="253" static="1">
			<f a="s:index">
				<c path="String"/>
				<c path="Int"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
		Provides a fast native string charCodeAt access. Since the EOF value might vary depending on the platforms, always test with StringTools.isEOF.
		Only guaranteed to work if index in [0,s.length] range. Might not work with strings containing \0 char.
	</haxe_doc>
		</fastCodeAt>
		<isEOF public="1" get="inline" set="null" line="270" static="1"><f a="c">
	<c path="Int"/>
	<e path="Bool"/>
</f></isEOF>
		<haxe_doc>
	The StringTools class contains some extra functionalities for [String]
	manipulation. It's stored in a different class in order to prevent
	the standard [String] of being bloated and thus increasing the size of
	each application using it.
</haxe_doc>
	</class>
	<class path="cocktailCore.style.formatter.InlineFormattingContext" params="" file="/Users/lexa/Documents/repositories/lexoyo_Cocktail/demo/games/libs/cocktailCore/style/formatter/InlineFormattingContext.hx">
		<extends path="cocktailCore.style.formatter.FormattingContext"/>
		<_domElementInLineBox>
			<c path="Array"><t path="cocktailCore.style.LineBoxElementData"/></c>
			<haxe_doc>
	 * The DOMElements in the current line
	 </haxe_doc>
		</_domElementInLineBox>
		<_firstLineLaidOut>
			<e path="Bool"/>
			<haxe_doc>
	 * Determine wheter the first line of the formatting context was
	 * already laid out. Used when applying text indent which is only
	 * applied to the first line of an inline formatting context
	 </haxe_doc>
		</_firstLineLaidOut>
		<destroy public="1" set="method" line="54" override="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * Called when the inline formatting context will
	 * be replaced by anohter. Used to ensure that the last line
	 * of DOMElements is laid out
	 </haxe_doc>
		</destroy>
		<insert public="1" set="method" line="60" override="1"><f a="domElement">
	<t path="cocktail.domElement.DOMElement"/>
	<e path="Void"/>
</f></insert>
		<insertSpace public="1" set="method" line="95" override="1"><f a="domElement">
	<t path="cocktail.domElement.DOMElement"/>
	<e path="Void"/>
</f></insertSpace>
		<place set="method" line="125" override="1">
			<f a="domElement">
				<t path="cocktail.domElement.DOMElement"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Overiden to imcrement the x position of the
	 * flowData with the placed DOMElement's offset width
	 </haxe_doc>
		</place>
		<startNewLine set="method" line="131" override="1"><f a="domElementWidth:?isLastLine">
	<c path="Int"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></startNewLine>
		<clearFloat public="1" set="method" line="183" override="1"><f a="clear:isFloat">
	<e path="cocktail.style.ClearStyleValue"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></clearFloat>
		<placeFloat set="method" line="191" override="1"><f a="domElement:floatData">
	<t path="cocktail.domElement.DOMElement"/>
	<t path="cocktailCore.style.FloatData"/>
	<e path="Void"/>
</f></placeFloat>
		<removeSpaces set="method" line="205"><f a=""><e path="Void"/></f></removeSpaces>
		<alignLineBox set="method" line="260">
			<f a="isFirstLine:isLastLine">
				<e path="Bool"/>
				<e path="Bool"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
	 * before a new line starts or before the inline
	 * formarring context get destroyed, align all the
	 * DOMElements in the current line horizontally
	 * @param	firstLine wether it is the first line which is laid out
	 * @param	isLastLine wheter it is the last line which is laid out
	 * @return returns the concantenated width of all the aligned DOMElelements.
	 * Used to determine the max line width used for shrink-to-fit algorithm
	 </haxe_doc>
		</alignLineBox>
		<alignLeft set="method" line="332">
			<f a="flowX">
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * align the DOMElements starting from the left edge of the containing DOMElement
	 * @param	flowX the x position of the first DOMElement
	 </haxe_doc>
		</alignLeft>
		<alignCenter set="method" line="349">
			<f a="flowX:remainingSpace">
				<c path="Int"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Center the DOMElements in the line by moving each to the right by half the remaining space
	 * @param	flowX the first availbable x position for the DOMElement to the left most of the line box
	 * @param	remainingSpace the available width in the line box after all DOMElements
	 * have been laid out
	 </haxe_doc>
		</alignCenter>
		<alignRight set="method" line="366">
			<f a="flowX:remainingSpace">
				<c path="Int"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * align the DOMElements starting from the right edge to the left edge of the
	 * containing DOMElement
	 * @param	flowX the x position of the DOMElement to left most of the line box
	 * @param	remainingSpace the available width in the line box after all DOMElements
	 * have been laid out
	 </haxe_doc>
		</alignRight>
		<alignJustify set="method" line="382">
			<f a="flowX:remainingSpace">
				<c path="Int"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Justify the DOMElements in the line box by adjusting
	 * the width of the space characters
	 * @param	flowX
	 * @param	remainingSpace
	 </haxe_doc>
		</alignJustify>
		<computeLineBoxHeight set="method" line="437">
			<f a=""><c path="Int"/></f>
			<haxe_doc>
	 * When a line box is full and a new line will
	 * be created, compute the height of the current line
	 * box and place its DOMElement vertically.
	 * 
	 * A line box height corresponds to the addition 
	 * of the highest ascent and descent of its
	 * DOMElement above the baseline
	 </haxe_doc>
		</computeLineBoxHeight>
		<new public="1" set="method" line="41">
			<f a="domElement:previousFormattingContext">
				<t path="cocktail.domElement.DOMElement"/>
				<c path="cocktailCore.style.formatter.FormattingContext"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * class constructor. Init class attributes
	 </haxe_doc>
		</new>
		<haxe_doc>
 * This formatting context place all formatted DOMElements
 * in lines, called line box. When the line is full and can't contain other
 * DOMElements, a new line is created
 * 
 * @author Yannick DOMINGUEZ
 </haxe_doc>
	</class>
	<typedef path="cocktailCore.domElement.TextFragmentDOMElement" params="" file="/Users/lexa/Documents/repositories/lexoyo_Cocktail/demo/games/libs/cocktailCore/domElement/TextFragmentDOMElement.hx">
		<c path="cocktailCore.domElement.js.TextFragmentDOMElement"/>
		<haxe_doc>
 * Set the right runtime specific TextFragmentDOMElement at compile-time
 </haxe_doc>
	</typedef>
</haxe>