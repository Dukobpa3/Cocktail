/*
 * Cocktail, HTML rendering engine
 * http://haxe.org/com/libs/cocktail
 *
 * Copyright (c) Silex Labs
 * Cocktail is available under the MIT license
 * http://www.silexlabs.org/labs/cocktail-licensing/
*/
package cocktail.core.dom;

import cocktail.core.event.EventCallback;
import cocktail.core.event.EventTarget;
import haxe.Log;

/**
 * The Node interface is the primary datatype for the entire Document Object Model.
 * It represents a single node in the document tree. While all objects implementing the Node
 * interface expose methods for dealing with children, not all objects implementing the Node
 * interface may have children. For example, Text nodes may not have children, and adding children
 * to such nodes results in a DOMException being raised.
 * 
 * TODO 5 : implement DOMException in all of the DOM package
 * 
 * The attributes nodeName, nodeValue and attributes are included as a mechanism to get at node
 * information without casting down to the specific derived interface.
 * In cases where there is no obvious mapping of these attributes for a specific nodeType
 * (e.g., nodeValue for an Element or attributes for a Comment), this returns null.
 * Note that the specialized interfaces may contain additional and more convenient mechanisms to get and set the relevant information. 
 * 
 * @author Yannick DOMINGUEZ
 */
class Node<NodeClass:Node<NodeClass>> extends NodeBase<NodeClass>
{	
	/**
	 * A value representing the underlying object
	 */
	public var nodeType(get_nodeType, never):Int;
	
	/**
	 * The value of this node, depending on its type.
	 * When it is defined to be null, setting it has no effect,
	 * including if the node is read-only
	 */
	public var nodeValue(get_nodeValue, set_nodeValue):String;
	
	/**
	 * The name of this node, depending on its type
	 */
	public var nodeName(get_nodeName, never):String;
	
	/**
	 * A NamedNodeMap containing the attributes of this node 
	 * (if it is an Element) or null otherwise.
	 */
	public var attributes(default, null):NamedNodeMap<NodeClass>;
	
	/**
	 * The Document object associated with this node. 
	 * This is also the Document object used to create new nodes.
	 * When this node is a Document or a DocumentType
	 * which is not used with any Document yet, this is null.
	 */
	public var ownerDocument(default, set_ownerDocument):Document;
	
	/**
	 * class constructor
	 */
	public function new() 
	{
		super();
	}
	
	//////////////////////////////////////////////////////////////////////////////////////////
	// PUBLIC METHODS
	//////////////////////////////////////////////////////////////////////////////////////////
	
	/**
	 * Returns a duplicate of this node, i.e., serves as a generic copy constructor for nodes.
	 * The duplicate node has no parent (parentNode is null) and no user data. 
	 * User data associated to the imported node is not carried over. However, if any UserDataHandlers
	 * has been specified along with the associated data these handlers will be called with
	 * the appropriate parameters before this method returns.
	 * 
	 * Cloning an Element copies all attributes and their values, including those generated by the
	 * XML processor to represent defaulted attributes, but this method does not copy any
	 * children it contains unless it is a deep clone. This includes text contained in an
	 * the Element since the text is contained in a child Text node. Cloning an Attr directly,
	 * as opposed to be cloned as part of an Element cloning operation, returns a specified attribute
	 * (specified is true). Cloning an Attr always clones its children, since they represent its value,
	 * no matter whether this is a deep clone or not. Cloning an EntityReference automatically constructs
	 * its subtree if a corresponding Entity is available, no matter whether this is a deep clone or not.
	 * Cloning any other type of node simply returns a copy of this node.
	 * 
	 * Note that cloning an immutable subtree results in a mutable copy, but the children
	 * of an EntityReference clone are readonly. In addition, clones of unspecified Attr nodes
	 * are specified. And, cloning Document, DocumentType, Entity, and Notation nodes is implementation dependent.
	 * 
	 * @param	deep If true, recursively clone the subtree under the specified node; 
	 * if false, clone only the node itself (and its attributes, if it is an Element).
	 * @return The duplicate node
	 */
	public function cloneNode(deep:Bool):NodeClass
	{
		var clonedNode:Node<NodeClass> = doCloneNode();
		if (deep == true)
		{
			var childLength:Int = childNodes.length;
			for (i in 0...childLength)
			{
				clonedNode.appendChild(childNodes[i].cloneNode(deep));
			}
		}
		return cast(clonedNode);
	}
	
	/**
	 * Returns whether this node (if it is an element) has any attributes. 
	 * Always false for any other Node sub classes
	 */
	public function hasAttributes():Bool
	{
		return false;
	}
	
	//////////////////////////////////////////////////////////////////////////////////////////
	// PRIVATE METHODS
	//////////////////////////////////////////////////////////////////////////////////////////
	
	/**
	 * clone this node and return the clone.
	 * What gets clone varies for each
	 * node type
	 */
	private function doCloneNode():NodeClass
	{
		return cast(new Node<NodeClass>());
	}
	
	//////////////////////////////////////////////////////////////////////////////////////////
	// SETTERS/GETTERS
	//////////////////////////////////////////////////////////////////////////////////////////
	
	private function get_nodeType():Int 
	{
		return -1;
	}
	
	private function get_nodeValue():String 
	{
		return null;
	}
	
	private function set_nodeValue(value:String):String 
	{
		if (value != null)
		{
			//Raised when the node is readonly and if it is not defined to be null.
			throw DOMException.NO_MODIFICATION_ALLOWED_ERR;
		}
		
		return value;
	}
	
	private function set_ownerDocument(value:Document):Document
	{
		return ownerDocument = value;
	}
	
	private function get_nodeName():String
	{
		return null;
	}
}